/**
 * Knoux Clipboard AI - Application Lifecycle Manager
 * Manages application startup, shutdown, and state transitions
 * Generated by Knoux — Abu Retaj
 * Clipboard Intelligence • Desktop Precision • Premium Engineering
 */

import { app, powerMonitor, dialog } from 'electron';
import { logger, createLogger } from '../shared/logger';
import { AppConfig } from '../shared/config-schema';
import { APP_NAME, APP_VERSION } from '../shared/constants';
import { AppLifecycleState, AppEventType } from '../shared/enums';

// ==================== TYPES ====================

/**
 * Application lifecycle state
 */
export interface LifecycleState {
  currentState: AppLifecycleState;
  previousState: AppLifecycleState;
  startTime: number;
  activeTime: number;
  idleTime: number;
  sessionId: string;
  lastActivity: number;
  errorCount: number;
  recoveryAttempts: number;
}

/**
 * Lifecycle manager configuration
 */
export interface LifecycleManagerConfig {
  startOnLogin: boolean;
  checkForUpdates: boolean;
  updateChannel: string;
  analyticsEnabled: boolean;
  crashReportsEnabled: boolean;
  logsRetentionDays: number;
  performanceMode: 'power-saver' | 'balanced' | 'performance';
}

/**
 * Recovery options
 */
export interface RecoveryOptions {
  maxAttempts: number;
  attemptDelay: number;
  resetOnSuccess: boolean;
  logRecovery: boolean;
}

// ==================== CONSTANTS ====================

/**
 * Default recovery options
 */
const DEFAULT_RECOVERY_OPTIONS: RecoveryOptions = {
  maxAttempts: 3,
  attemptDelay: 1000,
  resetOnSuccess: true,
  logRecovery: true,
};

/**
 * State transition timeout (ms)
 */
const STATE_TRANSITION_TIMEOUT = 5000;

/**
 * Auto-save interval (ms)
 */
const AUTO_SAVE_INTERVAL = 30000;

/**
 * Idle detection threshold (ms)
 */
const IDLE_DETECTION_THRESHOLD = 300000; // 5 minutes

// ==================== LIFECYCLE MANAGER CLASS ====================

export class LifecycleManager {
  private config: LifecycleManagerConfig;
  private logger = createLogger({ module: 'lifecycle-manager' });
  private state: LifecycleState;
  private recoveryOptions: RecoveryOptions;
  private autoSaveTimer: NodeJS.Timeout | null = null;
  private activityMonitorTimer: NodeJS.Timeout | null = null;
  private isShuttingDown = false;
  private stateChangeListeners: Array<(oldState: AppLifecycleState, newState: AppLifecycleState) => void> = [];
  private errorHandlers: Array<(error: Error) => void> = [];

  constructor(config: AppConfig) {
    this.config = this.mapConfig(config);
    this.recoveryOptions = DEFAULT_RECOVERY_OPTIONS;
    this.state = this.createInitialState();
    
    this.initialize();
  }

  // ==================== INITIALIZATION ====================

  /**
   * Map application config to lifecycle manager config
   */
  private mapConfig(config: AppConfig): LifecycleManagerConfig {
    return {
      startOnLogin: config.system.settings.startOnLogin,
      checkForUpdates: config.system.settings.checkForUpdates,
      updateChannel: config.system.settings.updateChannel,
      analyticsEnabled: config.system.settings.analyticsEnabled,
      crashReportsEnabled: config.system.settings.crashReportsEnabled,
      logsRetentionDays: config.system.settings.logsRetentionDays,
      performanceMode: config.system.settings.performanceMode,
    };
  }

  /**
   * Create initial lifecycle state
   */
  private createInitialState(): LifecycleState {
    const now = Date.now();
    
    return {
      currentState: AppLifecycleState.BOOTING,
      previousState: AppLifecycleState.BOOTING,
      startTime: now,
      activeTime: 0,
      idleTime: 0,
      sessionId: this.generateSessionId(),
      lastActivity: now,
      errorCount: 0,
      recoveryAttempts: 0,
    };
  }

  /**
   * Generate unique session ID
   */
  private generateSessionId(): string {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Initialize lifecycle manager
   */
  private initialize(): void {
    this.logger.info('Initializing lifecycle manager', {
      config: this.config,
      sessionId: this.state.sessionId,
    });

    // Setup global error handlers
    this.setupErrorHandlers();

    // Setup power monitor events
    this.setupPowerMonitor();

    // Setup auto-save
    this.setupAutoSave();

    // Setup activity monitoring
    this.setupActivityMonitoring();

    // Transition to ready state
    setTimeout(() => {
      this.transitionState(AppLifecycleState.READY);
    }, 100);

    this.logger.debug('Lifecycle manager initialized');
  }

  // ==================== STATE MANAGEMENT ====================

  /**
   * Transition to a new application state
   */
  private transitionState(newState: AppLifecycleState): void {
    const oldState = this.state.currentState;
    
    // Validate state transition
    if (!this.isValidTransition(oldState, newState)) {
      this.logger.warn('Invalid state transition attempted', {
        oldState,
        newState,
      });
      return;
    }

    // Update state
    this.state.previousState = oldState;
    this.state.currentState = newState;
    this.state.lastActivity = Date.now();

    // Update time tracking
    this.updateTimeTracking(oldState, newState);

    // Log state transition
    this.logger.info('Application state transition', {
      oldState,
      newState,
      sessionId: this.state.sessionId,
      activeTime: this.formatTime(this.state.activeTime),
      idleTime: this.formatTime(this.state.idleTime),
    });

    // Notify listeners
    this.notifyStateChangeListeners(oldState, newState);

    // Perform state-specific actions
    this.handleStateTransition(oldState, newState);
  }

  /**
   * Check if state transition is valid
   */
  private isValidTransition(from: AppLifecycleState, to: AppLifecycleState): boolean {
    const validTransitions: Record<AppLifecycleState, AppLifecycleState[]> = {
      [AppLifecycleState.BOOTING]: [AppLifecycleState.READY, AppLifecycleState.ERROR],
      [AppLifecycleState.READY]: [
        AppLifecycleState.ACTIVE,
        AppLifecycleState.IDLE,
        AppLifecycleState.SHUTTING_DOWN,
        AppLifecycleState.ERROR,
      ],
      [AppLifecycleState.ACTIVE]: [
        AppLifecycleState.READY,
        AppLifecycleState.IDLE,
        AppLifecycleState.BACKGROUND,
        AppLifecycleState.SHUTTING_DOWN,
        AppLifecycleState.ERROR,
      ],
      [AppLifecycleState.IDLE]: [
        AppLifecycleState.ACTIVE,
        AppLifecycleState.BACKGROUND,
        AppLifecycleState.SHUTTING_DOWN,
        AppLifecycleState.ERROR,
      ],
      [AppLifecycleState.BACKGROUND]: [
        AppLifecycleState.ACTIVE,
        AppLifecycleState.IDLE,
        AppLifecycleState.SUSPENDED,
        AppLifecycleState.SHUTTING_DOWN,
        AppLifecycleState.ERROR,
      ],
      [AppLifecycleState.SUSPENDED]: [
        AppLifecycleState.BACKGROUND,
        AppLifecycleState.SHUTTING_DOWN,
        AppLifecycleState.ERROR,
      ],
      [AppLifecycleState.SHUTTING_DOWN]: [AppLifecycleState.TERMINATED, AppLifecycleState.ERROR],
      [AppLifecycleState.TERMINATED]: [],
      [AppLifecycleState.ERROR]: [AppLifecycleState.READY, AppLifecycleState.SHUTTING_DOWN],
    };

    return validTransitions[from]?.includes(to) || false;
  }

  /**
   * Update time tracking based on state transition
   */
  private updateTimeTracking(oldState: AppLifecycleState, newState: AppLifecycleState): void {
    const now = Date.now();
    const timeDiff = now - this.state.lastActivity;

    // Update time based on previous state
    switch (oldState) {
      case AppLifecycleState.ACTIVE:
        this.state.activeTime += timeDiff;
        break;
      case AppLifecycleState.IDLE:
      case AppLifecycleState.BACKGROUND:
      case AppLifecycleState.SUSPENDED:
        this.state.idleTime += timeDiff;
        break;
    }

    this.state.lastActivity = now;
  }

  /**
   * Handle state-specific actions
   */
  private handleStateTransition(oldState: AppLifecycleState, newState: AppLifecycleState): void {
    switch (newState) {
      case AppLifecycleState.ACTIVE:
        this.onActive();
        break;
      case AppLifecycleState.IDLE:
        this.onIdle();
        break;
      case AppLifecycleState.BACKGROUND:
        this.onBackground();
        break;
      case AppLifecycleState.SUSPENDED:
        this.onSuspended();
        break;
      case AppLifecycleState.SHUTTING_DOWN:
        this.onShuttingDown();
        break;
      case AppLifecycleState.ERROR:
        this.onError();
        break;
    }
  }

  // ==================== STATE EVENT HANDLERS ====================

  /**
   * Application became active
   */
  private onActive(): void {
    this.logger.debug('Application became active');
    
    // Resume auto-save if it was paused
    if (!this.autoSaveTimer) {
      this.setupAutoSave();
    }
    
    // Resume activity monitoring
    if (!this.activityMonitorTimer) {
      this.setupActivityMonitoring();
    }
    
    // Adjust performance mode if needed
    this.adjustPerformanceMode();
  }

  /**
   * Application became idle
   */
  private onIdle(): void {
    this.logger.debug('Application became idle');
    
    // Reduce resource usage
    this.reduceResourceUsage();
  }

  /**
   * Application moved to background
   */
  private onBackground(): void {
    this.logger.debug('Application moved to background');
    
    // Pause non-essential operations
    this.pauseNonEssentialOperations();
  }

  /**
   * Application suspended
   */
  private onSuspended(): void {
    this.logger.debug('Application suspended');
    
    // Stop all timers and background tasks
    this.stopAllTimers();
    
    // Release resources
    this.releaseResources();
  }

  /**
   * Application shutting down
   */
  private onShuttingDown(): void {
    this.logger.info('Application shutting down');
    this.isShuttingDown = true;
    
    // Stop all timers
    this.stopAllTimers();
    
    // Save final state
    this.saveApplicationState();
    
    // Cleanup resources
    this.cleanupResources();
    
    // Log shutdown statistics
    this.logShutdownStatistics();
  }

  /**
   * Application error state
   */
  private onError(): void {
    this.state.errorCount++;
    this.logger.error('Application entered error state', {
      errorCount: this.state.errorCount,
      recoveryAttempts: this.state.recoveryAttempts,
    });
    
    // Attempt recovery if not shutting down
    if (!this.isShuttingDown && this.state.recoveryAttempts < this.recoveryOptions.maxAttempts) {
      this.attemptRecovery();
    }
  }

  // ==================== RESOURCE MANAGEMENT ====================

  /**
   * Adjust performance mode based on configuration
   */
  private adjustPerformanceMode(): void {
    const { performanceMode } = this.config;
    
    switch (performanceMode) {
      case 'power-saver':
        this.enablePowerSaverMode();
        break;
      case 'performance':
        this.enablePerformanceMode();
        break;
      default:
        this.enableBalancedMode();
        break;
    }
  }

  /**
   * Enable power saver mode
   */
  private enablePowerSaverMode(): void {
    this.logger.debug('Enabling power saver mode');
    
    // Reduce polling intervals
    // Lower CPU priority
    // Disable non-essential features
  }

  /**
   * Enable balanced mode
   */
  private enableBalancedMode(): void {
    this.logger.debug('Enabling balanced mode');
    
    // Use default settings
  }

  /**
   * Enable performance mode
   */
  private enablePerformanceMode(): void {
    this.logger.debug('Enabling performance mode');
    
    // Increase polling intervals
    // Enable all features
    // Optimize for speed
  }

  /**
   * Reduce resource usage for idle state
   */
  private reduceResourceUsage(): void {
    this.logger.debug('Reducing resource usage');
    
    // Increase auto-save interval
    if (this.autoSaveTimer) {
      clearInterval(this.autoSaveTimer);
      this.autoSaveTimer = setInterval(() => {
        this.saveApplicationState();
      }, AUTO_SAVE_INTERVAL * 2); // Double the interval
    }
    
    // Pause non-critical background tasks
  }

  /**
   * Pause non-essential operations
   */
  private pauseNonEssentialOperations(): void {
    this.logger.debug('Pausing non-essential operations');
    
    // Pause clipboard monitoring
    // Pause AI processing
    // Reduce logging frequency
  }

  /**
   * Stop all timers
   */
  private stopAllTimers(): void {
    if (this.autoSaveTimer) {
      clearInterval(this.autoSaveTimer);
      this.autoSaveTimer = null;
    }
    
    if (this.activityMonitorTimer) {
      clearInterval(this.activityMonitorTimer);
      this.activityMonitorTimer = null;
    }
  }

  /**
   * Release resources
   */
  private releaseResources(): void {
    this.logger.debug('Releasing resources');
    
    // Clear caches
    // Close database connections
    // Release memory
  }

  /**
   * Cleanup resources before shutdown
   */
  private cleanupResources(): void {
    this.logger.debug('Cleaning up resources');
    
    // Close all open files
    // Flush all pending writes
    // Disconnect from external services
  }

  // ==================== ERROR HANDLING & RECOVERY ====================

  /**
   * Setup global error handlers
   */
  private setupErrorHandlers(): void {
    // Uncaught exceptions
    process.on('uncaughtException', (error: Error) => {
      this.handleError(error, 'uncaught-exception');
    });

    // Unhandled promise rejections
    process.on('unhandledRejection', (reason: any, promise: Promise<any>) => {
      const error = new Error(reason?.message || 'Unhandled promise rejection');
      this.handleError(error, 'unhandled-rejection');
    });

    // App-specific error handler
    app.on('renderer-process-crashed', (event, webContents, killed) => {
      const error = new Error(`Renderer process crashed: ${killed ? 'killed' : 'crashed'}`);
      this.handleError(error, 'renderer-crash');
    });

    this.logger.debug('Global error handlers setup completed');
  }

  /**
   * Handle application error
   */
  private handleError(error: Error, source: string): void {
    this.logger.error(`Application error from ${source}`, error, {
      errorCount: this.state.errorCount + 1,
      currentState: this.state.currentState,
    });

    // Notify error handlers
    this.notifyErrorHandlers(error);

    // Transition to error state if not already shutting down
    if (this.state.currentState !== AppLifecycleState.SHUTTING_DOWN) {
      this.transitionState(AppLifecycleState.ERROR);
    }
  }

  /**
   * Attempt recovery from error state
   */
  private attemptRecovery(): void {
    this.state.recoveryAttempts++;
    
    this.logger.info('Attempting application recovery', {
      attempt: this.state.recoveryAttempts,
      maxAttempts: this.recoveryOptions.maxAttempts,
    });

    // Delay before recovery attempt
    setTimeout(() => {
      try {
        // Attempt recovery actions
        this.performRecoveryActions();
        
        // If recovery successful, transition back to ready state
        if (this.recoveryOptions.resetOnSuccess) {
          this.state.recoveryAttempts = 0;
        }
        
        this.transitionState(AppLifecycleState.READY);
        
        this.logger.info('Recovery successful', {
          attempt: this.state.recoveryAttempts,
        });
        
      } catch (recoveryError) {
        this.logger.error('Recovery attempt failed', recoveryError as Error, {
          attempt: this.state.recoveryAttempts,
        });
        
        // Try again if we haven't reached max attempts
        if (this.state.recoveryAttempts < this.recoveryOptions.maxAttempts) {
          this.attemptRecovery();
        } else {
          this.logger.error('Maximum recovery attempts reached, giving up');
          this.showRecoveryFailedDialog();
        }
      }
    }, this.recoveryOptions.attemptDelay);
  }

  /**
   * Perform recovery actions
   */
  private performRecoveryActions(): void {
    this.logger.debug('Performing recovery actions');
    
    // Restart clipboard monitoring
    // Reinitialize database connections
    // Clear corrupted caches
    // Restart background services
  }

  /**
   * Show recovery failed dialog
   */
  private showRecoveryFailedDialog(): void {
    if (this.isShuttingDown) {
      return;
    }

    dialog.showErrorBox(
      `${APP_NAME} - Recovery Failed`,
      `The application encountered multiple errors and failed to recover.\n\n` +
      `Session ID: ${this.state.sessionId}\n` +
      `Error Count: ${this.state.errorCount}\n` +
      `Recovery Attempts: ${this.state.recoveryAttempts}\n\n` +
      `The application will now close. Please restart it.\n\n` +
      `Error details have been saved to the log file.`
    );
    
    this.shutdown();
  }

  // ==================== ACTIVITY MONITORING ====================

  /**
   * Setup activity monitoring
   */
  private setupActivityMonitoring(): void {
    this.activityMonitorTimer = setInterval(() => {
      this.checkActivity();
    }, 60000); // Check every minute
    
    this.logger.debug('Activity monitoring setup');
  }

  /**
   * Check application activity
   */
  private checkActivity(): void {
    const now = Date.now();
    const timeSinceActivity = now - this.state.lastActivity;
    
    // Check if application is idle
    if (timeSinceActivity > IDLE_DETECTION_THRESHOLD && 
        this.state.currentState === AppLifecycleState.ACTIVE) {
      this.transitionState(AppLifecycleState.IDLE);
    }
    
    // Update activity time
    this.updateActivityTime();
  }

  /**
   * Update activity time based on current state
   */
  private updateActivityTime(): void {
    const now = Date.now();
    const timeDiff = now - this.state.lastActivity;
    
    switch (this.state.currentState) {
      case AppLifecycleState.ACTIVE:
        this.state.activeTime += timeDiff;
        break;
      case AppLifecycleState.IDLE:
      case AppLifecycleState.BACKGROUND:
      case AppLifecycleState.SUSPENDED:
        this.state.idleTime += timeDiff;
        break;
    }
    
    this.state.lastActivity = now;
  }

  // ==================== POWER MONITOR ====================

  /**
   * Setup power monitor events
   */
  private setupPowerMonitor(): void {
    if (!powerMonitor) {
      return;
    }
    
    // System suspending
    powerMonitor.on('suspend', () => {
      this.logger.debug('System suspending');
      this.transitionState(AppLifecycleState.SUSPENDED);
    });
    
    // System resuming
    powerMonitor.on('resume', () => {
      this.logger.debug('System resuming');
      this.transitionState(AppLifecycleState.READY);
    });
    
    // AC power connected
    powerMonitor.on('on-ac', () => {
      this.logger.debug('AC power connected');
      // Adjust performance mode if needed
    });
    
    // AC power disconnected
    powerMonitor.on('on-battery', () => {
      this.logger.debug('AC power disconnected');
      // Adjust performance mode for battery
    });
    
    this.logger.debug('Power monitor setup completed');
  }

  // ==================== AUTO-SAVE ====================

  /**
   * Setup auto-save timer
   */
  private setupAutoSave(): void {
    this.autoSaveTimer = setInterval(() => {
      this.saveApplicationState();
    }, AUTO_SAVE_INTERVAL);
    
    this.logger.debug('Auto-save setup', { interval: AUTO_SAVE_INTERVAL });
  }

  /**
   * Save application state
   */
  private saveApplicationState(): void {
    if (this.isShuttingDown) {
      return;
    }
    
    try {
      // Save clipboard history
      // Save application settings
      // Backup database
      
      this.logger.debug('Application state saved');
    } catch (error) {
      this.logger.error('Failed to save application state', error as Error);
    }
  }

  // ==================== PUBLIC METHODS ====================

  /**
   * Get current lifecycle state
   */
  public getState(): LifecycleState {
    return { ...this.state };
  }

  /**
   * Get current state name
   */
  public getCurrentState(): AppLifecycleState {
    return this.state.currentState;
  }

  /**
   * Check if application is active
   */
  public isActive(): boolean {
    return this.state.currentState === AppLifecycleState.ACTIVE;
  }

  /**
   * Check if application is idle
   */
  public isIdle(): boolean {
    return this.state.currentState === AppLifecycleState.IDLE;
  }

  /**
   * Check if application is shutting down
   */
  public isShutdown(): boolean {
    return this.isShuttingDown;
  }

  /**
   * Report user activity
   */
  public reportActivity(): void {
    this.state.lastActivity = Date.now();
    
    // Transition to active if idle
    if (this.state.currentState === AppLifecycleState.IDLE) {
      this.transitionState(AppLifecycleState.ACTIVE);
    }
  }

  /**
   * Update configuration
   */
  public updateConfig(config: AppConfig): void {
    const newConfig = this.mapConfig(config);
    const configChanged = JSON.stringify(this.config) !== JSON.stringify(newConfig);
    
    this.config = newConfig;

    if (configChanged) {
      this.logger.info('Lifecycle manager configuration updated', {
        newConfig: this.config,
      });

      // Re-adjust performance mode if needed
      if (this.isActive()) {
        this.adjustPerformanceMode();
      }
    }
  }

  /**
   * Add state change listener
   */
  public onStateChange(listener: (oldState: AppLifecycleState, newState: AppLifecycleState) => void): void {
    this.stateChangeListeners.push(listener);
  }

  /**
   * Remove state change listener
   */
  public removeStateChangeListener(listener: (oldState: AppLifecycleState, newState: AppLifecycleState) => void): void {
    const index = this.stateChangeListeners.indexOf(listener);
    if (index > -1) {
      this.stateChangeListeners.splice(index, 1);
    }
  }

  /**
   * Add error handler
   */
  public onError(handler: (error: Error) => void): void {
    this.errorHandlers.push(handler);
  }

  /**
   * Remove error handler
   */
  public removeErrorHandler(handler: (error: Error) => void): void {
    const index = this.errorHandlers.indexOf(handler);
    if (index > -1) {
      this.errorHandlers.splice(index, 1);
    }
  }

  /**
   * Gracefully shutdown application
   */
  public shutdown(): void {
    if (this.isShuttingDown) {
      return;
    }
    
    this.logger.info('Initiating graceful shutdown');
    this.transitionState(AppLifecycleState.SHUTTING_DOWN);
    
    // Allow time for cleanup
    setTimeout(() => {
      this.transitionState(AppLifecycleState.TERMINATED);
      app.quit();
    }, 1000);
  }

  /**
   * Force shutdown application
   */
  public forceShutdown(): void {
    this.logger.warn('Initiating force shutdown');
    this.isShuttingDown = true;
    this.stopAllTimers();
    app.exit(1);
  }

  // ==================== UTILITY METHODS ====================

  /**
   * Notify state change listeners
   */
  private notifyStateChangeListeners(oldState: AppLifecycleState, newState: AppLifecycleState): void {
    for (const listener of this.stateChangeListeners) {
      try {
        listener(oldState, newState);
      } catch (error) {
        this.logger.error('State change listener error', error as Error);
      }
    }
  }

  /**
   * Notify error handlers
   */
  private notifyErrorHandlers(error: Error): void {
    for (const handler of this.errorHandlers) {
      try {
        handler(error);
      } catch (handlerError) {
        this.logger.error('Error handler error', handlerError as Error);
      }
    }
  }

  /**
   * Format time in milliseconds to human readable string
   */
  private formatTime(ms: number): string {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    
    if (hours > 0) {
      return `${hours}h ${minutes % 60}m`;
    } else if (minutes > 0) {
      return `${minutes}m ${seconds % 60}s`;
    } else {
      return `${seconds}s`;
    }
  }

  /**
   * Log shutdown statistics
   */
  private logShutdownStatistics(): void {
    const totalTime = Date.now() - this.state.startTime;
    const uptime = this.formatTime(totalTime);
    
    this.logger.info('Application shutdown statistics', {
      sessionId: this.state.sessionId,
      startTime: new Date(this.state.startTime).toISOString(),
      endTime: new Date().toISOString(),
      uptime,
      activeTime: this.formatTime(this.state.activeTime),
      idleTime: this.formatTime(this.state.idleTime),
      errorCount: this.state.errorCount,
      recoveryAttempts: this.state.recoveryAttempts,
      finalState: this.state.currentState,
    });
  }
}
