/**
 * Knoux Clipboard AI - Electron Main Process Entry Point
 * Main application window and core Electron initialization
 * Generated by Knoux — Abu Retaj
 * Clipboard Intelligence • Desktop Precision • Premium Engineering
 */

import { app, BrowserWindow, screen, ipcMain, dialog, Menu, Tray, nativeImage, shell } from 'electron';
import { join, dirname, basename } from 'path';
import { format } from 'url';
import { logger, createLogger } from '../shared/logger';
import { APP_NAME, APP_VERSION, IPC_CHANNELS, UI, APP_MODES } from '../shared/constants';
import { OperatingSystem, AppEventType } from '../shared/enums';
import { AppConfig, validateAppConfig } from '../shared/config-schema';
import { WindowManager } from './window-manager';
import { TrayManager } from './tray';
import { LifecycleManager } from './lifecycle';

// ==================== GLOBAL STATE ====================

class KnouxMainApp {
  private mainWindow: BrowserWindow | null = null;
  private windowManager: WindowManager | null = null;
  private trayManager: TrayManager | null = null;
  private lifecycleManager: LifecycleManager | null = null;
  private appLogger = createLogger({ module: 'main' });
  private isQuitting = false;
  private config: AppConfig;
  private appDataPath: string;
  private configPath: string;
  private isDevelopment: boolean;
  private isProduction: boolean;

  constructor() {
    this.isDevelopment = process.env.NODE_ENV === 'development' || !app.isPackaged;
    this.isProduction = !this.isDevelopment;
    this.appDataPath = app.getPath('userData');
    this.configPath = join(this.appDataPath, 'knoux-config.json');
    
    // Load or create default configuration
    this.config = this.loadConfiguration();
    
    this.appLogger.info(`${APP_NAME} v${APP_VERSION} initializing`, {
      platform: process.platform,
      arch: process.arch,
      nodeVersion: process.version,
      electronVersion: process.versions.electron,
      isDevelopment: this.isDevelopment,
      isProduction: this.isProduction,
      appDataPath: this.appDataPath,
    });
  }

  // ==================== CONFIGURATION MANAGEMENT ====================

  /**
   * Load application configuration from file or create default
   */
  private loadConfiguration(): AppConfig {
    try {
      const fs = require('fs');
      const path = require('path');
      
      // Ensure app data directory exists
      if (!fs.existsSync(this.appDataPath)) {
        fs.mkdirSync(this.appDataPath, { recursive: true });
      }
      
      // Try to load existing configuration
      if (fs.existsSync(this.configPath)) {
        const configData = fs.readFileSync(this.configPath, 'utf8');
        const parsedConfig = JSON.parse(configData);
        
        // Validate against schema
        const validatedConfig = validateAppConfig(parsedConfig);
        
        this.appLogger.info('Configuration loaded successfully', {
          configPath: this.configPath,
          version: validatedConfig.version,
        });
        
        return validatedConfig;
      }
      
      // Create default configuration
      const defaultConfig = validateAppConfig({});
      
      // Save default configuration
      fs.writeFileSync(
        this.configPath,
        JSON.stringify(defaultConfig, null, 2),
        'utf8'
      );
      
      this.appLogger.info('Default configuration created', {
        configPath: this.configPath,
      });
      
      return defaultConfig;
      
    } catch (error) {
      this.appLogger.error('Failed to load configuration', error as Error, {
        configPath: this.configPath,
      });
      
      // Fall back to default configuration
      return validateAppConfig({});
    }
  }

  /**
   * Save configuration to file
   */
  private saveConfiguration(): void {
    try {
      const fs = require('fs');
      const path = require('path');
      
      // Update metadata
      this.config.metadata.updatedAt = Date.now();
      this.config.metadata.lastModifiedBy = 'main';
      
      // Save to file
      fs.writeFileSync(
        this.configPath,
        JSON.stringify(this.config, null, 2),
        'utf8'
      );
      
      this.appLogger.debug('Configuration saved', {
        configPath: this.configPath,
        updatedAt: this.config.metadata.updatedAt,
      });
      
    } catch (error) {
      this.appLogger.error('Failed to save configuration', error as Error, {
        configPath: this.configPath,
      });
    }
  }

  // ==================== WINDOW MANAGEMENT ====================

  /**
   * Create the main application window
   */
  private createMainWindow(): void {
    this.appLogger.info('Creating main window');
    
    // Calculate window position (centered)
    const { width, height } = screen.getPrimaryDisplay().workAreaSize;
    const windowWidth = this.config.ui.window.defaultWidth;
    const windowHeight = this.config.ui.window.defaultHeight;
    const x = Math.floor((width - windowWidth) / 2);
    const y = Math.floor((height - windowHeight) / 2);
    
    // Create the browser window
    this.mainWindow = new BrowserWindow({
      x,
      y,
      width: windowWidth,
      height: windowHeight,
      minWidth: this.config.ui.window.minWidth,
      minHeight: this.config.ui.window.minHeight,
      maxWidth: this.config.ui.window.maxWidth,
      maxHeight: this.config.ui.window.maxHeight,
      title: APP_NAME,
      icon: join(__dirname, '../../assets/app-icon.ico'),
      frame: true,
      titleBarStyle: 'hiddenInset',
      autoHideMenuBar: true,
      show: !this.config.ui.window.startMinimized,
      webPreferences: {
        preload: join(__dirname, 'preload.js'),
        nodeIntegration: false,
        contextIsolation: true,
        sandbox: true,
        webSecurity: true,
        allowRunningInsecureContent: false,
        experimentalFeatures: false,
        webgl: false,
        plugins: false,
        navigateOnDragDrop: false,
        safeDialogs: true,
        disableBlinkFeatures: 'Auxclick',
      },
    });
    
    // Load the app
    if (this.isDevelopment) {
      // Development: Load from Vite dev server
      this.mainWindow.loadURL('http://localhost:5173');
      this.mainWindow.webContents.openDevTools({ mode: 'detach' });
    } else {
      // Production: Load from built files
      this.mainWindow.loadFile(join(__dirname, '../renderer/index.html'));
    }
    
    // Window event handlers
    this.setupWindowEvents();
    
    // Create window manager
    this.windowManager = new WindowManager(this.mainWindow, this.config);
    
    this.appLogger.info('Main window created successfully', {
      width: windowWidth,
      height: windowHeight,
      position: { x, y },
      showOnStart: !this.config.ui.window.startMinimized,
    });
  }

  /**
   * Setup window event handlers
   */
  private setupWindowEvents(): void {
    if (!this.mainWindow) return;
    
    // Window ready to show
    this.mainWindow.on('ready-to-show', () => {
      this.appLogger.debug('Main window ready to show');
      
      // Restore window state if remembered
      if (this.config.ui.window.rememberPosition) {
        this.windowManager?.restoreWindowState();
      }
      
      // Show window if not starting minimized
      if (!this.config.ui.window.startMinimized) {
        this.mainWindow?.show();
      }
    });
    
    // Window closed
    this.mainWindow.on('closed', () => {
      this.appLogger.info('Main window closed');
      this.mainWindow = null;
      this.windowManager = null;
    });
    
    // Window focus
    this.mainWindow.on('focus', () => {
      this.appLogger.debug('Main window focused');
      this.sendToRenderer(AppEventType.WINDOW_STATE_CHANGED, { focused: true });
    });
    
    this.mainWindow.on('blur', () => {
      this.appLogger.debug('Main window blurred');
      this.sendToRenderer(AppEventType.WINDOW_STATE_CHANGED, { focused: false });
    });
    
    // Window minimize/restore
    this.mainWindow.on('minimize', () => {
      this.appLogger.debug('Main window minimized');
      this.sendToRenderer(AppEventType.WINDOW_STATE_CHANGED, { minimized: true });
    });
    
    this.mainWindow.on('restore', () => {
      this.appLogger.debug('Main window restored');
      this.sendToRenderer(AppEventType.WINDOW_STATE_CHANGED, { minimized: false });
    });
    
    // Prevent new window creation (security)
    this.mainWindow.webContents.setWindowOpenHandler(({ url }) => {
      // Allow certain URLs to open in default browser
      if (url.startsWith('http://') || url.startsWith('https://')) {
        shell.openExternal(url).catch(err => {
          this.appLogger.warn('Failed to open external URL', { url, error: err.message });
        });
      }
      return { action: 'deny' };
    });
  }

  // ==================== IPC HANDLERS ====================

  /**
   * Setup IPC communication handlers
   */
  private setupIpcHandlers(): void {
    this.appLogger.info('Setting up IPC handlers');
    
    // System IPC handlers
    ipcMain.handle(IPC_CHANNELS.SYSTEM.GET_PLATFORM, () => {
      return process.platform;
    });
    
    ipcMain.handle(IPC_CHANNELS.SYSTEM.SET_AUTOSTART, async (event, enabled: boolean) => {
      try {
        app.setLoginItemSettings({
          openAtLogin: enabled,
          openAsHidden: this.config.ui.window.startMinimized,
          path: app.getPath('exe'),
          args: this.config.ui.window.startMinimized ? ['--minimized'] : [],
        });
        
        this.config.system.settings.startOnLogin = enabled;
        this.saveConfiguration();
        
        this.appLogger.info('Auto-start settings updated', { enabled });
        return { success: true };
      } catch (error) {
        this.appLogger.error('Failed to set auto-start', error as Error, { enabled });
        return { success: false, error: (error as Error).message };
      }
    });
    
    ipcMain.handle(IPC_CHANNELS.SYSTEM.RESTART_APP, () => {
      this.appLogger.info('Restarting application');
      app.relaunch();
      app.exit(0);
    });
    
    ipcMain.handle(IPC_CHANNELS.SYSTEM.QUIT_APP, () => {
      this.appLogger.info('Quitting application');
      this.isQuitting = true;
      app.quit();
    });
    
    // Settings IPC handlers
    ipcMain.handle(IPC_CHANNELS.SETTINGS.GET_ALL, () => {
      return this.config;
    });
    
    ipcMain.handle(IPC_CHANNELS.SETTINGS.UPDATE, async (event, updates: Partial<AppConfig>) => {
      try {
        // Validate updates against schema
        const updatedConfig = validateAppConfig({ ...this.config, ...updates });
        this.config = updatedConfig;
        
        // Save to disk
        this.saveConfiguration();
        
        // Apply runtime changes
        this.applyRuntimeConfiguration();
        
        // Notify renderer
        this.sendToRenderer(AppEventType.SETTINGS_CHANGED, updates);
        
        this.appLogger.info('Settings updated', { updates: Object.keys(updates) });
        return { success: true };
      } catch (error) {
        this.appLogger.error('Failed to update settings', error as Error, { updates });
        return { success: false, error: (error as Error).message };
      }
    });
    
    ipcMain.handle(IPC_CHANNELS.SETTINGS.RESET, async () => {
      try {
        const defaultConfig = validateAppConfig({});
        this.config = defaultConfig;
        
        // Save to disk
        this.saveConfiguration();
        
        // Apply runtime changes
        this.applyRuntimeConfiguration();
        
        // Notify renderer
        this.sendToRenderer(AppEventType.SETTINGS_CHANGED, defaultConfig);
        
        this.appLogger.info('Settings reset to defaults');
        return { success: true };
      } catch (error) {
        this.appLogger.error('Failed to reset settings', error as Error);
        return { success: false, error: (error as Error).message };
      }
    });
    
    // Window management IPC handlers
    ipcMain.handle('window:minimize', () => {
      this.mainWindow?.minimize();
    });
    
    ipcMain.handle('window:maximize', () => {
      if (this.mainWindow?.isMaximized()) {
        this.mainWindow.unmaximize();
      } else {
        this.mainWindow?.maximize();
      }
    });
    
    ipcMain.handle('window:close', () => {
      this.mainWindow?.close();
    });
    
    ipcMain.handle('window:toggle', () => {
      if (this.mainWindow?.isVisible()) {
        if (this.mainWindow.isMinimized()) {
          this.mainWindow.restore();
        } else {
          this.mainWindow.minimize();
        }
      } else {
        this.mainWindow?.show();
      }
    });
    
    // File dialog IPC handlers
    ipcMain.handle('dialog:showOpenDialog', async (event, options: any) => {
      if (!this.mainWindow) return { canceled: true, filePaths: [] };
      
      const result = await dialog.showOpenDialog(this.mainWindow, options);
      return result;
    });
    
    ipcMain.handle('dialog:showSaveDialog', async (event, options: any) => {
      if (!this.mainWindow) return { canceled: true, filePath: '' };
      
      const result = await dialog.showSaveDialog(this.mainWindow, options);
      return result;
    });
    
    // App events IPC handler
    ipcMain.handle('app:sendEvent', (event, eventType: string, data: any) => {
      this.appLogger.debug('Renderer sent event', { eventType, data });
      // Handle events from renderer if needed
    });
    
    this.appLogger.info('IPC handlers setup completed');
  }

  /**
   * Apply runtime configuration changes
   */
  private applyRuntimeConfiguration(): void {
    // Update window settings
    if (this.mainWindow) {
      // Update window bounds if changed
      const currentBounds = this.mainWindow.getBounds();
      const newBounds = {
        width: this.config.ui.window.defaultWidth,
        height: this.config.ui.window.defaultHeight,
      };
      
      if (currentBounds.width !== newBounds.width || currentBounds.height !== newBounds.height) {
        this.mainWindow.setSize(newBounds.width, newBounds.height);
        this.mainWindow.center(); // Re-center after resize
      }
      
      // Update always on top
      this.mainWindow.setAlwaysOnTop(this.config.ui.window.alwaysOnTop);
      
      // Update window visibility based on tray settings
      if (this.config.ui.window.minimizeToTray && this.trayManager) {
        // Window should minimize to tray
        this.mainWindow.on('close', (event) => {
          if (!this.isQuitting) {
            event.preventDefault();
            this.mainWindow?.hide();
            return false;
          }
        });
      }
    }
    
    // Update tray icon
    if (this.trayManager) {
      this.trayManager.updateConfig(this.config);
    }
    
    // Update lifecycle manager
    if (this.lifecycleManager) {
      this.lifecycleManager.updateConfig(this.config);
    }
    
    this.appLogger.debug('Runtime configuration applied');
  }

  /**
   * Send data to renderer process
   */
  private sendToRenderer(eventType: string, data?: any): void {
    if (!this.mainWindow || this.mainWindow.isDestroyed()) {
      return;
    }
    
    try {
      this.mainWindow.webContents.send('app:event', {
        type: eventType,
        data,
        timestamp: Date.now(),
      });
    } catch (error) {
      this.appLogger.error('Failed to send event to renderer', error as Error, {
        eventType,
      });
    }
  }

  // ==================== APPLICATION LIFECYCLE ====================

  /**
   * Initialize the application
   */
  public async initialize(): Promise<void> {
    this.appLogger.info('Initializing application');
    
    try {
      // Wait for Electron to be ready
      await app.whenReady();
      this.appLogger.debug('Electron app ready');
      
      // Create main window
      this.createMainWindow();
      
      // Setup tray icon
      this.trayManager = new TrayManager(this.mainWindow!, this.config);
      
      // Setup lifecycle manager
      this.lifecycleManager = new LifecycleManager(this.config);
      
      // Setup IPC handlers
      this.setupIpcHandlers();
      
      // Setup global shortcuts
      this.setupGlobalShortcuts();
      
      // Setup single instance lock
      this.setupSingleInstanceLock();
      
      // Setup auto-start if enabled
      if (this.config.system.settings.startOnLogin) {
        app.setLoginItemSettings({
          openAtLogin: true,
          openAsHidden: this.config.ui.window.startMinimized,
          path: app.getPath('exe'),
          args: this.config.ui.window.startMinimized ? ['--minimized'] : [],
        });
      }
      
      this.appLogger.info('Application initialized successfully');
      this.sendToRenderer(AppEventType.APP_STARTED, {
        version: APP_VERSION,
        config: this.config,
      });
      
    } catch (error) {
      this.appLogger.error('Failed to initialize application', error as Error);
      throw error;
    }
  }

  /**
   * Setup global keyboard shortcuts
   */
  private setupGlobalShortcuts(): void {
    if (!this.config.ui.hotkeys.enabled) {
      this.appLogger.debug('Global shortcuts disabled');
      return;
    }
    
    const { globalShortcut } = require('electron');
    
    try {
      // Register toggle window hotkey
      if (this.config.ui.hotkeys.toggleWindow) {
        const registered = globalShortcut.register(
          this.config.ui.hotkeys.toggleWindow,
          () => {
            this.appLogger.debug('Toggle window hotkey triggered');
            this.sendToRenderer(AppEventType.HOTKEY_TRIGGERED, {
              action: 'toggle_window',
            });
            
            if (this.mainWindow) {
              if (this.mainWindow.isVisible()) {
                this.mainWindow.hide();
              } else {
                this.mainWindow.show();
                this.mainWindow.focus();
              }
            }
          }
        );
        
        if (registered) {
          this.appLogger.debug('Toggle window hotkey registered', {
            shortcut: this.config.ui.hotkeys.toggleWindow,
          });
        }
      }
      
      // Register quick search hotkey
      if (this.config.ui.hotkeys.quickSearch) {
        const registered = globalShortcut.register(
          this.config.ui.hotkeys.quickSearch,
          () => {
            this.appLogger.debug('Quick search hotkey triggered');
            this.sendToRenderer(AppEventType.HOTKEY_TRIGGERED, {
              action: 'quick_search',
            });
            
            if (this.mainWindow) {
              this.mainWindow.show();
              this.mainWindow.focus();
              this.sendToRenderer('focus-search', {});
            }
          }
        );
        
        if (registered) {
          this.appLogger.debug('Quick search hotkey registered', {
            shortcut: this.config.ui.hotkeys.quickSearch,
          });
        }
      }
      
    } catch (error) {
      this.appLogger.error('Failed to register global shortcuts', error as Error);
    }
  }

  /**
   * Setup single instance lock to prevent multiple instances
   */
  private setupSingleInstanceLock(): void {
    const gotTheLock = app.requestSingleInstanceLock();
    
    if (!gotTheLock) {
      this.appLogger.warn('Another instance is already running, quitting');
      app.quit();
      return;
    }
    
    app.on('second-instance', (event, commandLine, workingDirectory) => {
      this.appLogger.debug('Second instance attempted, focusing existing window');
      
      // Someone tried to run a second instance, focus our window instead
      if (this.mainWindow) {
        if (this.mainWindow.isMinimized()) {
          this.mainWindow.restore();
        }
        this.mainWindow.show();
        this.mainWindow.focus();
      }
    });
  }

  /**
   * Setup application event handlers
   */
  private setupAppEventHandlers(): void {
    // App will quit
    app.on('will-quit', (event) => {
      this.appLogger.info('Application will quit');
      
      // Unregister all global shortcuts
      const { globalShortcut } = require('electron');
      globalShortcut.unregisterAll();
      
      // Save window state
      if (this.mainWindow && this.config.ui.window.rememberPosition) {
        this.windowManager?.saveWindowState();
      }
      
      // Save configuration
      this.saveConfiguration();
      
      // Close tray
      if (this.trayManager) {
        this.trayManager.destroy();
      }
      
      // Close lifecycle manager
      if (this.lifecycleManager) {
        this.lifecycleManager.shutdown();
      }
    });
    
    // App window all closed
    app.on('window-all-closed', () => {
      this.appLogger.debug('All windows closed');
      
      // On macOS, keep the app running when all windows are closed
      if (process.platform !== 'darwin') {
        app.quit();
      }
    });
    
    // App activate (macOS)
    app.on('activate', () => {
      this.appLogger.debug('App activated (macOS)');
      
      // On macOS, re-create the window when the dock icon is clicked
      if (this.mainWindow === null) {
        this.createMainWindow();
      } else {
        this.mainWindow.show();
        this.mainWindow.focus();
      }
    });
    
    // Before quit
    app.on('before-quit', (event) => {
      this.appLogger.debug('Before quit event');
      this.isQuitting = true;
    });
  }

  /**
   * Get the main window instance
   */
  public getMainWindow(): BrowserWindow | null {
    return this.mainWindow;
  }

  /**
   * Get the application configuration
   */
  public getConfig(): AppConfig {
    return this.config;
  }

  /**
   * Check if application is quitting
   */
  public isAppQuitting(): boolean {
    return this.isQuitting;
  }
}

// ==================== APPLICATION ENTRY POINT ====================

// Handle uncaught exceptions
process.on('uncaughtException', (error: Error) => {
  console.error('Uncaught Exception:', error);
  logger.error('Uncaught exception', error);
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (reason: any, promise: Promise<any>) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  logger.error('Unhandled promise rejection', new Error(reason?.message || 'Unknown rejection'), {
    reason: String(reason),
  });
});

// Create and initialize the application
const knouxApp = new KnouxMainApp();

// Setup app event handlers
knouxApp.setupAppEventHandlers();

// Initialize the application
knouxApp.initialize().catch((error) => {
  logger.error('Failed to initialize application', error);
  
  // Show error dialog to user
  if (app.isReady()) {
    dialog.showErrorBox(
      `${APP_NAME} - Initialization Error`,
      `Failed to start ${APP_NAME}:\n\n${error.message}\n\nPlease check the logs for more details.`
    );
  }
  
  app.quit();
});

// Export for testing and module access
export { knouxApp };
export default knouxApp;
