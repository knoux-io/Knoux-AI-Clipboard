/**
 * Knoux Clipboard AI - Centralized Logging System
 * Provides coordinated logging, file rotation, and console/file output
 * Generated by Knoux — Abu Retaj
 * Clipboard Intelligence • Desktop Precision • Premium Engineering
 */

import fs from 'fs';
import path from 'path';
import { app } from 'electron';

/**
 * Log levels
 */
export enum LogLevel {
  ERROR = 0,
  WARN = 1,
  INFO = 2,
  DEBUG = 3,
  VERBOSE = 4,
}

/**
 * Log entry
 */
export interface LogEntry {
  timestamp: Date;
  level: LogLevel;
  module: string;
  message: string;
  data?: any;
  error?: Error;
  correlationId?: string;
  sessionId?: string;
}

/**
 * Logger configuration
 */
export interface LoggerConfig {
  level: LogLevel;
  enableConsole: boolean;
  enableFile: boolean;
  enableRotation: boolean;
  maxFileSizeMB: number;
  maxFiles: number;
  logDirectory: string;
  fileName: string;
  format: 'json' | 'text';
  includeTimestamp: boolean;
  includeLevel: boolean;
  includeModule: boolean;
  colors: boolean;
}

/**
 * Module configuration
 */
export interface ModuleConfig {
  module: string;
  level?: LogLevel;
  colors?: {
    module: string;
    level: Record<LogLevel, string>;
  };
}

/**
 * Logger statistics
 */
export interface LoggerStats {
  totalLogs: number;
  logsByLevel: Record<LogLevel, number>;
  bytesWritten: number;
  rotationCount: number;
  errorCount: number;
}

class Logger {
  private config: LoggerConfig;
  private moduleConfigs: Map<string, ModuleConfig> = new Map();
  private fileStream: fs.WriteStream | null = null;
  private currentFileSize = 0;
  private stats: LoggerStats;
  private isInitialized = false;
  private readonly COLOR_RESET = '\x1b[0m';
  private readonly COLORS = {
    [LogLevel.ERROR]: '\x1b[31m', // Red
    [LogLevel.WARN]: '\x1b[33m',  // Yellow
    [LogLevel.INFO]: '\x1b[32m',  // Green
    [LogLevel.DEBUG]: '\x1b[36m', // Cyan
    [LogLevel.VERBOSE]: '\x1b[90m', // Gray
  };
  private readonly LEVEL_NAMES = {
    [LogLevel.ERROR]: 'ERROR',
    [LogLevel.WARN]: 'WARN',
    [LogLevel.INFO]: 'INFO',
    [LogLevel.DEBUG]: 'DEBUG',
    [LogLevel.VERBOSE]: 'VERBOSE',
  };

  constructor(config?: Partial<LoggerConfig>) {
    this.config = this.getDefaultConfig();
    if (config) {
      Object.assign(this.config, config);
    }
    this.stats = this.createInitialStats();
  }

  /**
   * Get default configuration
   */
  private getDefaultConfig(): LoggerConfig {
    const logDir = path.join(app.getPath('userData'), 'logs');
    
    return {
      level: process.env.NODE_ENV === 'production' ? LogLevel.INFO : LogLevel.DEBUG,
      enableConsole: true,
      enableFile: true,
      enableRotation: true,
      maxFileSizeMB: 10,
      maxFiles: 5,
      logDirectory: logDir,
      fileName: 'knoux',
      format: 'text',
      includeTimestamp: true,
      includeLevel: true,
      includeModule: true,
      colors: process.platform !== 'win32', // Colors on non-Windows
    };
  }

  /**
   * Create initial statistics
   */
  private createInitialStats(): LoggerStats {
    return {
      totalLogs: 0,
      logsByLevel: {
        [LogLevel.ERROR]: 0,
        [LogLevel.WARN]: 0,
        [LogLevel.INFO]: 0,
        [LogLevel.DEBUG]: 0,
        [LogLevel.VERBOSE]: 0,
      },
      bytesWritten: 0,
      rotationCount: 0,
      errorCount: 0,
    };
  }

  /**
   * Initialize logger
   */
  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    try {
      // Create log directory if it doesn't exist
      if (this.config.enableFile) {
        await this.ensureLogDirectory();
        await this.openLogFile();
      }

      this.isInitialized = true;
      
      this.info('Logger initialized', {
        module: 'logger',
        level: LogLevel[this.config.level],
        directory: this.config.logDirectory,
      });

    } catch (error) {
      // Fallback to console only
      this.config.enableFile = false;
      this.error('Failed to initialize file logging, using console only', error as Error, {
        module: 'logger',
      });
      this.isInitialized = true;
    }
  }

  /**
   * Ensure log directory exists
   */
  private async ensureLogDirectory(): Promise<void> {
    try {
      await fs.promises.mkdir(this.config.logDirectory, { recursive: true });
    } catch (error) {
      throw new Error(`Failed to create log directory: ${error}`);
    }
  }

  /**
   * Open log file
   */
  private async openLogFile(): Promise<void> {
    try {
      const filePath = this.getCurrentLogFilePath();
      
      // Close existing stream if open
      if (this.fileStream) {
        this.fileStream.end();
        this.fileStream = null;
      }
      
      // Open new stream
      this.fileStream = fs.createWriteStream(filePath, { flags: 'a' });
      this.currentFileSize = (await fs.promises.stat(filePath).catch(() => ({ size: 0 }))).size;
      
      this.debug('Log file opened', {
        module: 'logger',
        path: filePath,
        size: this.formatBytes(this.currentFileSize),
      });
      
    } catch (error) {
      throw new Error(`Failed to open log file: ${error}`);
    }
  }

  /**
   * Get current log file path
   */
  private getCurrentLogFilePath(): string {
    const date = new Date();
    const dateStr = date.toISOString().split('T')[0]; // YYYY-MM-DD
    return path.join(this.config.logDirectory, `${this.config.fileName}.${dateStr}.log`);
  }

  /**
   * Check if rotation is needed
   */
  private shouldRotate(): boolean {
    if (!this.config.enableRotation) {
      return false;
    }
    
    const maxSizeBytes = this.config.maxFileSizeMB * 1024 * 1024;
    return this.currentFileSize >= maxSizeBytes;
  }

  /**
   * Rotate log file
   */
  private async rotateLogFile(): Promise<void> {
    if (!this.config.enableFile) {
      return;
    }
    
    try {
      this.debug('Rotating log file', {
        module: 'logger',
        currentSize: this.formatBytes(this.currentFileSize),
        maxSize: `${this.config.maxFileSizeMB}MB`,
      });
      
      // Close current file
      if (this.fileStream) {
        this.fileStream.end();
        this.fileStream = null;
      }
      
      // Cleanup old files
      await this.cleanupOldLogs();
      
      // Open new file
      await this.openLogFile();
      
      this.stats.rotationCount++;
      
      this.info('Log file rotated', {
        module: 'logger',
        rotationCount: this.stats.rotationCount,
      });
      
    } catch (error) {
      this.error('Failed to rotate log file', error as Error, { module: 'logger' });
    }
  }

  /**
   * Cleanup old log files
   */
  private async cleanupOldLogs(): Promise<void> {
    try {
      const files = await fs.promises.readdir(this.config.logDirectory);
      const logFiles = files
        .filter(f => f.startsWith(this.config.fileName) && f.endsWith('.log'))
        .map(f => ({
          name: f,
          path: path.join(this.config.logDirectory, f),
          time: fs.statSync(path.join(this.config.logDirectory, f)).mtime.getTime(),
        }))
        .sort((a, b) => b.time - a.time); // Newest first
      
      // Remove files beyond max count
      for (let i = this.config.maxFiles; i < logFiles.length; i++) {
        await fs.promises.unlink(logFiles[i].path);
        
        this.debug('Removed old log file', {
          module: 'logger',
          file: logFiles[i].name,
          index: i,
        });
      }
      
    } catch (error) {
      this.error('Failed to cleanup old logs', error as Error, { module: 'logger' });
    }
  }

  /**
   * Register module configuration
   */
  public registerModule(config: ModuleConfig): void {
    this.moduleConfigs.set(config.module, {
      ...config,
      level: config.level ?? this.config.level,
    });
    
    this.debug('Module registered', {
      module: 'logger',
      registeredModule: config.module,
      level: LogLevel[config.level ?? this.config.level],
    });
  }

  /**
   * Create logger for specific module
   */
  public createLogger(config: ModuleConfig) {
    this.registerModule(config);
    
    return {
      error: (message: string, error?: Error, data?: any) => 
        this.log(LogLevel.ERROR, config.module, message, error, data),
      warn: (message: string, data?: any) => 
        this.log(LogLevel.WARN, config.module, message, undefined, data),
      info: (message: string, data?: any) => 
        this.log(LogLevel.INFO, config.module, message, undefined, data),
      debug: (message: string, data?: any) => 
        this.log(LogLevel.DEBUG, config.module, message, undefined, data),
      verbose: (message: string, data?: any) => 
        this.log(LogLevel.VERBOSE, config.module, message, undefined, data),
    };
  }

  /**
   * Main logging method
   */
  public log(
    level: LogLevel,
    module: string,
    message: string,
    error?: Error,
    data?: any,
    correlationId?: string,
    sessionId?: string
  ): void {
    // Check if logging is enabled for this module/level
    if (!this.shouldLog(level, module)) {
      return;
    }
    
    // Create log entry
    const entry: LogEntry = {
      timestamp: new Date(),
      level,
      module,
      message,
      data,
      error,
      correlationId,
      sessionId,
    };
    
    // Process the log entry
    this.processLogEntry(entry);
  }

  /**
   * Check if should log for given level and module
   */
  private shouldLog(level: LogLevel, module: string): boolean {
    // Global level check
    if (level > this.config.level) {
      return false;
    }
    
    // Module-specific level check
    const moduleConfig = this.moduleConfigs.get(module);
    if (moduleConfig && moduleConfig.level !== undefined) {
      return level <= moduleConfig.level;
    }
    
    return true;
  }

  /**
   * Process log entry
   */
  private processLogEntry(entry: LogEntry): void {
    // Update statistics
    this.stats.totalLogs++;
    this.stats.logsByLevel[entry.level]++;
    
    // Output to console
    if (this.config.enableConsole) {
      this.writeToConsole(entry);
    }
    
    // Output to file
    if (this.config.enableFile && this.fileStream) {
      this.writeToFile(entry);
    }
  }

  /**
   * Write log entry to console
   */
  private writeToConsole(entry: LogEntry): void {
    const formatted = this.formatEntry(entry, 'text', true);
    const output = this.config.colors ? this.colorize(formatted, entry.level) : formatted;
    
    // Use appropriate console method based on level
    switch (entry.level) {
      case LogLevel.ERROR:
        console.error(output);
        if (entry.error) {
          console.error(entry.error);
        }
        break;
      case LogLevel.WARN:
        console.warn(output);
        break;
      case LogLevel.INFO:
        console.info(output);
        break;
      default:
        console.log(output);
    }
  }

  /**
   * Write log entry to file
   */
  private writeToFile(entry: LogEntry): void {
    if (!this.fileStream) {
      return;
    }
    
    const formatted = this.formatEntry(entry, this.config.format, false);
    const data = formatted + '\n';
    
    try {
      this.fileStream.write(data);
      this.currentFileSize += Buffer.byteLength(data, 'utf8');
      this.stats.bytesWritten += Buffer.byteLength(data, 'utf8');
      
      // Check if rotation is needed
      if (this.shouldRotate()) {
        this.rotateLogFile();
      }
      
    } catch (error) {
      this.stats.errorCount++;
      // Don't try to log the error to avoid infinite recursion
      if (this.config.enableConsole) {
        console.error('Failed to write to log file:', error);
      }
    }
  }

  /**
   * Format log entry
   */
  private formatEntry(
    entry: LogEntry, 
    format: 'json' | 'text',
    includeColors: boolean
  ): string {
    if (format === 'json') {
      return this.formatAsJson(entry);
    } else {
      return this.formatAsText(entry, includeColors);
    }
  }

  /**
   * Format as JSON
   */
  private formatAsJson(entry: LogEntry): string {
    const logObject: any = {
      timestamp: entry.timestamp.toISOString(),
      level: LogLevel[entry.level],
      module: entry.module,
      message: entry.message,
    };
    
    if (entry.data) {
      logObject.data = entry.data;
    }
    
    if (entry.error) {
      logObject.error = {
        name: entry.error.name,
        message: entry.error.message,
        stack: entry.error.stack,
      };
    }
    
    if (entry.correlationId) {
      logObject.correlationId = entry.correlationId;
    }
    
    if (entry.sessionId) {
      logObject.sessionId = entry.sessionId;
    }
    
    return JSON.stringify(logObject);
  }

  /**
   * Format as text
   */
  private formatAsText(entry: LogEntry, includeColors: boolean): string {
    const parts: string[] = [];
    
    // Timestamp
    if (this.config.includeTimestamp) {
      const timeStr = entry.timestamp.toISOString().replace('T', ' ').substring(0, 23);
      parts.push(`[${timeStr}]`);
    }
    
    // Level
    if (this.config.includeLevel) {
      const levelName = LogLevel[entry.level].padEnd(7);
      parts.push(includeColors ? levelName : `[${levelName.trim()}]`);
    }
    
    // Module
    if (this.config.includeModule) {
      const moduleStr = entry.module.padEnd(15).substring(0, 15);
      parts.push(`[${moduleStr.trim()}]`);
    }
    
    // Message
    parts.push(entry.message);
    
    // Data
    if (entry.data) {
      const dataStr = typeof entry.data === 'string' 
        ? entry.data 
        : JSON.stringify(entry.data);
      parts.push(`| ${dataStr}`);
    }
    
    // Error
    if (entry.error) {
      parts.push(`| Error: ${entry.error.message}`);
    }
    
    // Correlation ID
    if (entry.correlationId) {
      parts.push(`| CID: ${entry.correlationId}`);
    }
    
    return parts.join(' ');
  }

  /**
   * Colorize text for console
   */
  private colorize(text: string, level: LogLevel): string {
    const color = this.COLORS[level];
    return color ? `${color}${text}${this.COLOR_RESET}` : text;
  }

  /**
   * Format bytes to human readable
   */
  private formatBytes(bytes: number): string {
    if (bytes === 0) return '0 Bytes';
    
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  /**
   * Convenience methods
   */
  public error(message: string, error?: Error, data?: any, module: string = 'logger'): void {
    this.log(LogLevel.ERROR, module, message, error, data);
  }
  
  public warn(message: string, data?: any, module: string = 'logger'): void {
    this.log(LogLevel.WARN, module, message, undefined, data);
  }
  
  public info(message: string, data?: any, module: string = 'logger'): void {
    this.log(LogLevel.INFO, module, message, undefined, data);
  }
  
  public debug(message: string, data?: any, module: string = 'logger'): void {
    this.log(LogLevel.DEBUG, module, message, undefined, data);
  }
  
  public verbose(message: string, data?: any, module: string = 'logger'): void {
    this.log(LogLevel.VERBOSE, module, message, undefined, data);
  }

  /**
   * Get logger statistics
   */
  public getStats(): LoggerStats {
    return { ...this.stats };
  }

  /**
   * Update configuration
   */
  public updateConfig(config: Partial<LoggerConfig>): void {
    const oldLevel = this.config.level;
    Object.assign(this.config, config);
    
    // Reopen file if directory changed
    if (config.logDirectory && config.logDirectory !== this.config.logDirectory) {
      this.openLogFile();
    }
    
    // Log configuration change
    if (oldLevel !== this.config.level) {
      this.info('Log level changed', {
        module: 'logger',
        oldLevel: LogLevel[oldLevel],
        newLevel: LogLevel[this.config.level],
      });
    }
  }

  /**
   * Flush log buffer
   */
  public flush(): Promise<void> {
    return new Promise((resolve) => {
      if (this.fileStream) {
        this.fileStream.write('', () => resolve());
      } else {
        resolve();
      }
    });
  }

  /**
   * Cleanup resources
   */
  public async cleanup(): Promise<void> {
    this.info('Cleaning up logger', { module: 'logger' });
    
    // Flush and close file stream
    if (this.fileStream) {
      await this.flush();
      this.fileStream.end();
      this.fileStream = null;
    }
    
    this.isInitialized = false;
    
    this.info('Logger cleanup completed', { module: 'logger' });
  }

  /**
   * Check if logger is ready
   */
  public isReady(): boolean {
    return this.isInitialized;
  }
}

// Create default logger instance
const defaultLogger = new Logger();

// Export functions that use the default logger
export const logger = {
  error: (message: string, error?: Error, data?: any) => 
    defaultLogger.error(message, error, data),
  warn: (message: string, data?: any) => 
    defaultLogger.warn(message, data),
  info: (message: string, data?: any) => 
    defaultLogger.info(message, data),
  debug: (message: string, data?: any) => 
    defaultLogger.debug(message, data),
  verbose: (message: string, data?: any) => 
    defaultLogger.verbose(message, data),
  createLogger: (config: ModuleConfig) => defaultLogger.createLogger(config),
  initialize: () => defaultLogger.initialize(),
  getStats: () => defaultLogger.getStats(),
  updateConfig: (config: Partial<LoggerConfig>) => defaultLogger.updateConfig(config),
  flush: () => defaultLogger.flush(),
  cleanup: () => defaultLogger.cleanup(),
  isReady: () => defaultLogger.isReady(),
};

// Export the Logger class for custom instances
export { Logger };
