/**
 * Knoux Clipboard AI - Unified Logging System
 * Centralized logging with multiple transports and log levels
 * Generated by Knoux — Abu Retaj
 * Clipboard Intelligence • Desktop Precision • Premium Engineering
 */

import { existsSync, mkdirSync, appendFileSync, createWriteStream, WriteStream } from 'fs';
import { join, dirname } from 'path';
import { format, inspect } from 'util';
import { IPC_CHANNELS } from './constants';
import { OperatingSystem } from './enums';

// ==================== TYPES ====================

/**
 * Log levels in order of severity
 */
export enum LogLevel {
  ERROR = 0,
  WARN = 1,
  INFO = 2,
  DEBUG = 3,
  TRACE = 4,
}

/**
 * Log entry structure
 */
export interface LogEntry {
  timestamp: Date;
  level: LogLevel;
  message: string;
  module: string;
  data?: any;
  stack?: string;
  correlationId?: string;
  sessionId?: string;
}

/**
 * Log transport configuration
 */
export interface LogTransport {
  enabled: boolean;
  level: LogLevel;
  format?: (entry: LogEntry) => string;
}

/**
 * Console transport configuration
 */
export interface ConsoleTransport extends LogTransport {
  colors: boolean;
  timestamps: boolean;
}

/**
 * File transport configuration
 */
export interface FileTransport extends LogTransport {
  path: string;
  maxSize: number; // in bytes
  maxFiles: number;
  compress: boolean;
  rotation: boolean;
}

/**
 * IPC transport configuration
 */
export interface IPCTransport extends LogTransport {
  channel: string;
  includeData: boolean;
}

/**
 * Complete logger configuration
 */
export interface LoggerConfig {
  level: LogLevel;
  module: string;
  transports: {
    console: ConsoleTransport;
    file: FileTransport;
    ipc: IPCTransport;
  };
  metadata: {
    appVersion: string;
    sessionId: string;
    environment: string;
  };
}

// ==================== CONSTANTS ====================

/**
 * ANSI color codes for console output
 */
const COLORS = {
  RESET: '\x1b[0m',
  BRIGHT: '\x1b[1m',
  DIM: '\x1b[2m',
  UNDERSCORE: '\x1b[4m',
  BLINK: '\x1b[5m',
  REVERSE: '\x1b[7m',
  HIDDEN: '\x1b[8m',
  
  // Foreground colors
  BLACK: '\x1b[30m',
  RED: '\x1b[31m',
  GREEN: '\x1b[32m',
  YELLOW: '\x1b[33m',
  BLUE: '\x1b[34m',
  MAGENTA: '\x1b[35m',
  CYAN: '\x1b[36m',
  WHITE: '\x1b[37m',
  
  // Background colors
  BG_BLACK: '\x1b[40m',
  BG_RED: '\x1b[41m',
  BG_GREEN: '\x1b[42m',
  BG_YELLOW: '\x1b[43m',
  BG_BLUE: '\x1b[44m',
  BG_MAGENTA: '\x1b[45m',
  BG_CYAN: '\x1b[46m',
  BG_WHITE: '\x1b[47m',
} as const;

/**
 * Log level colors
 */
const LEVEL_COLORS: Record<LogLevel, string> = {
  [LogLevel.ERROR]: COLORS.RED,
  [LogLevel.WARN]: COLORS.YELLOW,
  [LogLevel.INFO]: COLORS.GREEN,
  [LogLevel.DEBUG]: COLORS.BLUE,
  [LogLevel.TRACE]: COLORS.MAGENTA,
};

/**
 * Log level names
 */
const LEVEL_NAMES: Record<LogLevel, string> = {
  [LogLevel.ERROR]: 'ERROR',
  [LogLevel.WARN]: 'WARN',
  [LogLevel.INFO]: 'INFO',
  [LogLevel.DEBUG]: 'DEBUG',
  [LogLevel.TRACE]: 'TRACE',
};

// ==================== DEFAULT CONFIGURATION ====================

/**
 * Default logger configuration
 */
const DEFAULT_CONFIG: LoggerConfig = {
  level: LogLevel.INFO,
  module: 'main',
  transports: {
    console: {
      enabled: true,
      level: LogLevel.INFO,
      colors: true,
      timestamps: true,
    },
    file: {
      enabled: true,
      level: LogLevel.DEBUG,
      path: '',
      maxSize: 10 * 1024 * 1024, // 10MB
      maxFiles: 5,
      compress: true,
      rotation: true,
    },
    ipc: {
      enabled: false,
      level: LogLevel.WARN,
      channel: IPC_CHANNELS.EVENTS.SYSTEM_EVENT,
      includeData: false,
    },
  },
  metadata: {
    appVersion: '1.0.0',
    sessionId: generateSessionId(),
    environment: process.env.NODE_ENV || 'development',
  },
};

// ==================== CORE LOGGER CLASS ====================

/**
 * Main logger class
 */
class KnouxLogger {
  private config: LoggerConfig;
  private fileStream: WriteStream | null = null;
  private logQueue: LogEntry[] = [];
  private isProcessing = false;
  private ipcRenderer: any = null;

  constructor(config: Partial<LoggerConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    
    // Initialize file transport
    if (this.config.transports.file.enabled) {
      this.initializeFileTransport();
    }
    
    // Initialize IPC transport in renderer process
    if (typeof window !== 'undefined' && window.require) {
      try {
        const { ipcRenderer } = window.require('electron');
        this.ipcRenderer = ipcRenderer;
      } catch (error) {
        // Not in renderer process or IPC not available
      }
    }
  }

  /**
   * Initialize file transport with log rotation
   */
  private initializeFileTransport(): void {
    const { file } = this.config.transports;
    
    if (!file.path) {
      // Set default log path based on OS
      const logDir = this.getDefaultLogDir();
      file.path = join(logDir, 'knoux-clipboard.log');
    }
    
    // Ensure log directory exists
    const logDir = dirname(file.path);
    if (!existsSync(logDir)) {
      mkdirSync(logDir, { recursive: true });
    }
    
    // Check if log rotation is needed
    if (file.rotation && existsSync(file.path)) {
      const stats = require('fs').statSync(file.path);
      if (stats.size >= file.maxSize) {
        this.rotateLogFile();
      }
    }
    
    // Create write stream
    this.fileStream = createWriteStream(file.path, {
      flags: 'a',
      encoding: 'utf8',
    });
    
    this.fileStream.on('error', (error) => {
      console.error('Failed to write to log file:', error);
    });
  }

  /**
   * Get default log directory based on OS
   */
  private getDefaultLogDir(): string {
    const os = require('os');
    const appName = 'Knoux Clipboard AI';
    
    switch (process.platform) {
      case 'win32':
        return join(os.homedir(), 'AppData', 'Roaming', appName, 'logs');
      case 'darwin':
        return join(os.homedir(), 'Library', 'Logs', appName);
      case 'linux':
        return join(os.homedir(), '.local', 'share', appName, 'logs');
      default:
        return join(os.tmpdir(), appName, 'logs');
    }
  }

  /**
   * Rotate log file
   */
  private rotateLogFile(): void {
    const { file } = this.config.transports;
    const fs = require('fs');
    const path = require('path');
    
    try {
      // Get existing backup files
      const logDir = dirname(file.path);
      const logName = path.basename(file.path, '.log');
      const backupFiles = fs.readdirSync(logDir)
        .filter((f: string) => f.startsWith(`${logName}-`) && f.endsWith('.log'))
        .sort();
      
      // Remove old backups if we have too many
      while (backupFiles.length >= file.maxFiles - 1) {
        const oldFile = backupFiles.shift();
        if (oldFile) {
          fs.unlinkSync(path.join(logDir, oldFile));
        }
      }
      
      // Rename current log to backup
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const backupPath = path.join(logDir, `${logName}-${timestamp}.log`);
      fs.renameSync(file.path, backupPath);
      
      // Compress backup if enabled
      if (file.compress) {
        const zlib = require('zlib');
        const input = fs.readFileSync(backupPath);
        const compressed = zlib.gzipSync(input);
        fs.writeFileSync(`${backupPath}.gz`, compressed);
        fs.unlinkSync(backupPath);
      }
      
      // Close and reopen stream
      if (this.fileStream) {
        this.fileStream.end();
      }
      
      this.fileStream = createWriteStream(file.path, {
        flags: 'a',
        encoding: 'utf8',
      });
      
    } catch (error) {
      console.error('Failed to rotate log file:', error);
    }
  }

  /**
   * Format log entry for console output
   */
  private formatConsoleEntry(entry: LogEntry): string {
    const { console: consoleConfig } = this.config.transports;
    let formatted = '';
    
    if (consoleConfig.timestamps) {
      const timestamp = entry.timestamp.toISOString().replace('T', ' ').replace(/\.\d+Z$/, '');
      formatted += `${COLORS.DIM}${timestamp}${COLORS.RESET} `;
    }
    
    if (consoleConfig.colors) {
      const color = LEVEL_COLORS[entry.level];
      formatted += `${color}${LEVEL_NAMES[entry.level].padEnd(5)}${COLORS.RESET} `;
    } else {
      formatted += `${LEVEL_NAMES[entry.level].padEnd(5)} `;
    }
    
    formatted += `${COLORS.BRIGHT}[${this.config.module}]${COLORS.RESET} `;
    formatted += entry.message;
    
    if (entry.data) {
      const inspected = inspect(entry.data, {
        colors: consoleConfig.colors,
        depth: 2,
        maxArrayLength: 10,
      });
      formatted += ` ${COLORS.DIM}${inspected}${COLORS.RESET}`;
    }
    
    if (entry.stack && entry.level >= LogLevel.ERROR) {
      formatted += `\n${COLORS.DIM}${entry.stack}${COLORS.RESET}`;
    }
    
    return formatted;
  }

  /**
   * Format log entry for file output
   */
  private formatFileEntry(entry: LogEntry): string {
    const logLine = {
      timestamp: entry.timestamp.toISOString(),
      level: LEVEL_NAMES[entry.level],
      module: this.config.module,
      message: entry.message,
      data: entry.data,
      stack: entry.stack,
      correlationId: entry.correlationId,
      sessionId: entry.sessionId || this.config.metadata.sessionId,
      appVersion: this.config.metadata.appVersion,
      environment: this.config.metadata.environment,
    };
    
    return JSON.stringify(logLine) + '\n';
  }

  /**
   * Process log entry through all transports
   */
  private processEntry(entry: LogEntry): void {
    const { console: consoleConfig, file: fileConfig, ipc: ipcConfig } = this.config.transports;
    
    // Console transport
    if (consoleConfig.enabled && entry.level <= consoleConfig.level) {
      const consoleMessage = this.formatConsoleEntry(entry);
      const consoleMethod = entry.level === LogLevel.ERROR ? 'error' :
                          entry.level === LogLevel.WARN ? 'warn' :
                          entry.level === LogLevel.INFO ? 'info' : 'log';
      
      console[consoleMethod](consoleMessage);
    }
    
    // File transport
    if (fileConfig.enabled && entry.level <= fileConfig.level && this.fileStream) {
      const fileMessage = this.formatFileEntry(entry);
      this.fileStream.write(fileMessage);
      
      // Check for log rotation
      if (fileConfig.rotation && this.fileStream.bytesWritten >= fileConfig.maxSize) {
        this.rotateLogFile();
      }
    }
    
    // IPC transport
    if (ipcConfig.enabled && entry.level <= ipcConfig.level && this.ipcRenderer) {
      const ipcMessage = {
        type: 'log',
        level: LEVEL_NAMES[entry.level],
        message: entry.message,
        module: this.config.module,
        timestamp: entry.timestamp.toISOString(),
        ...(ipcConfig.includeData && { data: entry.data }),
      };
      
      this.ipcRenderer.send(ipcConfig.channel, ipcMessage);
    }
  }

  /**
   * Process queued log entries
   */
  private processQueue(): void {
    if (this.isProcessing || this.logQueue.length === 0) {
      return;
    }
    
    this.isProcessing = true;
    
    while (this.logQueue.length > 0) {
      const entry = this.logQueue.shift();
      if (entry) {
        try {
          this.processEntry(entry);
        } catch (error) {
          console.error('Failed to process log entry:', error);
        }
      }
    }
    
    this.isProcessing = false;
  }

  /**
   * Create log entry
   */
  private log(level: LogLevel, message: string, data?: any, error?: Error): void {
    if (level > this.config.level) {
      return;
    }
    
    const entry: LogEntry = {
      timestamp: new Date(),
      level,
      message,
      module: this.config.module,
      data,
      stack: error?.stack,
      correlationId: this.generateCorrelationId(),
      sessionId: this.config.metadata.sessionId,
    };
    
    // Add to queue and process asynchronously
    this.logQueue.push(entry);
    
    // Use setImmediate for async processing
    if (typeof setImmediate === 'function') {
      setImmediate(() => this.processQueue());
    } else {
      setTimeout(() => this.processQueue(), 0);
    }
  }

  /**
   * Generate correlation ID for tracing
   */
  private generateCorrelationId(): string {
    return Math.random().toString(36).substring(2, 15) +
           Math.random().toString(36).substring(2, 15);
  }

  // ==================== PUBLIC API ====================

  /**
   * Error level log
   */
  public error(message: string, error?: Error, data?: any): void {
    this.log(LogLevel.ERROR, message, data, error);
  }

  /**
   * Warn level log
   */
  public warn(message: string, data?: any): void {
    this.log(LogLevel.WARN, message, data);
  }

  /**
   * Info level log
   */
  public info(message: string, data?: any): void {
    this.log(LogLevel.INFO, message, data);
  }

  /**
   * Debug level log
   */
  public debug(message: string, data?: any): void {
    this.log(LogLevel.DEBUG, message, data);
  }

  /**
   * Trace level log
   */
  public trace(message: string, data?: any): void {
    this.log(LogLevel.TRACE, message, data);
  }

  /**
   * Create a child logger with specific module name
   */
  public child(module: string): KnouxLogger {
    return new KnouxLogger({
      ...this.config,
      module: `${this.config.module}.${module}`,
    });
  }

  /**
   * Update logger configuration
   */
  public updateConfig(config: Partial<LoggerConfig>): void {
    this.config = { ...this.config, ...config };
    
    // Reinitialize file transport if path changed
    if (config.transports?.file?.path && 
        config.transports.file.path !== this.config.transports.file.path) {
      if (this.fileStream) {
        this.fileStream.end();
      }
      this.initializeFileTransport();
    }
  }

  /**
   * Get current configuration
   */
  public getConfig(): LoggerConfig {
    return { ...this.config };
  }

  /**
   * Flush all pending log entries
   */
  public async flush(): Promise<void> {
    return new Promise((resolve) => {
      const checkQueue = () => {
        if (this.logQueue.length === 0 && !this.isProcessing) {
          resolve();
        } else {
          setTimeout(checkQueue, 10);
        }
      };
      checkQueue();
    });
  }

  /**
   * Close logger and cleanup resources
   */
  public async close(): Promise<void> {
    await this.flush();
    
    if (this.fileStream) {
      this.fileStream.end();
      this.fileStream = null;
    }
  }
}

// ==================== UTILITY FUNCTIONS ====================

/**
 * Generate unique session ID
 */
function generateSessionId(): string {
  return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

/**
 * Create a logger instance
 */
export function createLogger(config: Partial<LoggerConfig> = {}): KnouxLogger {
  return new KnouxLogger(config);
}

/**
 * Get module-specific logger
 */
export function getLogger(module: string): KnouxLogger {
  return createLogger({ module });
}

/**
 * Default logger instance
 */
export const logger = createLogger();

/**
 * Create a performance timer
 */
export function createTimer(label: string): () => number {
  const start = process.hrtime.bigint();
  
  return () => {
    const end = process.hrtime.bigint();
    const duration = Number(end - start) / 1_000_000; // Convert to milliseconds
    logger.debug(`${label} completed`, { duration: `${duration.toFixed(2)}ms` });
    return duration;
  };
}

/**
 * Log function execution time
 */
export function logExecutionTime<T>(
  func: () => T | Promise<T>,
  label: string,
  level: LogLevel = LogLevel.DEBUG
): T | Promise<T> {
  const start = process.hrtime.bigint();
  
  const logDuration = () => {
    const end = process.hrtime.bigint();
    const duration = Number(end - start) / 1_000_000;
    const message = `${label} execution time`;
    
    switch (level) {
      case LogLevel.ERROR:
        logger.error(message, undefined, { duration: `${duration.toFixed(2)}ms` });
        break;
      case LogLevel.WARN:
        logger.warn(message, { duration: `${duration.toFixed(2)}ms` });
        break;
      case LogLevel.INFO:
        logger.info(message, { duration: `${duration.toFixed(2)}ms` });
        break;
      case LogLevel.DEBUG:
        logger.debug(message, { duration: `${duration.toFixed(2)}ms` });
        break;
      case LogLevel.TRACE:
        logger.trace(message, { duration: `${duration.toFixed(2)}ms` });
        break;
    }
  };
  
  try {
    const result = func();
    
    if (result instanceof Promise) {
      return result.finally(logDuration) as Promise<T>;
    } else {
      logDuration();
      return result;
    }
  } catch (error) {
    logDuration();
    throw error;
  }
}

/**
 * Create a scoped logger for specific operation
 */
export function createScopedLogger(scope: string, parent?: KnouxLogger): KnouxLogger {
  const baseLogger = parent || logger;
  return baseLogger.child(scope);
}

// ==================== EXPORTS ====================

export default logger;

// Type exports
export type {
  LogEntry,
  LoggerConfig,
  ConsoleTransport,
  FileTransport,
  IPCTransport,
};
