/**
 * Knoux Clipboard AI - Clipboard Content Formatter
 * Formats and presents clipboard content in readable displays
 * Generated by Knoux — Abu Retaj
 * Clipboard Intelligence • Desktop Precision • Premium Engineering
 */

import { llog } from '../../shared/localized-logger';
import { CLIPBOARD, CONTENT_TYPES } from '../../shared/constants';
import { ClipboardItem, ClipboardMetadata } from '../../shared/types';
import { ProgrammingLanguage, ClipboardFormat } from '../../shared/enums';

/**
 * Formatting options
 */
export interface FormattingOptions {
  maxLength: number;
  preserveFormatting: boolean;
  showLineNumbers: boolean;
  syntaxHighlighting: boolean;
  theme: 'dark' | 'light' | 'system';
  compact: boolean;
  includeMetadata: boolean;
  language?: string;
}

/**
 * Formatted content
 */
export interface FormattedContent {
  raw: string;
  formatted: string;
  preview: string;
  html?: string;
  metadata: FormatMetadata;
}

/**
 * Format metadata
 */
export interface FormatMetadata {
  language: string;
  hasSyntax: boolean;
  lineCount: number;
  charCount: number;
  formattedLength: number;
  formattingTimeMs: number;
}

/**
 * Syntax highlighting rule
 */
export interface SyntaxRule {
  pattern: RegExp;
  type: 'keyword' | 'string' | 'comment' | 'number' | 'function' | 'operator';
  className: string;
}

export class ClipboardFormatter {
  private logger = createLogger({ module: 'clipboard-formatter' });
  private syntaxRules: Map<string, SyntaxRule[]> = new Map();
  private isInitialized = false;

  constructor() {
    this.initializeSyntaxRules();
  }

  /**
   * Initialize formatter
   */
  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    this.llog.info('Initializing clipboard formatter');
    this.isInitialized = true;
    this.llog.info('Clipboard formatter initialized successfully');
  }

  /**
   * Initialize syntax highlighting rules
   */
  private initializeSyntaxRules(): void {
    // JavaScript/TypeScript syntax rules
    this.syntaxRules.set('javascript', [
      { pattern: /\b(function|const|let|var|if|else|for|while|return|class|import|export|from|default)\b/g, type: 'keyword', className: 'keyword' },
      { pattern: /(["'`])(?:(?=(\\?))\2.)*?\1/g, type: 'string', className: 'string' },
      { pattern: /\/\/.*$/gm, type: 'comment', className: 'comment' },
      { pattern: /\/\*[\s\S]*?\*\//g, type: 'comment', className: 'comment' },
      { pattern: /\b(\d+)\b/g, type: 'number', className: 'number' },
      { pattern: /\b([A-Za-z_$][A-Za-z0-9_$]*)\s*\(/g, type: 'function', className: 'function' },
      { pattern: /[=<>!&|+\-*/%]+/g, type: 'operator', className: 'operator' },
    ]);

    this.syntaxRules.set('typescript', [
      { pattern: /\b(interface|type|implements|extends|public|private|protected|readonly)\b/g, type: 'keyword', className: 'keyword' },
      { pattern: /(["'`])(?:(?=(\\?))\2.)*?\1/g, type: 'string', className: 'string' },
      { pattern: /\/\/.*$/gm, type: 'comment', className: 'comment' },
      { pattern: /\/\*[\s\S]*?\*\//g, type: 'comment', className: 'comment' },
      { pattern: /\b(\d+)\b/g, type: 'number', className: 'number' },
      { pattern: /\b([A-Za-z_$][A-Za-z0-9_$]*)\s*\(/g, type: 'function', className: 'function' },
      { pattern: /[=<>!&|+\-*/%]+/g, type: 'operator', className: 'operator' },
    ]);

    // Python syntax rules
    this.syntaxRules.set('python', [
      { pattern: /\b(def|class|if|elif|else|for|while|try|except|import|from|as|with|return|yield)\b/g, type: 'keyword', className: 'keyword' },
      { pattern: /(["'`])(?:(?=(\\?))\2.)*?\1/g, type: 'string', className: 'string' },
      { pattern: /#.*$/gm, type: 'comment', className: 'comment' },
      { pattern: /"""[\s\S]*?"""/g, type: 'comment', className: 'comment' },
      { pattern: /'''[\s\S]*?'''/g, type: 'comment', className: 'comment' },
      { pattern: /\b(\d+)\b/g, type: 'number', className: 'number' },
      { pattern: /\b([A-Za-z_][A-Za-z0-9_]*)\s*\(/g, type: 'function', className: 'function' },
      { pattern: /[=<>!&|+\-*/%]+/g, type: 'operator', className: 'operator' },
    ]);

    // PowerShell syntax rules
    this.syntaxRules.set('powershell', [
      { pattern: /\b(function|param|begin|process|end|if|else|foreach|while|try|catch|finally|return)\b/g, type: 'keyword', className: 'keyword' },
      { pattern: /(["'`])(?:(?=(\\?))\2.)*?\1/g, type: 'string', className: 'string' },
      { pattern: /#.*$/gm, type: 'comment', className: 'comment' },
      { pattern: /\b(\d+)\b/g, type: 'number', className: 'number' },
      { pattern: /\b(Get-|Set-|Write-|Start-|Stop-|Test-|New-|Remove-)[A-Za-z]+\b/g, type: 'function', className: 'function' },
      { pattern: /[=<>!&|+\-*/%]+/g, type: 'operator', className: 'operator' },
      { pattern: /\$[A-Za-z_][A-Za-z0-9_]*/g, type: 'keyword', className: 'variable' },
    ]);

    // HTML syntax rules
    this.syntaxRules.set('html', [
      { pattern: /&[a-z]+;/g, type: 'keyword', className: 'entity' },
      { pattern: /(["'`])(?:(?=(\\?))\2.)*?\1/g, type: 'string', className: 'string' },
      { pattern: /<!--[\s\S]*?-->/g, type: 'comment', className: 'comment' },
      { pattern: /<\/?[a-zA-Z][^>]*>/g, type: 'keyword', className: 'tag' },
      { pattern: /\b([a-zA-Z-]+)=/g, type: 'keyword', className: 'attribute' },
    ]);

    // CSS syntax rules
    this.syntaxRules.set('css', [
      { pattern: /\b(@media|@import|@keyframes|@font-face)\b/g, type: 'keyword', className: 'keyword' },
      { pattern: /(["'`])(?:(?=(\\?))\2.)*?\1/g, type: 'string', className: 'string' },
      { pattern: /\/\*[\s\S]*?\*\//g, type: 'comment', className: 'comment' },
      { pattern: /[a-zA-Z-]+\s*\{/g, type: 'function', className: 'selector' },
      { pattern: /[a-zA-Z-]+\s*:/g, type: 'keyword', className: 'property' },
      { pattern: /#([a-fA-F0-9]{3}|[a-fA-F0-9]{6})\b/g, type: 'number', className: 'color' },
      { pattern: /\b(\d+)(px|em|rem|%|vh|vw)?\b/g, type: 'number', className: 'number' },
    ]);

    // JSON syntax rules
    this.syntaxRules.set('json', [
      { pattern: /(["'`])(?:(?=(\\?))\2.)*?\1/g, type: 'string', className: 'string' },
      { pattern: /\b(true|false|null)\b/g, type: 'keyword', className: 'keyword' },
      { pattern: /\b(\d+)\b/g, type: 'number', className: 'number' },
    ]);

    // Markdown syntax rules
    this.syntaxRules.set('markdown', [
      { pattern: /^#+\s+.+$/gm, type: 'keyword', className: 'heading' },
      { pattern: /\*\*[^*]+\*\*/g, type: 'keyword', className: 'bold' },
      { pattern: /\*[^*]+\*/g, type: 'keyword', className: 'italic' },
      { pattern: /`[^`]+`/g, type: 'string', className: 'code' },
      { pattern: /\[[^\]]+\]\([^)]+\)/g, type: 'keyword', className: 'link' },
      { pattern: /^\s*[-*+]\s+.+$/gm, type: 'keyword', className: 'list' },
      { pattern: /^\s*\d+\.\s+.+$/gm, type: 'keyword', className: 'list' },
    ]);

    this.llog.debug(`Initialized syntax rules for ${this.syntaxRules.size} languages`);
  }

  /**
   * Format clipboard content
   */
  public async formatContent(
    content: string,
    options: Partial<FormattingOptions> = {}
  ): Promise<FormattedContent> {
    const startTime = Date.now();
    
    if (!this.isInitialized) {
      await this.initialize();
    }

    // Merge options with defaults
    const fullOptions: FormattingOptions = {
      maxLength: CLIPBOARD.TRUNCATE_PREVIEW_LENGTH,
      preserveFormatting: true,
      showLineNumbers: false,
      syntaxHighlighting: true,
      theme: 'dark',
      compact: false,
      includeMetadata: true,
      ...options,
    };

    this.llog.debug('Formatting content', {
      contentLength: content.length,
      options: fullOptions,
    });

    try {
      // Detect language if not provided
      const language = fullOptions.language || this.detectLanguage(content);
      
      // Create preview (truncated version)
      const preview = this.createPreview(content, fullOptions);
      
      // Apply formatting
      let formatted = content;
      
      if (fullOptions.preserveFormatting) {
        formatted = this.preserveFormatting(formatted, language);
      }
      
      if (fullOptions.showLineNumbers) {
        formatted = this.addLineNumbers(formatted);
      }
      
      if (fullOptions.syntaxHighlighting) {
        formatted = this.applySyntaxHighlighting(formatted, language, fullOptions.theme);
      }
      
      if (fullOptions.compact) {
        formatted = this.makeCompact(formatted);
      }
      
      // Create HTML version if needed
      let html: string | undefined;
      if (fullOptions.syntaxHighlighting) {
        html = this.formatAsHtml(content, language, fullOptions);
      }
      
      // Calculate metadata
      const formattingTimeMs = Date.now() - startTime;
      const metadata = this.createFormatMetadata(content, formatted, language, formattingTimeMs);
      
      this.llog.info('Content formatted successfully', {
        originalLength: content.length,
        formattedLength: formatted.length,
        language,
        formattingTimeMs,
      });
      
      return {
        raw: content,
        formatted,
        preview,
        html,
        metadata,
      };
      
    } catch (error) {
      this.llog.error('Failed to format content', error as Error, {
        contentLength: content.length,
      });
      
      // Return basic formatted version on error
      return {
        raw: content,
        formatted: content,
        preview: this.createPreview(content, fullOptions),
        metadata: this.createFormatMetadata(content, content, 'plain', 0),
      };
    }
  }

  /**
   * Create preview of content
   */
  public createPreview(
    content: string,
    options: Partial<FormattingOptions> = {}
  ): string {
    const maxLength = options.maxLength || CLIPBOARD.TRUNCATE_PREVIEW_LENGTH;
    
    if (content.length <= maxLength) {
      return content;
    }
    
    // Try to find a good truncation point
    let preview = content.substring(0, maxLength);
    
    // Look for sentence end
    const lastPeriod = preview.lastIndexOf('.');
    const lastExclamation = preview.lastIndexOf('!');
    const lastQuestion = preview.lastIndexOf('?');
    const lastNewline = preview.lastIndexOf('\n');
    
    const cutoff = Math.max(lastPeriod, lastExclamation, lastQuestion, lastNewline);
    
    if (cutoff > maxLength * 0.5) {
      preview = preview.substring(0, cutoff + 1);
    }
    
    // Add ellipsis
    if (preview.length < content.length) {
      preview += '...';
    }
    
    return preview;
  }

  /**
   * Format clipboard item
   */
  public async formatClipboardItem(
    item: ClipboardItem,
    options: Partial<FormattingOptions> = {}
  ): Promise<FormattedContent> {
    const formatOptions: Partial<FormattingOptions> = {
      language: item.metadata.language,
      ...options,
    };
    
    return this.formatContent(item.content, formatOptions);
  }

  /**
   * Detect language from content
   */
  private detectLanguage(content: string): string {
    if (!content || content.trim().length === 0) {
      return 'plain';
    }
    
    // Check for JSON
    try {
      JSON.parse(content);
      return 'json';
    } catch {
      // Not JSON
    }
    
    // Check for HTML
    if (content.includes('<html') || content.includes('<div') || content.includes('<span')) {
      return 'html';
    }
    
    // Check for CSS
    if (content.includes('{') && content.includes('}') && content.includes(':')) {
      return 'css';
    }
    
    // Check for JavaScript/TypeScript
    if (content.includes('function') || content.includes('const ') || content.includes('let ')) {
      return 'javascript';
    }
    
    // Check for Python
    if (content.includes('def ') || content.includes('import ') || content.includes('from ')) {
      return 'python';
    }
    
    // Check for PowerShell
    if (content.includes('Get-') || content.includes('$') || content.includes('Write-')) {
      return 'powershell';
    }
    
    // Check for Markdown
    if (content.includes('# ') || content.includes('## ') || content.includes('*') || content.includes('`')) {
      return 'markdown';
    }
    
    // Default to plain text
    return 'plain';
  }

  /**
   * Preserve formatting in content
   */
  private preserveFormatting(content: string, language: string): string {
    // For code languages, ensure proper indentation is preserved
    if (language !== 'plain' && language !== 'markdown') {
      const lines = content.split('\n');
      const formattedLines = lines.map(line => {
        // Preserve leading whitespace for indentation
        const match = line.match(/^(\s*)/);
        if (match) {
          const indent = match[1];
          // Convert tabs to spaces for consistent display
          return indent.replace(/\t/g, '    ') + line.substring(indent.length);
        }
        return line;
      });
      return formattedLines.join('\n');
    }
    
    return content;
  }

  /**
   * Add line numbers to content
   */
  private addLineNumbers(content: string): string {
    const lines = content.split('\n');
    const maxLineNumber = lines.length;
    const lineNumberWidth = maxLineNumber.toString().length;
    
    const numberedLines = lines.map((line, index) => {
      const lineNumber = (index + 1).toString().padStart(lineNumberWidth, ' ');
      return `${lineNumber} │ ${line}`;
    });
    
    return numberedLines.join('\n');
  }

  /**
   * Apply syntax highlighting
   */
  private applySyntaxHighlighting(
    content: string,
    language: string,
    theme: 'dark' | 'light' | 'system'
  ): string {
    const rules = this.syntaxRules.get(language);
    if (!rules) {
      return content; // No syntax rules for this language
    }
    
    let highlighted = content;
    
    // Apply rules in order
    for (const rule of rules) {
      highlighted = highlighted.replace(rule.pattern, (match) => {
        return `{{${rule.className}:${match}}}`;
      });
    }
    
    // Convert to terminal colors if needed
    if (theme === 'dark') {
      highlighted = this.applyDarkTheme(highlighted);
    } else if (theme === 'light') {
      highlighted = this.applyLightTheme(highlighted);
    }
    
    // Remove markers for plain text display
    highlighted = highlighted.replace(/\{\{([^}]+):([^}]+)\}\}/g, '$2');
    
    return highlighted;
  }

  /**
   * Apply dark theme colors
   */
  private applyDarkTheme(content: string): string {
    const colorMap: Record<string, string> = {
      'keyword': '\x1b[95m', // Magenta
      'string': '\x1b[92m',  // Green
      'comment': '\x1b[90m', // Gray
      'number': '\x1b[93m',  // Yellow
      'function': '\x1b[96m', // Cyan
      'operator': '\x1b[94m', // Blue
      'variable': '\x1b[95m', // Magenta
      'tag': '\x1b[91m',     // Red
      'attribute': '\x1b[93m', // Yellow
      'selector': '\x1b[96m', // Cyan
      'property': '\x1b[94m', // Blue
      'color': '\x1b[92m',   // Green
      'heading': '\x1b[95m', // Magenta
      'bold': '\x1b[1m',     // Bold
      'italic': '\x1b[3m',   // Italic
      'code': '\x1b[90m',    // Gray
      'link': '\x1b[94m',    // Blue
      'list': '\x1b[92m',    // Green
      'entity': '\x1b[91m',  // Red
    };
    
    return content.replace(/\{\{([^}]+):([^}]+)\}\}/g, (match, className, text) => {
      const color = colorMap[className] || '\x1b[0m';
      return `${color}${text}\x1b[0m`;
    });
  }

  /**
   * Apply light theme colors
   */
  private applyLightTheme(content: string): string {
    const colorMap: Record<string, string> = {
      'keyword': '\x1b[35m', // Magenta
      'string': '\x1b[32m',  // Green
      'comment': '\x1b[90m', // Gray
      'number': '\x1b[33m',  // Yellow
      'function': '\x1b[36m', // Cyan
      'operator': '\x1b[34m', // Blue
      'variable': '\x1b[35m', // Magenta
      'tag': '\x1b[31m',     // Red
      'attribute': '\x1b[33m', // Yellow
      'selector': '\x1b[36m', // Cyan
      'property': '\x1b[34m', // Blue
      'color': '\x1b[32m',   // Green
      'heading': '\x1b[35m', // Magenta
      'bold': '\x1b[1m',     // Bold
      'italic': '\x1b[3m',   // Italic
      'code': '\x1b[90m',    // Gray
      'link': '\x1b[34m',    // Blue
      'list': '\x1b[32m',    // Green
      'entity': '\x1b[31m',  // Red
    };
    
    return content.replace(/\{\{([^}]+):([^}]+)\}\}/g, (match, className, text) => {
      const color = colorMap[className] || '\x1b[0m';
      return `${color}${text}\x1b[0m`;
    });
  }

  /**
   * Make content compact
   */
  private makeCompact(content: string): string {
    const lines = content.split('\n');
    
    // Remove excessive empty lines (keep at most 2 consecutive empty lines)
    const compactLines: string[] = [];
    let emptyLineCount = 0;
    
    for (const line of lines) {
      if (line.trim().length === 0) {
        emptyLineCount++;
        if (emptyLineCount <= 2) {
          compactLines.push('');
        }
      } else {
        emptyLineCount = 0;
        compactLines.push(line);
      }
    }
    
    // Trim trailing empty lines
    while (compactLines.length > 0 && compactLines[compactLines.length - 1] === '') {
      compactLines.pop();
    }
    
    return compactLines.join('\n');
  }

  /**
   * Format content as HTML
   */
  private formatAsHtml(
    content: string,
    language: string,
    options: FormattingOptions
  ): string {
    let html = '<div class="code-container">';
    
    if (options.showLineNumbers) {
      html += '<div class="line-numbers">';
      const lines = content.split('\n');
      for (let i = 1; i <= lines.length; i++) {
        html += `<div class="line-number">${i}</div>`;
      }
      html += '</div>';
    }
    
    html += '<pre class="code-content">';
    
    // Apply HTML escaping
    const escapedContent = content
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
    
    // Apply syntax highlighting for HTML output
    const rules = this.syntaxRules.get(language);
    if (rules) {
      let highlighted = escapedContent;
      
      for (const rule of rules) {
        highlighted = highlighted.replace(rule.pattern, (match) => {
          return `<span class="syntax-${rule.className}">${match}</span>`;
        });
      }
      
      html += highlighted;
    } else {
      html += escapedContent;
    }
    
    html += '</pre></div>';
    
    return html;
  }

  /**
   * Create format metadata
   */
  private createFormatMetadata(
    original: string,
    formatted: string,
    language: string,
    formattingTimeMs: number
  ): FormatMetadata {
    const rules = this.syntaxRules.get(language);
    
    return {
      language,
      hasSyntax: !!rules,
      lineCount: formatted.split('\n').length,
      charCount: formatted.length,
      formattedLength: formatted.length,
      formattingTimeMs,
    };
  }

  /**
   * Get available formatting themes
   */
  public getAvailableThemes(): Array<{
    id: string;
    name: string;
    description: string;
    isDark: boolean;
  }> {
    return [
      { id: 'dark', name: 'Dark Theme', description: 'Dark background with bright colors', isDark: true },
      { id: 'light', name: 'Light Theme', description: 'Light background with dark colors', isDark: false },
      { id: 'system', name: 'System Theme', description: 'Follows system theme', isDark: false },
      { id: 'monokai', name: 'Monokai', description: 'Monokai color scheme', isDark: true },
      { id: 'solarized', name: 'Solarized', description: 'Solarized color scheme', isDark: true },
    ];
  }

  /**
   * Get available languages
   */
  public getAvailableLanguages(): Array<{
    id: string;
    name: string;
    extensions: string[];
    mimeTypes: string[];
  }> {
    return [
      { id: 'javascript', name: 'JavaScript', extensions: ['.js', '.jsx'], mimeTypes: ['application/javascript'] },
      { id: 'typescript', name: 'TypeScript', extensions: ['.ts', '.tsx'], mimeTypes: ['application/typescript'] },
      { id: 'python', name: 'Python', extensions: ['.py'], mimeTypes: ['text/x-python'] },
      { id: 'powershell', name: 'PowerShell', extensions: ['.ps1'], mimeTypes: ['application/x-powershell'] },
      { id: 'html', name: 'HTML', extensions: ['.html', '.htm'], mimeTypes: ['text/html'] },
      { id: 'css', name: 'CSS', extensions: ['.css'], mimeTypes: ['text/css'] },
      { id: 'json', name: 'JSON', extensions: ['.json'], mimeTypes: ['application/json'] },
      { id: 'markdown', name: 'Markdown', extensions: ['.md', '.markdown'], mimeTypes: ['text/markdown'] },
      { id: 'plain', name: 'Plain Text', extensions: ['.txt'], mimeTypes: ['text/plain'] },
    ];
  }

  /**
   * Get language from extension
   */
  public getLanguageFromExtension(extension: string): string {
    const languages = this.getAvailableLanguages();
    const language = languages.find(lang => 
      lang.extensions.some(ext => extension.toLowerCase().endsWith(ext))
    );
    
    return language?.id || 'plain';
  }

  /**
   * Get language from mime type
   */
  public getLanguageFromMimeType(mimeType: string): string {
    const languages = this.getAvailableLanguages();
    const language = languages.find(lang => 
      lang.mimeTypes.includes(mimeType.toLowerCase())
    );
    
    return language?.id || 'plain';
  }

  /**
   * Validate formatting options
   */
  public validateOptions(options: Partial<FormattingOptions>): string[] {
    const errors: string[] = [];
    
    if (options.maxLength !== undefined) {
      if (typeof options.maxLength !== 'number') {
        errors.push('maxLength must be a number');
      } else if (options.maxLength < 10) {
        errors.push('maxLength must be at least 10');
      } else if (options.maxLength > 10000) {
        errors.push('maxLength cannot exceed 10000');
      }
    }
    
    if (options.theme && !['dark', 'light', 'system'].includes(options.theme)) {
      errors.push(`Invalid theme: ${options.theme}`);
    }
    
    if (options.language) {
      const languages = this.getAvailableLanguages();
      if (!languages.some(lang => lang.id === options.language)) {
        errors.push(`Unsupported language: ${options.language}`);
      }
    }
    
    return errors;
  }

  /**
   * Format multiple items as a collection
   */
  public async formatCollection(
    items: ClipboardItem[],
    options: Partial<FormattingOptions> = {}
  ): Promise<FormattedContent[]> {
    const formattedItems: FormattedContent[] = [];
    
    for (const item of items) {
      try {
        const formatted = await this.formatClipboardItem(item, options);
        formattedItems.push(formatted);
      } catch (error) {
        this.llog.error('Failed to format collection item', error as Error, {
          itemId: item.id,
        });
      }
    }
    
    return formattedItems;
  }

  /**
   * Create comparison view of two contents
   */
  public async createComparison(
    content1: string,
    content2: string,
    options: Partial<FormattingOptions> = {}
  ): Promise<{
    original: FormattedContent;
    modified: FormattedContent;
    differences: string[];
  }> {
    const [original, modified] = await Promise.all([
      this.formatContent(content1, options),
      this.formatContent(content2, options),
    ]);
    
    // Find differences (simplified)
    const differences: string[] = [];
    
    if (original.metadata.lineCount !== modified.metadata.lineCount) {
      differences.push(`Line count changed: ${original.metadata.lineCount} → ${modified.metadata.lineCount}`);
    }
    
    if (original.metadata.charCount !== modified.metadata.charCount) {
      differences.push(`Character count changed: ${original.metadata.charCount} → ${modified.metadata.charCount}`);
    }
    
    // Simple content comparison
    if (content1 !== content2) {
      const lines1 = content1.split('\n');
      const lines2 = content2.split('\n');
      
      for (let i = 0; i < Math.max(lines1.length, lines2.length); i++) {
        const line1 = lines1[i] || '';
        const line2 = lines2[i] || '';
        
        if (line1 !== line2) {
          differences.push(`Line ${i + 1} changed`);
        }
      }
    }
    
    return { original, modified, differences };
  }

  /**
   * Extract code blocks from content
   */
  public extractCodeBlocks(content: string): Array<{
    code: string;
    language: string;
    startLine: number;
    endLine: number;
  }> {
    const codeBlocks: Array<{
      code: string;
      language: string;
      startLine: number;
      endLine: number;
    }> = [];
    
    const lines = content.split('\n');
    let currentBlock: string[] = [];
    let currentLanguage = 'plain';
    let blockStartLine = -1;
    let inCodeBlock = false;
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      
      // Check for code block start
      const codeBlockMatch = line.match(/^```(\w*)/);
      if (codeBlockMatch && !inCodeBlock) {
        inCodeBlock = true;
        currentLanguage = codeBlockMatch[1] || 'plain';
        blockStartLine = i + 1;
        continue;
      }
      
      // Check for code block end
      if (line.trim() === '```' && inCodeBlock) {
        inCodeBlock = false;
        if (currentBlock.length > 0) {
          codeBlocks.push({
            code: currentBlock.join('\n'),
            language: currentLanguage,
            startLine: blockStartLine,
            endLine: i,
          });
          currentBlock = [];
        }
        continue;
      }
      
      // Add line to current block if in code block
      if (inCodeBlock) {
        currentBlock.push(line);
      }
    }
    
    // Handle unclosed code block
    if (inCodeBlock && currentBlock.length > 0) {
      codeBlocks.push({
        code: currentBlock.join('\n'),
        language: currentLanguage,
        startLine: blockStartLine,
        endLine: lines.length,
      });
    }
    
    return codeBlocks;
  }

  /**
   * Check if formatter is ready
   */
  public isReady(): boolean {
    return this.isInitialized;
  }

  /**
   * Clear formatter cache
   */
  public clearCache(): void {
    this.llog.debug('Formatter cache cleared');
    // This implementation doesn't use caching
  }

  /**
   * Get formatter statistics
   */
  public getStats(): {
    languagesSupported: number;
    syntaxRules: number;
  } {
    let totalRules = 0;
    this.syntaxRules.forEach(rules => {
      totalRules += rules.length;
    });
    
    return {
      languagesSupported: this.syntaxRules.size,
      syntaxRules: totalRules,
    };
  }
}

