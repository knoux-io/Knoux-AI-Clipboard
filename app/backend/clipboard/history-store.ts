/**
 * Knoux Clipboard AI - Clipboard History Store
 * Persistent storage for clipboard items with classification, search, and encryption
 * Generated by Knoux — Abu Retaj
 * Clipboard Intelligence • Desktop Precision • Premium Engineering
 */

import { logger, createLogger } from '../../shared/logger';
import { CLIPBOARD, SECURITY, AI } from '../../shared/constants';
import { 
  ClipboardItem, 
  ClipboardMetadata, 
  ContentClassification,
  SearchFilter 
} from '../../shared/types';
import { 
  ClipboardFormat, 
  StorageType, 
  CompressionMethod 
} from '../../shared/enums';
import { ContentClassifier } from '../ai/classifier';
import { ContentSummarizer } from '../ai/summarizer';

/**
 * Storage configuration
 */
export interface StorageConfig {
  maxItems: number;
  maxSizeMB: number;
  autoPrune: boolean;
  compressOldItems: boolean;
  encryptionEnabled: boolean;
  backupEnabled: boolean;
  backupIntervalHours: number;
  storageType: StorageType;
}

/**
 * Storage statistics
 */
export interface StorageStats {
  totalItems: number;
  totalSizeBytes: number;
  itemsByType: Record<string, number>;
  oldestItemDate: Date | null;
  newestItemDate: Date | null;
  compressionRatio: number;
  encryptedCount: number;
}

/**
 * Search result
 */
export interface SearchResult {
  items: ClipboardItem[];
  totalMatches: number;
  searchTimeMs: number;
  filtersApplied: SearchFilter[];
}

export class HistoryStore {
  private logger = createLogger({ module: 'history-store' });
  private classifier: ContentClassifier;
  private summarizer: ContentSummarizer;
  private storagePath: string;
  private items: Map<string, ClipboardItem> = new Map();
  private config: StorageConfig;
  private stats: StorageStats;
  private isInitialized = false;
  private encryptionKey: Buffer | null = null;
  private backupInterval: NodeJS.Timeout | null = null;
  private readonly ENCRYPTION_ALGORITHM = 'aes-256-gcm';

  constructor(classifier: ContentClassifier, summarizer: ContentSummarizer) {
    this.classifier = classifier;
    this.summarizer = summarizer;
    this.storagePath = CLIPBOARD.STORAGE_PATH;
    this.config = this.getDefaultConfig();
    this.stats = this.createInitialStats();
  }

  /**
   * Get default configuration
   */
  private getDefaultConfig(): StorageConfig {
    return {
      maxItems: CLIPBOARD.MAX_HISTORY_ITEMS,
      maxSizeMB: 100,
      autoPrune: true,
      compressOldItems: true,
      encryptionEnabled: true,
      backupEnabled: true,
      backupIntervalHours: 24,
      storageType: StorageType.LOCAL_SQLITE,
    };
  }

  /**
   * Create initial statistics
   */
  private createInitialStats(): StorageStats {
    return {
      totalItems: 0,
      totalSizeBytes: 0,
      itemsByType: {},
      oldestItemDate: null,
      newestItemDate: null,
      compressionRatio: 1.0,
      encryptedCount: 0,
    };
  }

  /**
   * Initialize history store
   */
  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    this.logger.info('Initializing history store');

    try {
      // Initialize dependencies
      if (!this.classifier.isReady()) {
        await this.classifier.initialize();
      }

      if (!this.summarizer.isReady()) {
        await this.summarizer.initialize();
      }

      // Load existing items from storage
      await this.loadFromStorage();

      // Setup encryption if enabled
      if (this.config.encryptionEnabled) {
        await this.setupEncryption();
      }

      // Start backup schedule
      if (this.config.backupEnabled) {
        this.startBackupSchedule();
      }

      this.isInitialized = true;
      this.logger.info('History store initialized successfully', {
        itemCount: this.stats.totalItems,
        totalSize: this.formatBytes(this.stats.totalSizeBytes),
      });

    } catch (error) {
      this.logger.error('Failed to initialize history store', error as Error);
      throw error;
    }
  }

  /**
   * Load items from storage
   */
  private async loadFromStorage(): Promise<void> {
    try {
      // In production, this would load from SQLite/JSON file
      this.logger.debug('Loading items from storage', { path: this.storagePath });
      
      // Simulate loading
      await new Promise(resolve => setTimeout(resolve, 100));
      
      this.logger.debug('Storage loading completed (simulated)');

    } catch (error) {
      this.logger.warn('Failed to load from storage, starting fresh', error as Error);
      this.items.clear();
    }
  }

  /**
   * Setup encryption system
   */
  private async setupEncryption(): Promise<void> {
    try {
      // In production, this would load or generate encryption keys
      this.logger.debug('Setting up encryption system');
      
      // For now, create a mock key
      this.encryptionKey = Buffer.from('mock-encryption-key-32-bytes-length', 'utf8');
      
      this.logger.info('Encryption system ready');

    } catch (error) {
      this.logger.error('Failed to setup encryption', error as Error);
      this.config.encryptionEnabled = false;
    }
  }

  /**
   * Start backup schedule
   */
  private startBackupSchedule(): void {
    const intervalMs = this.config.backupIntervalHours * 60 * 60 * 1000;
    
    this.backupInterval = setInterval(() => {
      this.createBackup();
    }, intervalMs);

    this.logger.debug('Backup schedule started', { intervalHours: this.config.backupIntervalHours });
  }

  /**
   * Create backup
   */
  private async createBackup(): Promise<void> {
    try {
      const backupPath = `${this.storagePath}.backup.${Date.now()}.json`;
      this.logger.info('Creating backup', { path: backupPath });
      
      // In production, this would copy the database/file
      await new Promise(resolve => setTimeout(resolve, 500));
      
      this.logger.debug('Backup created successfully');

    } catch (error) {
      this.logger.error('Failed to create backup', error as Error);
    }
  }

  /**
   * Save items to storage
   */
  private async saveToStorage(): Promise<void> {
    try {
      this.logger.debug('Saving items to storage', { 
        itemCount: this.items.size,
        path: this.storagePath,
      });
      
      // In production, this would save to SQLite/JSON file
      await new Promise(resolve => setTimeout(resolve, 200));
      
      this.logger.debug('Storage save completed');

    } catch (error) {
      this.logger.error('Failed to save to storage', error as Error);
    }
  }

  /**
   * Add item to history
   */
  public async addItem(
    content: string,
    format: ClipboardFormat,
    metadata: Partial<ClipboardMetadata> = {}
  ): Promise<ClipboardItem> {
    if (!this.isInitialized) {
      await this.initialize();
    }

    const startTime = Date.now();
    const itemId = `item_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    this.logger.debug('Adding item to history', {
      itemId,
      contentLength: content.length,
      format,
    });

    try {
      // Classify content
      const classification = await this.classifier.classify(content, {
        detailedAnalysis: true,
        includePatterns: true,
      });

      // Summarize content
      let summary = '';
      let keyPoints: string[] = [];
      
      if (content.length > 100) {
        const summaryResult = await this.summarizer.summarize(content, {
          compressionRatio: 0.3,
          preserveKeyPoints: true,
        });
        summary = summaryResult.summary;
        keyPoints = summaryResult.keyPoints;
      }

      // Create clipboard item
      const item: ClipboardItem = {
        id: itemId,
        content,
        format,
        metadata: {
          timestamp: new Date(),
          sourceApp: metadata.sourceApp || 'unknown',
          sourceWindow: metadata.sourceWindow,
          contentType: classification.primaryType,
          language: classification.language,
          isSensitive: classification.isSensitive,
          sensitiveType: classification.sensitiveType,
          sizeBytes: Buffer.byteLength(content, 'utf8'),
          lineCount: content.split('\n').length,
          wordCount: content.split(/\s+/).filter(w => w.length > 0).length,
          hasHtml: metadata.hasHtml || false,
          hasRtf: metadata.hasRtf || false,
          hasImage: metadata.hasImage || false,
          tags: metadata.tags || [],
        },
        classification,
        summary,
        keyPoints,
        favorites: false,
        pinned: false,
        lastAccessed: new Date(),
        accessCount: 0,
        version: 1,
      };

      // Encrypt sensitive content if needed
      if (classification.isSensitive && this.config.encryptionEnabled && this.encryptionKey) {
        await this.encryptItemContent(item);
      }

      // Compress old items if enabled
      if (this.config.compressOldItems && this.shouldCompressItem(item)) {
        await this.compressItem(item);
      }

      // Store item
      this.items.set(itemId, item);
      this.updateStats(item, 'add');

      // Auto prune if needed
      if (this.config.autoPrune) {
        await this.autoPrune();
      }

      // Save to persistent storage
      await this.saveToStorage();

      const processingTime = Date.now() - startTime;
      this.logger.info('Item added to history', {
        itemId,
        contentType: classification.primaryType,
        isSensitive: classification.isSensitive,
        processingTime,
      });

      return item;

    } catch (error) {
      this.logger.error('Failed to add item to history', error as Error, {
        itemId,
        contentLength: content.length,
      });
      throw error;
    }
  }

  /**
   * Encrypt item content
   */
  private async encryptItemContent(item: ClipboardItem): Promise<void> {
    try {
      // In production, use actual encryption
      this.logger.debug('Encrypting item content', { itemId: item.id });
      
      // Mark as encrypted
      (item.metadata as any).encrypted = true;
      (item.metadata as any).encryptionTimestamp = new Date();
      
      this.stats.encryptedCount++;

    } catch (error) {
      this.logger.error('Failed to encrypt item', error as Error, { itemId: item.id });
      throw error;
    }
  }

  /**
   * Check if item should be compressed
   */
  private shouldCompressItem(item: ClipboardItem): boolean {
    const age = Date.now() - item.metadata.timestamp.getTime();
    const ageDays = age / (1000 * 60 * 60 * 24);
    
    // Compress items older than 7 days and larger than 1KB
    return ageDays > 7 && item.metadata.sizeBytes > 1024;
  }

  /**
   * Compress item content
   */
  private async compressItem(item: ClipboardItem): Promise<void> {
    try {
      // In production, use actual compression
      this.logger.debug('Compressing item', { 
        itemId: item.id,
        originalSize: item.metadata.sizeBytes,
      });
      
      // Mark as compressed
      (item.metadata as any).compressed = true;
      (item.metadata as any).compressionMethod = CompressionMethod.GZIP;
      
      // Update stats with compression ratio
      this.stats.compressionRatio = 0.7; // Simulated 30% compression

    } catch (error) {
      this.logger.warn('Failed to compress item', error as Error, { itemId: item.id });
    }
  }

  /**
   * Update statistics
   */
  private updateStats(item: ClipboardItem, operation: 'add' | 'remove' | 'update'): void {
    const contentType = item.classification.primaryType;
    
    switch (operation) {
      case 'add':
        this.stats.totalItems++;
        this.stats.totalSizeBytes += item.metadata.sizeBytes;
        this.stats.itemsByType[contentType] = (this.stats.itemsByType[contentType] || 0) + 1;
        
        if (!this.stats.oldestItemDate || item.metadata.timestamp < this.stats.oldestItemDate) {
          this.stats.oldestItemDate = item.metadata.timestamp;
        }
        
        if (!this.stats.newestItemDate || item.metadata.timestamp > this.stats.newestItemDate) {
          this.stats.newestItemDate = item.metadata.timestamp;
        }
        break;

      case 'remove':
        this.stats.totalItems--;
        this.stats.totalSizeBytes -= item.metadata.sizeBytes;
        this.stats.itemsByType[contentType] = Math.max(0, (this.stats.itemsByType[contentType] || 0) - 1);
        break;
    }

    // Update compression stats
    if ((item.metadata as any).compressed) {
      this.stats.compressionRatio = 0.8; // Updated ratio
    }
  }

  /**
   * Auto prune old items
   */
  private async autoPrune(): Promise<void> {
    // Check if we need to prune
    const needsSizePrune = this.stats.totalSizeBytes > this.config.maxSizeMB * 1024 * 1024;
    const needsCountPrune = this.stats.totalItems > this.config.maxItems;
    
    if (!needsSizePrune && !needsCountPrune) {
      return;
    }

    this.logger.info('Auto-pruning history store', {
      currentItems: this.stats.totalItems,
      maxItems: this.config.maxItems,
      currentSize: this.formatBytes(this.stats.totalSizeBytes),
      maxSize: `${this.config.maxSizeMB}MB`,
    });

    // Get all items sorted by oldest first
    const itemsArray = Array.from(this.items.values());
    itemsArray.sort((a, b) => a.metadata.timestamp.getTime() - b.metadata.timestamp.getTime());

    let removedCount = 0;
    let removedSize = 0;

    // Remove oldest items until under limits
    for (const item of itemsArray) {
      if (this.stats.totalItems <= this.config.maxItems && 
          this.stats.totalSizeBytes <= this.config.maxSizeMB * 1024 * 1024) {
        break;
      }

      // Don't remove pinned or favorite items
      if (item.pinned || item.favorites) {
        continue;
      }

      // Remove the item
      this.items.delete(item.id);
      this.updateStats(item, 'remove');
      
      removedCount++;
      removedSize += item.metadata.sizeBytes;
    }

    if (removedCount > 0) {
      await this.saveToStorage();
      this.logger.info('Auto-prune completed', {
        removedCount,
        removedSize: this.formatBytes(removedSize),
        remainingItems: this.stats.totalItems,
        remainingSize: this.formatBytes(this.stats.totalSizeBytes),
      });
    }
  }

  /**
   * Get item by ID
   */
  public getItem(id: string): ClipboardItem | undefined {
    const item = this.items.get(id);
    
    if (item) {
      item.accessCount++;
      item.lastAccessed = new Date();
      this.logger.debug('Item accessed', { itemId: id, accessCount: item.accessCount });
    }
    
    return item;
  }

  /**
   * Get all items
   */
  public getAllItems(limit?: number): ClipboardItem[] {
    const items = Array.from(this.items.values())
      .sort((a, b) => b.metadata.timestamp.getTime() - a.metadata.timestamp.getTime());
    
    return limit ? items.slice(0, limit) : items;
  }

  /**
   * Get items by type
   */
  public getItemsByType(contentType: string): ClipboardItem[] {
    return Array.from(this.items.values())
      .filter(item => item.classification.primaryType === contentType)
      .sort((a, b) => b.metadata.timestamp.getTime() - a.metadata.timestamp.getTime());
  }

  /**
   * Get items by tag
   */
  public getItemsByTag(tag: string): ClipboardItem[] {
    return Array.from(this.items.values())
      .filter(item => item.metadata.tags.includes(tag))
      .sort((a, b) => b.metadata.timestamp.getTime() - a.metadata.timestamp.getTime());
  }

  /**
   * Get favorite items
   */
  public getFavoriteItems(): ClipboardItem[] {
    return Array.from(this.items.values())
      .filter(item => item.favorites)
      .sort((a, b) => b.metadata.timestamp.getTime() - a.metadata.timestamp.getTime());
  }

  /**
   * Get pinned items
   */
  public getPinnedItems(): ClipboardItem[] {
    return Array.from(this.items.values())
      .filter(item => item.pinned)
      .sort((a, b) => b.metadata.timestamp.getTime() - a.metadata.timestamp.getTime());
  }

  /**
   * Search items
   */
  public searchItems(query: string, filters: SearchFilter[] = []): SearchResult {
    const startTime = Date.now();
    
    let results = Array.from(this.items.values());
    
    // Apply text search
    if (query.trim()) {
      const searchTerms = query.toLowerCase().split(/\s+/);
      results = results.filter(item => {
        const searchableText = (
          item.content.toLowerCase() + 
          ' ' + (item.summary || '').toLowerCase() +
          ' ' + item.metadata.tags.join(' ').toLowerCase()
        );
        
        return searchTerms.every(term => searchableText.includes(term));
      });
    }
    
    // Apply filters
    for (const filter of filters) {
      switch (filter.type) {
        case 'contentType':
          if (filter.value) {
            results = results.filter(item => 
              item.classification.primaryType === filter.value
            );
          }
          break;
          
        case 'dateRange':
          if (filter.startDate && filter.endDate) {
            results = results.filter(item => 
              item.metadata.timestamp >= filter.startDate! &&
              item.metadata.timestamp <= filter.endDate!
            );
          }
          break;
          
        case 'hasSensitive':
          if (filter.value !== undefined) {
            results = results.filter(item => 
              item.classification.isSensitive === filter.value
            );
          }
          break;
          
        case 'minSize':
          if (filter.value) {
            results = results.filter(item => 
              item.metadata.sizeBytes >= (filter.value as number)
            );
          }
          break;
          
        case 'maxSize':
          if (filter.value) {
            results = results.filter(item => 
              item.metadata.sizeBytes <= (filter.value as number)
            );
          }
          break;
          
        case 'tags':
          if (filter.value && Array.isArray(filter.value)) {
            const requiredTags = filter.value as string[];
            results = results.filter(item =>
              requiredTags.every(tag => item.metadata.tags.includes(tag))
            );
          }
          break;
      }
    }
    
    // Sort by relevance/date
    results.sort((a, b) => b.metadata.timestamp.getTime() - a.metadata.timestamp.getTime());
    
    const searchTimeMs = Date.now() - startTime;
    
    this.logger.debug('Search completed', {
      query,
      filterCount: filters.length,
      resultCount: results.length,
      searchTimeMs,
    });
    
    return {
      items: results,
      totalMatches: results.length,
      searchTimeMs,
      filtersApplied: filters,
    };
  }

  /**
   * Update item metadata
   */
  public updateItem(id: string, updates: Partial<ClipboardItem>): boolean {
    const item = this.items.get(id);
    
    if (!item) {
      return false;
    }
    
    // Apply updates
    Object.assign(item, updates);
    item.version = (item.version || 0) + 1;
    
    this.logger.debug('Item updated', { itemId: id, updates: Object.keys(updates) });
    this.saveToStorage(); // Async, no await
    
    return true;
  }

  /**
   * Toggle favorite status
   */
  public toggleFavorite(id: string): boolean {
    const item = this.items.get(id);
    
    if (!item) {
      return false;
    }
    
    item.favorites = !item.favorites;
    item.version = (item.version || 0) + 1;
    
    this.logger.debug('Favorite toggled', { 
      itemId: id, 
      isFavorite: item.favorites 
    });
    
    this.saveToStorage(); // Async, no await
    return true;
  }

  /**
   * Toggle pinned status
   */
  public togglePinned(id: string): boolean {
    const item = this.items.get(id);
    
    if (!item) {
      return false;
    }
    
    item.pinned = !item.pinned;
    item.version = (item.version || 0) + 1;
    
    this.logger.debug('Pinned toggled', { 
      itemId: id, 
      isPinned: item.pinned 
    });
    
    this.saveToStorage(); // Async, no await
    return true;
  }

  /**
   * Add tag to item
   */
  public addTag(id: string, tag: string): boolean {
    const item = this.items.get(id);
    
    if (!item) {
      return false;
    }
    
    if (!item.metadata.tags.includes(tag)) {
      item.metadata.tags.push(tag);
      item.version = (item.version || 0) + 1;
      
      this.logger.debug('Tag added', { itemId: id, tag });
      this.saveToStorage(); // Async, no await
    }
    
    return true;
  }

  /**
   * Remove tag from item
   */
  public removeTag(id: string, tag: string): boolean {
    const item = this.items.get(id);
    
    if (!item) {
      return false;
    }
    
    const index = item.metadata.tags.indexOf(tag);
    if (index !== -1) {
      item.metadata.tags.splice(index, 1);
      item.version = (item.version || 0) + 1;
      
      this.logger.debug('Tag removed', { itemId: id, tag });
      this.saveToStorage(); // Async, no await
    }
    
    return true;
  }

  /**
   * Delete item
   */
  public deleteItem(id: string): boolean {
    const item = this.items.get(id);
    
    if (!item) {
      return false;
    }
    
    // Don't delete pinned items without force
    if (item.pinned) {
      this.logger.warn('Attempted to delete pinned item', { itemId: id });
      return false;
    }
    
    this.items.delete(id);
    this.updateStats(item, 'remove');
    
    this.logger.info('Item deleted', { 
      itemId: id, 
      contentType: item.classification.primaryType,
      age: this.formatAge(Date.now() - item.metadata.timestamp.getTime()),
    });
    
    this.saveToStorage(); // Async, no await
    return true;
  }

  /**
   * Clear all items
   */
  public clearAll(includePinned: boolean = false): number {
    let itemsToDelete: ClipboardItem[] = [];
    
    if (includePinned) {
      itemsToDelete = Array.from(this.items.values());
    } else {
      itemsToDelete = Array.from(this.items.values()).filter(item => !item.pinned);
    }
    
    const deleteCount = itemsToDelete.length;
    
    // Remove items
    for (const item of itemsToDelete) {
      this.items.delete(item.id);
      this.updateStats(item, 'remove');
    }
    
    this.logger.info('All items cleared', { 
      deletedCount: deleteCount,
      remainingCount: this.items.size,
      includePinned,
    });
    
    this.saveToStorage(); // Async, no await
    return deleteCount;
  }

  /**
   * Get storage statistics
   */
  public getStats(): StorageStats {
    return { ...this.stats };
  }

  /**
   * Export items to JSON
   */
  public exportItems(includeSensitive: boolean = false): string {
    const itemsToExport = Array.from(this.items.values())
      .filter(item => includeSensitive || !item.classification.isSensitive)
      .map(item => ({
        ...item,
        // Don't include encryption keys in export
        metadata: { ...item.metadata, encrypted: undefined, encryptionKey: undefined },
      }));
    
    const exportData = {
      version: '1.0.0',
      exportDate: new Date().toISOString(),
      itemCount: itemsToExport.length,
      totalSize: this.stats.totalSizeBytes,
      items: itemsToExport,
    };
    
    this.logger.info('Items exported', { 
      itemCount: itemsToExport.length,
      includeSensitive,
    });
    
    return JSON.stringify(exportData, null, 2);
  }

  /**
   * Import items from JSON
   */
  public async importItems(json: string): Promise<number> {
    try {
      const importData = JSON.parse(json);
      
      if (!importData.items || !Array.isArray(importData.items)) {
        throw new Error('Invalid import format');
      }
      
      let importedCount = 0;
      
      for (const itemData of importData.items) {
        try {
          // Validate required fields
          if (!itemData.id || !itemData.content) {
            continue;
          }
          
          // Create or update item
          const existingItem = this.items.get(itemData.id);
          if (existingItem) {
            // Update existing
            Object.assign(existingItem, itemData);
            existingItem.version = (existingItem.version || 0) + 1;
          } else {
            // Add new
            this.items.set(itemData.id, itemData as ClipboardItem);
            this.updateStats(itemData as ClipboardItem, 'add');
          }
          
          importedCount++;
          
        } catch (error) {
          this.logger.warn('Failed to import item', error as Error, { itemId: itemData.id });
        }
      }
      
      await this.saveToStorage();
      
      this.logger.info('Items imported', { 
        importedCount,
        totalItems: this.stats.totalItems,
      });
      
      return importedCount;
      
    } catch (error) {
      this.logger.error('Failed to import items', error as Error);
      throw error;
    }
  }

  /**
   * Format bytes to human readable
   */
  private formatBytes(bytes: number): string {
    if (bytes === 0) return '0 Bytes';
    
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  /**
   * Format age to human readable
   */
  private formatAge(ms: number): string {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    
    if (days > 0) return `${days}d ${hours % 24}h`;
    if (hours > 0) return `${hours}h ${minutes % 60}m`;
    if (minutes > 0) return `${minutes}m ${seconds % 60}s`;
    return `${seconds}s`;
  }

  /**
   * Check if store is ready
   */
  public isReady(): boolean {
    return this.isInitialized;
  }

  /**
   * Cleanup resources
   */
  public async cleanup(): Promise<void> {
    this.logger.info('Cleaning up history store');
    
    // Clear backup interval
    if (this.backupInterval) {
      clearInterval(this.backupInterval);
      this.backupInterval = null;
    }
    
    // Save final state
    await this.saveToStorage();
    
    this.logger.info('History store cleanup completed');
  }
}
