/**
 * Knoux Clipboard AI - Clipboard Watcher Core
 * Monitors clipboard changes and coordinates with other components
 * Generated by Knoux — Abu Retaj
 * Clipboard Intelligence • Desktop Precision • Premium Engineering
 */

import { clipboard, nativeImage } from 'electron';
import { llog } from '../../shared/localized-logger';
import { CLIPBOARD, CONTENT_TYPES } from '../../shared/constants';
import { ClipboardItem, ClipboardMetadata, ClipboardEvent } from '../../shared/types';
import { ClipboardFormat, ClipboardState, DetectionMode } from '../../shared/enums';
import { ClipboardNormalizer } from './normalizer';
import { ClipboardFormatter } from './formatter';
import { HistoryStore } from './history-store';

/**
 * Watcher configuration
 */
export interface WatcherConfig {
  enabled: boolean;
  pollIntervalMs: number;
  detectionMode: DetectionMode;
  captureImages: boolean;
  captureHtml: boolean;
  captureRtf: boolean;
  maxItemSizeKB: number;
  excludeApps: string[];
  autoClearSensitive: boolean;
  autoClearMinutes: number;
}

/**
 * Clipboard change event
 */
export interface ClipboardChange {
  content: string;
  format: ClipboardFormat;
  timestamp: number;
  sourceApp?: string;
  sourceWindow?: string;
  imageData?: Buffer;
  htmlContent?: string;
  rtfContent?: string;
}

/**
 * Watcher statistics
 */
export interface WatcherStats {
  totalChanges: number;
  capturedChanges: number;
  ignoredChanges: number;
  averageProcessingTime: number;
  lastChangeTime: number;
  state: ClipboardState;
  errorCount: number;
}

export class ClipboardWatcher {
  private logger = createLogger({ module: 'clipboard-watcher' });
  private config: WatcherConfig;
  private normalizer: ClipboardNormalizer;
  private formatter: ClipboardFormatter;
  private historyStore: HistoryStore;
  private state: ClipboardState = ClipboardState.DISABLED;
  private lastContent: string = '';
  private lastImageHash: string = '';
  private pollingInterval: NodeJS.Timeout | null = null;
  private eventListeners: Array<(event: ClipboardEvent) => void> = [];
  private stats: WatcherStats;
  private isInitialized = false;
  private processingQueue: Set<string> = new Set();
  private changeDebounceTimer: NodeJS.Timeout | null = null;
  private readonly DEBOUNCE_DELAY = 300;

  constructor(
    normalizer: ClipboardNormalizer,
    formatter: ClipboardFormatter,
    historyStore: HistoryStore
  ) {
    this.normalizer = normalizer;
    this.formatter = formatter;
    this.historyStore = historyStore;
    this.config = this.getDefaultConfig();
    this.stats = this.createInitialStats();
  }

  /**
   * Get default configuration
   */
  private getDefaultConfig(): WatcherConfig {
    return {
      enabled: true,
      pollIntervalMs: CLIPBOARD.POLL_INTERVAL_MS,
      detectionMode: DetectionMode.POLLING,
      captureImages: false,
      captureHtml: true,
      captureRtf: true,
      maxItemSizeKB: 1024,
      excludeApps: [],
      autoClearSensitive: true,
      autoClearMinutes: 5,
    };
  }

  /**
   * Create initial statistics
   */
  private createInitialStats(): WatcherStats {
    return {
      totalChanges: 0,
      capturedChanges: 0,
      ignoredChanges: 0,
      averageProcessingTime: 0,
      lastChangeTime: 0,
      state: this.state,
      errorCount: 0,
    };
  }

  /**
   * Initialize the watcher
   */
  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    this.llog.info('Initializing clipboard watcher');

    try {
      // Initialize dependencies
      await this.normalizer.initialize();
      await this.formatter.initialize();
      await this.historyStore.initialize();

      // Get initial clipboard content
      this.lastContent = this.getCurrentClipboardText();
      this.lastImageHash = this.getCurrentImageHash();

      this.isInitialized = true;
      this.llog.info('Clipboard watcher initialized successfully');

      // Start watching if enabled
      if (this.config.enabled) {
        await this.startWatching();
      }

    } catch (error) {
      this.llog.error('Failed to initialize clipboard watcher', error as Error);
      throw error;
    }
  }

  /**
   * Update configuration
   */
  public updateConfig(config: Partial<WatcherConfig>): void {
    const oldConfig = { ...this.config };
    this.config = { ...this.config, ...config };

    const configChanged = JSON.stringify(oldConfig) !== JSON.stringify(this.config);
    if (configChanged) {
      this.llog.info('Clipboard watcher configuration updated', {
        oldConfig,
        newConfig: this.config,
      });

      // Restart watching if enabled state changed
      if (oldConfig.enabled !== this.config.enabled) {
        if (this.config.enabled) {
          this.startWatching();
        } else {
          this.stopWatching();
        }
      }

      // Update polling interval if changed
      if (oldConfig.pollIntervalMs !== this.config.pollIntervalMs && this.pollingInterval) {
        this.restartPolling();
      }
    }
  }

  /**
   * Start watching clipboard
   */
  public async startWatching(): Promise<void> {
    if (this.state === ClipboardState.ACTIVE) {
      return;
    }

    this.llog.info('Starting clipboard watcher');

    try {
      // Stop any existing monitoring
      this.stopWatching();

      // Start based on detection mode
      switch (this.config.detectionMode) {
        case DetectionMode.POLLING:
          this.startPolling();
          break;
        
        case DetectionMode.EVENT_DRIVEN:
          this.startEventDriven();
          break;
        
        case DetectionMode.HYBRID:
          this.startHybrid();
          break;
        
        case DetectionMode.MANUAL:
          this.setState(ClipboardState.ACTIVE);
          break;
      }

      this.setState(ClipboardState.ACTIVE);
      this.llog.info('Clipboard watcher started successfully', {
        mode: this.config.detectionMode,
        interval: this.config.pollIntervalMs,
      });

    } catch (error) {
      this.llog.error('Failed to start clipboard watcher', error as Error);
      this.setState(ClipboardState.ERROR);
      throw error;
    }
  }

  /**
   * Stop watching clipboard
   */
  public stopWatching(): void {
    this.llog.info('Stopping clipboard watcher');

    // Clear polling interval
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
      this.pollingInterval = null;
    }

    // Clear debounce timer
    if (this.changeDebounceTimer) {
      clearTimeout(this.changeDebounceTimer);
      this.changeDebounceTimer = null;
    }

    // Clear event listeners
    this.eventListeners = [];

    this.setState(ClipboardState.DISABLED);
    this.llog.info('Clipboard watcher stopped');
  }

  /**
   * Start polling mode
   */
  private startPolling(): void {
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
    }

    this.pollingInterval = setInterval(() => {
      this.checkClipboardChanges();
    }, this.config.pollIntervalMs);

    this.llog.debug('Started polling mode', { interval: this.config.pollIntervalMs });
  }

  /**
   * Start event-driven mode
   */
  private startEventDriven(): void {
    // Electron doesn't have native clipboard change events on Windows
    // We'll use polling with a shorter interval as fallback
    this.llog.warn('Event-driven mode not fully supported, using polling fallback');
    this.startPolling();
  }

  /**
   * Start hybrid mode
   */
  private startHybrid(): void {
    // Combine polling with other detection methods
    this.startPolling();
    this.llog.debug('Started hybrid detection mode');
  }

  /**
   * Restart polling with new interval
   */
  private restartPolling(): void {
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
      this.startPolling();
    }
  }

  /**
   * Check for clipboard changes
   */
  private async checkClipboardChanges(): Promise<void> {
    if (this.state !== ClipboardState.ACTIVE) {
      return;
    }

    try {
      // Check for text changes
      const currentText = this.getCurrentClipboardText();
      if (this.hasTextChanged(currentText)) {
        await this.handleTextChange(currentText);
        return;
      }

      // Check for image changes if enabled
      if (this.config.captureImages) {
        const currentImageHash = this.getCurrentImageHash();
        if (this.hasImageChanged(currentImageHash)) {
          await this.handleImageChange();
          return;
        }
      }

    } catch (error) {
      this.llog.error('Error checking clipboard changes', error as Error);
      this.stats.errorCount++;
    }
  }

  /**
   * Get current clipboard text
   */
  private getCurrentClipboardText(): string {
    try {
      return clipboard.readText() || '';
    } catch (error) {
      this.llog.warn('Failed to read clipboard text', error as Error);
      return '';
    }
  }

  /**
   * Get current image hash
   */
  private getCurrentImageHash(): string {
    try {
      if (!clipboard.hasImage()) {
        return '';
      }

      const image = clipboard.readImage();
      if (image.isEmpty()) {
        return '';
      }

      // Create simple hash from image dimensions
      const size = image.getSize();
      return x;

    } catch (error) {
      this.llog.warn('Failed to read clipboard image', error as Error);
      return '';
    }
  }

  /**
   * Check if text has changed
   */
  private hasTextChanged(currentText: string): boolean {
    if (currentText === this.lastContent) {
      return false;
    }

    // Ignore empty or whitespace-only changes
    if (!currentText.trim() && !this.lastContent.trim()) {
      return false;
    }

    // Ignore very similar text (likely just formatting)
    if (this.isSimilarText(currentText, this.lastContent)) {
      return false;
    }

    return true;
  }

  /**
   * Check if image has changed
   */
  private hasImageChanged(currentHash: string): boolean {
    return currentHash !== '' && currentHash !== this.lastImageHash;
  }

  /**
   * Check if texts are similar
   */
  private isSimilarText(text1: string, text2: string): boolean {
    if (!text1 || !text2) {
      return false;
    }

    // Normalize whitespace
    const normalized1 = text1.replace(/\s+/g, ' ').trim();
    const normalized2 = text2.replace(/\s+/g, ' ').trim();

    // Check if one contains the other
    if (normalized1.includes(normalized2) || normalized2.includes(normalized1)) {
      return true;
    }

    // Check similarity ratio (simple implementation)
    const similarity = this.calculateSimilarity(normalized1, normalized2);
    return similarity > 0.8;
  }

  /**
   * Calculate text similarity
   */
  private calculateSimilarity(text1: string, text2: string): number {
    if (text1 === text2) return 1.0;
    if (text1.length === 0 || text2.length === 0) return 0.0;

    // Simple Levenshtein distance based similarity
    const maxLength = Math.max(text1.length, text2.length);
    if (maxLength === 0) return 0.0;

    // For simplicity, use a basic character overlap
    const set1 = new Set(text1);
    const set2 = new Set(text2);
    const intersection = new Set([...set1].filter(x => set2.has(x)));
    
    return intersection.size / Math.max(set1.size, set2.size);
  }

  /**
   * Handle text change
   */
  private async handleTextChange(currentText: string): Promise<void> {
    const timestamp = Date.now();
    const changeId = change__;

    // Debounce rapid changes
    if (this.changeDebounceTimer) {
      clearTimeout(this.changeDebounceTimer);
    }

    this.changeDebounceTimer = setTimeout(async () => {
      if (this.processingQueue.has(changeId)) {
        return;
      }

      this.processingQueue.add(changeId);
      this.stats.totalChanges++;

      try {
        // Get source application info
        const sourceApp = await this.getSourceApplication();
        
        // Check if app is excluded
        if (this.isAppExcluded(sourceApp)) {
          this.llog.debug('Ignoring clipboard change from excluded app', { app: sourceApp });
          this.stats.ignoredChanges++;
          return;
        }

        // Check content size
        if (this.isContentTooLarge(currentText)) {
          this.llog.warn('Clipboard content too large, ignoring', {
            size: currentText.length,
            limit: this.config.maxItemSizeKB * 1024,
          });
          this.stats.ignoredChanges++;
          return;
        }

        // Create clipboard change object
        const change: ClipboardChange = {
          content: currentText,
          format: ClipboardFormat.TEXT,
          timestamp,
          sourceApp,
          sourceWindow: await this.getSourceWindow(),
        };

        // Get additional formats if enabled
        if (this.config.captureHtml && clipboard.has('text/html')) {
          try {
            change.htmlContent = clipboard.readHTML();
          } catch (error) {
            this.llog.debug('Failed to read HTML from clipboard', error as Error);
          }
        }

        if (this.config.captureRtf && clipboard.has('text/rtf')) {
          try {
            change.rtfContent = clipboard.readRTF();
          } catch (error) {
            this.llog.debug('Failed to read RTF from clipboard', error as Error);
          }
        }

        // Process the change
        await this.processClipboardChange(change);

        // Update last content
        this.lastContent = currentText;
        this.stats.capturedChanges++;
        this.stats.lastChangeTime = timestamp;

        this.llog.debug('Clipboard text change processed', {
          length: currentText.length,
          sourceApp,
          timestamp,
        });

      } catch (error) {
        this.llog.error('Failed to process clipboard text change', error as Error, {
          changeId,
          contentLength: currentText.length,
        });
        this.stats.errorCount++;
      } finally {
        this.processingQueue.delete(changeId);
      }
    }, this.DEBOUNCE_DELAY);
  }

  /**
   * Handle image change
   */
  private async handleImageChange(): Promise<void> {
    if (!this.config.captureImages) {
      return;
    }

    const timestamp = Date.now();
    const changeId = image__;

    if (this.processingQueue.has(changeId)) {
      return;
    }

    this.processingQueue.add(changeId);
    this.stats.totalChanges++;

    try {
      // Get image from clipboard
      const image = clipboard.readImage();
      if (image.isEmpty()) {
        this.llog.debug('Clipboard image is empty');
        return;
      }

      // Get source application
      const sourceApp = await this.getSourceApplication();
      
      // Check if app is excluded
      if (this.isAppExcluded(sourceApp)) {
        this.llog.debug('Ignoring clipboard image from excluded app', { app: sourceApp });
        this.stats.ignoredChanges++;
        return;
      }

      // Convert image to buffer for processing
      const pngBuffer = image.toPNG();
      
      // Check image size
      if (this.isImageTooLarge(pngBuffer)) {
        this.llog.warn('Clipboard image too large, ignoring', {
          size: pngBuffer.length,
          limit: this.config.maxItemSizeKB * 1024,
        });
        this.stats.ignoredChanges++;
        return;
      }

      // Create clipboard change for image
      const change: ClipboardChange = {
        content: '[Image captured]',
        format: ClipboardFormat.IMAGE,
        timestamp,
        sourceApp,
        sourceWindow: await this.getSourceWindow(),
        imageData: pngBuffer,
      };

      // Process the image change
      await this.processClipboardChange(change);

      // Update last image hash
      this.lastImageHash = this.getCurrentImageHash();
      this.stats.capturedChanges++;
      this.stats.lastChangeTime = timestamp;

      this.llog.debug('Clipboard image change processed', {
        size: pngBuffer.length,
        dimensions: image.getSize(),
        sourceApp,
        timestamp,
      });

    } catch (error) {
      this.llog.error('Failed to process clipboard image change', error as Error, {
        changeId,
      });
      this.stats.errorCount++;
    } finally {
      this.processingQueue.delete(changeId);
    }
  }

  /**
   * Process clipboard change
   */
  private async processClipboardChange(change: ClipboardChange): Promise<void> {
    const startTime = Date.now();

    try {
      // Normalize content
      const normalizedContent = await this.normalizer.normalize(
        change.content,
        change.format
      );

      // Create metadata
      const metadata: ClipboardMetadata = {
        language: await this.detectLanguage(normalizedContent),
        lineCount: normalizedContent.split('\n').length,
        charCount: normalizedContent.length,
        wordCount: normalizedContent.split(/\s+/).filter(w => w.length > 0).length,
        hasUrls: this.containsUrls(normalizedContent),
        hasEmails: this.containsEmails(normalizedContent),
        hasCode: this.containsCode(normalizedContent),
        sourceProcess: change.sourceApp,
        sourceWindow: change.sourceWindow,
      };

      // Format preview
      const preview = this.formatter.createPreview(normalizedContent, {
        maxLength: CLIPBOARD.TRUNCATE_PREVIEW_LENGTH,
        preserveFormatting: true,
      });

      // Create clipboard item
      const item: ClipboardItem = {
        id: item__,
        content: normalizedContent,
        contentType: this.mapFormatToContentType(change.format),
        sourceApp: change.sourceApp,
        timestamp: change.timestamp,
        sizeBytes: Buffer.from(normalizedContent).length,
        preview,
        metadata,
        tags: [],
        isSensitive: false,
        isEncrypted: false,
        createdAt: new Date(change.timestamp),
        updatedAt: new Date(change.timestamp),
      };

      // Store in history
      await this.historyStore.addItem(item);

      // Update statistics
      const processingTime = Date.now() - startTime;
      this.updateAverageProcessingTime(processingTime);

      // Notify listeners
      this.notifyListeners({
        type: 'added',
        item,
        timestamp: change.timestamp,
      });

      this.llog.info('Clipboard change processed successfully', {
        itemId: item.id,
        contentType: item.contentType,
        processingTime,
      });

    } catch (error) {
      this.llog.error('Failed to process clipboard change', error as Error, {
        format: change.format,
        timestamp: change.timestamp,
      });
      throw error;
    }
  }

  /**
   * Map format to content type
   */
  private mapFormatToContentType(format: ClipboardFormat): string {
    switch (format) {
      case ClipboardFormat.TEXT:
        return 'text';
      case ClipboardFormat.HTML:
        return 'html';
      case ClipboardFormat.RTF:
        return 'rtf';
      case ClipboardFormat.IMAGE:
        return 'image';
      default:
        return 'text';
    }
  }

  /**
   * Get source application
   */
  private async getSourceApplication(): Promise<string> {
    try {
      // On Windows, we can use PowerShell to get foreground process
      if (process.platform === 'win32') {
        const { exec } = require('child_process');
        return new Promise((resolve) => {
          exec('powershell -Command "Get-Process | Where-Object { $_.MainWindowHandle -ne 0 } | Select-Object -First 1 ProcessName"', 
            (error: any, stdout: string) => {
              if (error || !stdout) {
                resolve('unknown');
              } else {
                resolve(stdout.trim().toLowerCase());
              }
            });
        });
      }
      
      // For other platforms or fallback
      return 'unknown';
      
    } catch (error) {
      this.llog.debug('Failed to get source application', error as Error);
      return 'unknown';
    }
  }

  /**
   * Get source window title
   */
  private async getSourceWindow(): Promise<string | undefined> {
    try {
      // Similar to getSourceApplication, but for window title
      return undefined; // Simplified for now
    } catch (error) {
      return undefined;
    }
  }

  /**
   * Check if application is excluded
   */
  private isAppExcluded(appName: string): boolean {
    if (!appName || appName === 'unknown') {
      return false;
    }

    return this.config.excludeApps.some(excludedApp => 
      appName.toLowerCase().includes(excludedApp.toLowerCase()) ||
      excludedApp.toLowerCase().includes(appName.toLowerCase())
    );
  }

  /**
   * Check if content is too large
   */
  private isContentTooLarge(content: string): boolean {
    const sizeBytes = Buffer.from(content).length;
    return sizeBytes > this.config.maxItemSizeKB * 1024;
  }

  /**
   * Check if image is too large
   */
  private isImageTooLarge(imageBuffer: Buffer): boolean {
    return imageBuffer.length > this.config.maxItemSizeKB * 1024;
  }

  /**
   * Detect language in content
   */
  private async detectLanguage(content: string): Promise<string | undefined> {
    // Simple language detection based on common patterns
    if (content.includes('function') || content.includes('const ') || content.includes('let ')) {
      return 'javascript';
    } else if (content.includes('def ') || content.includes('import ')) {
      return 'python';
    } else if (content.includes('Get-') || content.includes('$')) {
      return 'powershell';
    } else if (content.includes('{') && content.includes('}')) {
      return 'json';
    }
    
    return undefined;
  }

  /**
   * Check if content contains URLs
   */
  private containsUrls(content: string): boolean {
    return /(https?:\/\/|www\.)[^\s/$.?#].[^\s]*/.test(content);
  }

  /**
   * Check if content contains emails
   */
  private containsEmails(content: string): boolean {
    return /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/.test(content);
  }

  /**
   * Check if content contains code
   */
  private containsCode(content: string): boolean {
    const codePatterns = [
      /function\s+\w+\(/,
      /def\s+\w+\(/,
      /class\s+\w+/,
      /import\s+\w+/,
      /console\.log\(/,
      /Get-\w+/,
      /\{.*\}/s,
      /\[.*\]/s,
    ];
    
    return codePatterns.some(pattern => pattern.test(content));
  }

  /**
   * Update average processing time
   */
  private updateAverageProcessingTime(newTime: number): void {
    const currentAverage = this.stats.averageProcessingTime;
    const totalProcessed = this.stats.capturedChanges;
    
    if (totalProcessed <= 1) {
      this.stats.averageProcessingTime = newTime;
    } else {
      this.stats.averageProcessingTime = 
        (currentAverage * (totalProcessed - 1) + newTime) / totalProcessed;
    }
  }

  /**
   * Set watcher state
   */
  private setState(newState: ClipboardState): void {
    const oldState = this.state;
    this.state = newState;
    this.stats.state = newState;

    if (oldState !== newState) {
      this.llog.debug('Watcher state changed', { oldState, newState });
    }
  }

  /**
   * Add event listener
   */
  public addEventListener(listener: (event: ClipboardEvent) => void): () => void {
    this.eventListeners.push(listener);
    
    // Return unsubscribe function
    return () => {
      const index = this.eventListeners.indexOf(listener);
      if (index !== -1) {
        this.eventListeners.splice(index, 1);
      }
    };
  }

  /**
   * Notify all listeners
   */
  private notifyListeners(event: ClipboardEvent): void {
    this.eventListeners.forEach(listener => {
      try {
        listener(event);
      } catch (error) {
        this.llog.error('Error in clipboard event listener', error as Error);
      }
    });
  }

  /**
   * Manually trigger clipboard check
   */
  public async checkNow(): Promise<void> {
    if (this.state !== ClipboardState.ACTIVE) {
      throw new Error('Watcher is not active');
    }

    this.llog.debug('Manual clipboard check triggered');
    await this.checkClipboardChanges();
  }

  /**
   * Pause watching
   */
  public pause(): void {
    if (this.state === ClipboardState.ACTIVE) {
      this.setState(ClipboardState.PAUSED);
      this.llog.info('Clipboard watcher paused');
    }
  }

  /**
   * Resume watching
   */
  public resume(): void {
    if (this.state === ClipboardState.PAUSED) {
      this.setState(ClipboardState.ACTIVE);
      this.llog.info('Clipboard watcher resumed');
    }
  }

  /**
   * Get watcher statistics
   */
  public getStats(): WatcherStats {
    return { ...this.stats };
  }

  /**
   * Clear watcher statistics
   */
  public clearStats(): void {
    this.stats = this.createInitialStats();
    this.llog.debug('Watcher statistics cleared');
  }

  /**
   * Get current state
   */
  public getState(): ClipboardState {
    return this.state;
  }

  /**
   * Check if watcher is active
   */
  public isActive(): boolean {
    return this.state === ClipboardState.ACTIVE;
  }

  /**
   * Get current configuration
   */
  public getConfig(): WatcherConfig {
    return { ...this.config };
  }

  /**
   * Force capture current clipboard content
   */
  public async captureNow(): Promise<string | null> {
    try {
      const currentText = this.getCurrentClipboardText();
      if (!currentText.trim()) {
        return null;
      }

      const timestamp = Date.now();
      const change: ClipboardChange = {
        content: currentText,
        format: ClipboardFormat.TEXT,
        timestamp,
        sourceApp: await this.getSourceApplication(),
      };

      await this.processClipboardChange(change);
      return currentText;

    } catch (error) {
      this.llog.error('Failed to capture clipboard content', error as Error);
      return null;
    }
  }

  /**
   * Cleanup resources
   */
  public async cleanup(): Promise<void> {
    this.llog.info('Cleaning up clipboard watcher');
    
    this.stopWatching();
    this.eventListeners = [];
    this.processingQueue.clear();
    
    if (this.changeDebounceTimer) {
      clearTimeout(this.changeDebounceTimer);
      this.changeDebounceTimer = null;
    }
    
    this.isInitialized = false;
    this.llog.info('Clipboard watcher cleanup completed');
  }

  /**
   * Check if watcher is initialized
   */
  public isInitializedState(): boolean {
    return this.isInitialized;
  }
}




