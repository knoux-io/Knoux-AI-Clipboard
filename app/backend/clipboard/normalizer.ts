/**
 * Knoux Clipboard AI - Clipboard Content Normalizer
 * Cleans, normalizes, and standardizes clipboard content
 * Generated by Knoux — Abu Retaj
 * Clipboard Intelligence • Desktop Precision • Premium Engineering
 */

import { llog } from '../../shared/localized-logger';
import { CLIPBOARD, CONTENT_TYPES } from '../../shared/constants';
import { ClipboardFormat } from '../../shared/enums';

/**
 * Normalization options
 */
export interface NormalizationOptions {
  trimWhitespace: boolean;
  normalizeLineEndings: boolean;
  removeEmptyLines: boolean;
  deduplicateLines: boolean;
  removeExtraSpaces: boolean;
  normalizeIndentation: boolean;
  maxLength?: number;
  preserveFormatting: boolean;
  language?: string;
}

/**
 * Normalization result
 */
export interface NormalizationResult {
  original: string;
  normalized: string;
  changes: NormalizationChange[];
  statistics: NormalizationStats;
  metadata: NormalizationMetadata;
}

/**
 * Normalization change
 */
export interface NormalizationChange {
  type: 'trim' | 'line-ending' | 'empty-line' | 'duplicate' | 'space' | 'indent' | 'truncate';
  description: string;
  count: number;
}

/**
 * Normalization statistics
 */
export interface NormalizationStats {
  originalLength: number;
  normalizedLength: number;
  lineCount: number;
  wordCount: number;
  whitespaceReduction: number;
  processingTimeMs: number;
}

/**
 * Normalization metadata
 */
export interface NormalizationMetadata {
  encoding: string;
  lineEndings: 'lf' | 'crlf' | 'mixed' | 'unknown';
  indentation: 'spaces' | 'tabs' | 'mixed' | 'none';
  hasBom: boolean;
  languageDetected?: string;
}

export class ClipboardNormalizer {
  private logger = createLogger({ module: 'clipboard-normalizer' });
  private isInitialized = false;

  constructor() {
    // No dependencies needed
  }

  /**
   * Initialize normalizer
   */
  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    this.llog.info('Initializing clipboard normalizer');
    this.isInitialized = true;
    this.llog.info('Clipboard normalizer initialized successfully');
  }

  /**
   * Normalize clipboard content
   */
  public async normalize(
    content: string,
    format: ClipboardFormat = ClipboardFormat.TEXT,
    options: Partial<NormalizationOptions> = {}
  ): Promise<string> {
    const startTime = Date.now();
    
    if (!this.isInitialized) {
      await this.initialize();
    }

    // Validate input
    if (typeof content !== 'string') {
      throw new Error(Invalid content type: );
    }

    // Apply format-specific normalization first
    let normalized = this.applyFormatSpecificNormalization(content, format);

    // Merge options with defaults
    const fullOptions: NormalizationOptions = {
      trimWhitespace: true,
      normalizeLineEndings: true,
      removeEmptyLines: false,
      deduplicateLines: false,
      removeExtraSpaces: true,
      normalizeIndentation: true,
      preserveFormatting: false,
      ...options,
    };

    this.llog.debug('Normalizing content', {
      originalLength: content.length,
      format,
      options: fullOptions,
    });

    // Track changes
    const changes: NormalizationChange[] = [];

    // Apply normalization steps in order
    if (fullOptions.trimWhitespace) {
      normalized = this.applyTrim(normalized, changes);
    }

    if (fullOptions.normalizeLineEndings) {
      normalized = this.normalizeLineEndings(normalized, changes);
    }

    if (fullOptions.removeEmptyLines) {
      normalized = this.removeEmptyLines(normalized, changes);
    }

    if (fullOptions.deduplicateLines) {
      normalized = this.deduplicateLines(normalized, changes);
    }

    if (fullOptions.removeExtraSpaces) {
      normalized = this.removeExtraSpaces(normalized, changes);
    }

    if (fullOptions.normalizeIndentation && !fullOptions.preserveFormatting) {
      normalized = this.normalizeIndentation(normalized, changes);
    }

    // Apply length constraint if specified
    if (fullOptions.maxLength && normalized.length > fullOptions.maxLength) {
      normalized = this.truncateContent(normalized, fullOptions.maxLength, changes);
    }

    // Calculate statistics
    const processingTimeMs = Date.now() - startTime;
    const statistics = this.calculateStatistics(content, normalized, processingTimeMs);
    
    // Extract metadata
    const metadata = this.extractMetadata(normalized, format);

    this.llog.info('Content normalized successfully', {
      originalLength: content.length,
      normalizedLength: normalized.length,
      reduction: ((content.length - normalized.length) / content.length * 100).toFixed(1) + '%',
      processingTimeMs,
      changeCount: changes.length,
    });

    return normalized;
  }

  /**
   * Apply format-specific normalization
   */
  private applyFormatSpecificNormalization(content: string, format: ClipboardFormat): string {
    switch (format) {
      case ClipboardFormat.HTML:
        return this.normalizeHtml(content);
      
      case ClipboardFormat.RTF:
        return this.normalizeRtf(content);
      
      case ClipboardFormat.IMAGE:
        return this.normalizeImage(content);
      
      case ClipboardFormat.TEXT:
      default:
        return content;
    }
  }

  /**
   * Normalize HTML content
   */
  private normalizeHtml(html: string): string {
    try {
      // Basic HTML cleaning
      let cleaned = html;
      
      // Remove excessive whitespace
      cleaned = cleaned.replace(/\s+/g, ' ');
      
      // Remove script and style tags (for safety)
      cleaned = cleaned.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
      cleaned = cleaned.replace(/<style\b[^<]*(?:(?!<\/style>)<[^<]*)*<\/style>/gi, '');
      
      // Extract text content if it's mostly HTML
      if (this.isMostlyHtml(cleaned)) {
        // Simple HTML to text extraction
        cleaned = cleaned
          .replace(/<[^>]+>/g, ' ') // Replace tags with space
          .replace(/\s+/g, ' ')      // Collapse whitespace
          .trim();
      }
      
      return cleaned;
    } catch (error) {
      this.llog.warn('HTML normalization failed, returning as plain text', error as Error);
      return html;
    }
  }

  /**
   * Check if content is mostly HTML
   */
  private isMostlyHtml(content: string): boolean {
    const htmlTags = content.match(/<[^>]+>/g) || [];
    const textContent = content.replace(/<[^>]+>/g, '');
    
    // If we have more HTML tags than text ratio suggests HTML content
    return htmlTags.length > 3 && textContent.length < content.length * 0.7;
  }

  /**
   * Normalize RTF content
   */
  private normalizeRtf(rtf: string): string {
    try {
      // Simple RTF to text extraction
      // Remove RTF control words and groups
      let text = rtf
        .replace(/\\[a-z]+\d*\s?/gi, ' ') // Remove control words
        .replace(/\{[^{}]*\}/g, ' ')      // Remove groups
        .replace(/\s+/g, ' ')             // Collapse whitespace
        .trim();
      
      // If extraction failed or resulted in very short text, return marker
      if (text.length < 10 && rtf.length > 50) {
        return '[RTF Content - Use formatted view]';
      }
      
      return text;
    } catch (error) {
      this.llog.warn('RTF normalization failed', error as Error);
      return '[RTF Content]';
    }
  }

  /**
   * Normalize image content
   */
  private normalizeImage(imageRef: string): string {
    // For images, we return a descriptive string
    return '[Image Content]';
  }

  /**
   * Apply trimming
   */
  private applyTrim(content: string, changes: NormalizationChange[]): string {
    const original = content;
    const trimmed = content.trim();
    
    if (original !== trimmed) {
      changes.push({
        type: 'trim',
        description: 'Removed leading/trailing whitespace',
        count: 1,
      });
    }
    
    return trimmed;
  }

  /**
   * Normalize line endings
   */
  private normalizeLineEndings(content: string, changes: NormalizationChange[]): string {
    const before = content;
    
    // Convert all line endings to LF (Unix style)
    const normalized = content
      .replace(/\r\n/g, '\n')  // Windows CRLF to LF
      .replace(/\r/g, '\n');   // Mac CR to LF
    
    if (before !== normalized) {
      const lineEndingMatches = (before.match(/\r\n|\r/g) || []).length;
      if (lineEndingMatches > 0) {
        changes.push({
          type: 'line-ending',
          description: 'Normalized line endings to LF',
          count: lineEndingMatches,
        });
      }
    }
    
    return normalized;
  }

  /**
   * Remove empty lines
   */
  private removeEmptyLines(content: string, changes: NormalizationChange[]): string {
    const lines = content.split('\n');
    const nonEmptyLines = lines.filter(line => line.trim().length > 0);
    
    const emptyLineCount = lines.length - nonEmptyLines.length;
    if (emptyLineCount > 0) {
      changes.push({
        type: 'empty-line',
        description: 'Removed empty lines',
        count: emptyLineCount,
      });
    }
    
    return nonEmptyLines.join('\n');
  }

  /**
   * Deduplicate lines
   */
  private deduplicateLines(content: string, changes: NormalizationChange[]): string {
    const lines = content.split('\n');
    const uniqueLines: string[] = [];
    const seenLines = new Set<string>();
    let duplicateCount = 0;
    
    for (const line of lines) {
      const trimmedLine = line.trim();
      if (!seenLines.has(trimmedLine)) {
        uniqueLines.push(line);
        seenLines.add(trimmedLine);
      } else {
        duplicateCount++;
      }
    }
    
    if (duplicateCount > 0) {
      changes.push({
        type: 'duplicate',
        description: 'Removed duplicate lines',
        count: duplicateCount,
      });
    }
    
    return uniqueLines.join('\n');
  }

  /**
   * Remove extra spaces
   */
  private removeExtraSpaces(content: string, changes: NormalizationChange[]): string {
    const before = content;
    
    // Remove multiple spaces (but preserve newlines)
    const lines = content.split('\n');
    const processedLines = lines.map(line => {
      // Replace multiple spaces with single space
      return line.replace(/\s+/g, ' ').trim();
    });
    
    const after = processedLines.join('\n');
    
    if (before !== after) {
      // Count how many extra spaces were removed
      const beforeSpaces = (before.match(/\s+/g) || []).length;
      const afterSpaces = (after.match(/\s+/g) || []).length;
      const spacesRemoved = beforeSpaces - afterSpaces;
      
      if (spacesRemoved > 0) {
        changes.push({
          type: 'space',
          description: 'Removed extra spaces',
          count: spacesRemoved,
        });
      }
    }
    
    return after;
  }

  /**
   * Normalize indentation
   */
  private normalizeIndentation(content: string, changes: NormalizationChange[]): string {
    // Detect indentation style
    const lines = content.split('\n');
    let tabCount = 0;
    let spaceCount = 0;
    
    for (const line of lines) {
      const match = line.match(/^(\s+)/);
      if (match) {
        const indent = match[1];
        if (indent.includes('\t')) {
          tabCount++;
        } else if (indent.includes(' ')) {
          spaceCount++;
        }
      }
    }
    
    // Decide which style to use (default to spaces)
    const useSpaces = spaceCount >= tabCount;
    const indentSize = 2; // Default to 2 spaces
    
    if (tabCount === 0 && spaceCount === 0) {
      // No indentation found
      return content;
    }
    
    // Convert indentation
    const normalizedLines = lines.map(line => {
      const match = line.match(/^(\s+)/);
      if (!match) {
        return line;
      }
      
      const originalIndent = match[1];
      let indentLevel = 0;
      
      if (originalIndent.includes('\t')) {
        // Count tabs
        indentLevel = (originalIndent.match(/\t/g) || []).length;
      } else {
        // Count spaces (assuming 2 or 4 space indentation)
        const spaceGroups = originalIndent.match(/\s{2,4}/g) || [];
        indentLevel = spaceGroups.length;
      }
      
      // Create new indentation
      const newIndent = useSpaces 
        ? ' '.repeat(indentLevel * indentSize)
        : '\t'.repeat(indentLevel);
      
      return newIndent + line.substring(originalIndent.length);
    });
    
    const after = normalizedLines.join('\n');
    
    if (content !== after) {
      changes.push({
        type: 'indent',
        description: Normalized indentation to  spaces : 'tabs'},
        count: Math.max(tabCount, spaceCount),
      });
    }
    
    return after;
  }

  /**
   * Truncate content to maximum length
   */
  private truncateContent(content: string, maxLength: number, changes: NormalizationChange[]): string {
    if (content.length <= maxLength) {
      return content;
    }
    
    // Try to truncate at sentence boundary
    let truncated = content.substring(0, maxLength);
    
    // Find last sentence end
    const lastPeriod = truncated.lastIndexOf('.');
    const lastExclamation = truncated.lastIndexOf('!');
    const lastQuestion = truncated.lastIndexOf('?');
    const lastNewline = truncated.lastIndexOf('\n');
    
    const cutoff = Math.max(lastPeriod, lastExclamation, lastQuestion, lastNewline);
    
    if (cutoff > maxLength * 0.5) { // Only if we found a reasonable cutoff
      truncated = truncated.substring(0, cutoff + 1);
    }
    
    // Add ellipsis if we truncated
    if (truncated.length < content.length) {
      truncated += '...';
    }
    
    const charsRemoved = content.length - truncated.length;
    if (charsRemoved > 0) {
      changes.push({
        type: 'truncate',
        description: Truncated to  characters,
        count: charsRemoved,
      });
    }
    
    return truncated;
  }

  /**
   * Calculate normalization statistics
   */
  private calculateStatistics(
    original: string,
    normalized: string,
    processingTimeMs: number
  ): NormalizationStats {
    const lines = normalized.split('\n');
    const words = normalized.split(/\s+/).filter(word => word.length > 0);
    
    const whitespaceReduction = original.length > 0 
      ? ((original.length - normalized.length) / original.length) * 100 
      : 0;
    
    return {
      originalLength: original.length,
      normalizedLength: normalized.length,
      lineCount: lines.length,
      wordCount: words.length,
      whitespaceReduction,
      processingTimeMs,
    };
  }

  /**
   * Extract metadata from content
   */
  private extractMetadata(content: string, format: ClipboardFormat): NormalizationMetadata {
    // Detect line endings
    let lineEndings: 'lf' | 'crlf' | 'mixed' | 'unknown' = 'unknown';
    const hasCRLF = content.includes('\r\n');
    const hasLF = content.includes('\n') && !content.includes('\r\n');
    const hasCR = content.includes('\r') && !content.includes('\r\n');
    
    if (hasCRLF && !hasLF && !hasCR) {
      lineEndings = 'crlf';
    } else if (hasLF && !hasCRLF && !hasCR) {
      lineEndings = 'lf';
    } else if (hasCRLF || hasLF || hasCR) {
      lineEndings = 'mixed';
    }
    
    // Detect indentation
    const lines = content.split('\n');
    let spaces = 0;
    let tabs = 0;
    
    for (const line of lines) {
      const match = line.match(/^(\s+)/);
      if (match) {
        const indent = match[1];
        if (indent.includes(' ') && !indent.includes('\t')) {
          spaces++;
        } else if (indent.includes('\t') && !indent.includes(' ')) {
          tabs++;
        }
      }
    }
    
    let indentation: 'spaces' | 'tabs' | 'mixed' | 'none' = 'none';
    if (spaces > 0 && tabs === 0) {
      indentation = 'spaces';
    } else if (tabs > 0 && spaces === 0) {
      indentation = 'tabs';
    } else if (spaces > 0 && tabs > 0) {
      indentation = 'mixed';
    }
    
    // Check for BOM (Byte Order Mark)
    const hasBom = content.charCodeAt(0) === 0xFEFF;
    
    // Detect language (simple)
    let languageDetected: string | undefined;
    if (content.includes('function') || content.includes('const ') || content.includes('var ')) {
      languageDetected = 'javascript';
    } else if (content.includes('def ') || content.includes('import ')) {
      languageDetected = 'python';
    } else if (content.includes('{') && content.includes('}')) {
      languageDetected = 'json';
    }
    
    return {
      encoding: 'UTF-8',
      lineEndings,
      indentation,
      hasBom,
      languageDetected,
    };
  }

  /**
   * Detect content type
   */
  public async detectContentType(content: string): Promise<string> {
    if (!content || content.trim().length === 0) {
      return CONTENT_TYPES.TEXT.PLAIN;
    }
    
    // Check for JSON
    try {
      JSON.parse(content);
      return CONTENT_TYPES.CODE.JSON;
    } catch {
      // Not JSON
    }
    
    // Check for URLs
    if (content.match(/^(https?:\/\/|ftp:\/\/|www\.)[^\s/$.?#].[^\s]*$/)) {
      return CONTENT_TYPES.TEXT.URL;
    }
    
    // Check for email
    if (content.match(/^\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b$/)) {
      return CONTENT_TYPES.TEXT.EMAIL;
    }
    
    // Check for code patterns
    if (content.includes('function') || content.includes('const ') || content.includes('var ')) {
      return CONTENT_TYPES.CODE.JAVASCRIPT;
    }
    
    if (content.includes('def ') || content.includes('import ')) {
      return CONTENT_TYPES.CODE.PYTHON;
    }
    
    if (content.includes('Get-') || content.includes('$')) {
      return CONTENT_TYPES.CODE.POWERSHELL;
    }
    
    // Default to plain text
    return CONTENT_TYPES.TEXT.PLAIN;
  }

  /**
   * Clean sensitive data from content
   */
  public cleanSensitiveData(content: string): string {
    let cleaned = content;
    
    // Patterns for sensitive data
    const sensitivePatterns = [
      // API keys (common patterns)
      { pattern: /(?:api[_-]?key|apikey)[\s:=]+['"]?([a-zA-Z0-9_\-]{20,})['"]?/gi, replacement: '[API_KEY_REDACTED]' },
      
      // Passwords
      { pattern: /(?:password|passwd|pwd)[\s:=]+['"]?([^\s'"]+)['"]?/gi, replacement: '[PASSWORD_REDACTED]' },
      
      // JWT tokens
      { pattern: /eyJ[a-zA-Z0-9_-]+\.eyJ[a-zA-Z0-9_-]+\.[a-zA-Z0-9_-]+/g, replacement: '[JWT_TOKEN_REDACTED]' },
      
      // Credit cards (simplified)
      { pattern: /\b(?:\d[ -]*?){13,16}\b/g, replacement: '[CREDIT_CARD_REDACTED]' },
      
      // Private keys (begin markers)
      { pattern: /-----BEGIN (?:RSA|DSA|EC|OPENSSH) PRIVATE KEY-----[\s\S]*?-----END (?:RSA|DSA|EC|OPENSSH) PRIVATE KEY-----/g, replacement: '[PRIVATE_KEY_REDACTED]' },
    ];
    
    let redactionCount = 0;
    
    for (const { pattern, replacement } of sensitivePatterns) {
      const matches = cleaned.match(pattern);
      if (matches) {
        redactionCount += matches.length;
        cleaned = cleaned.replace(pattern, replacement);
      }
    }
    
    if (redactionCount > 0) {
      this.llog.info('Sensitive data cleaned from content', { redactionCount });
    }
    
    return cleaned;
  }

  /**
   * Extract structured data from content
   */
  public extractStructuredData(content: string): {
    urls: string[];
    emails: string[];
    phoneNumbers: string[];
    ipAddresses: string[];
  } {
    const urls = (content.match(/(?:https?:\/\/|ftp:\/\/|www\.)[^\s/$.?#].[^\s]*/g) || [])
      .map(url => url.trim());
    
    const emails = (content.match(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g) || [])
      .map(email => email.trim());
    
    const phoneNumbers = (content.match(/\b(?:\+\d{1,3}[-.]?)?\(?\d{3}\)?[-.]?\d{3}[-.]?\d{4}\b/g) || [])
      .map(phone => phone.trim());
    
    const ipAddresses = (content.match(/\b(?:\d{1,3}\.){3}\d{1,3}\b/g) || [])
      .map(ip => ip.trim());
    
    return { urls, emails, phoneNumbers, ipAddresses };
  }

  /**
   * Validate content format
   */
  public validateFormat(content: string, expectedFormat: string): boolean {
    switch (expectedFormat) {
      case CONTENT_TYPES.CODE.JSON:
        try {
          JSON.parse(content);
          return true;
        } catch {
          return false;
        }
      
      case CONTENT_TYPES.CODE.XML:
        return /<[a-zA-Z][^>]*>.*<\/[a-zA-Z][^>]*>/.test(content);
      
      case CONTENT_TYPES.CODE.YAML:
        return content.includes(':') || content.includes('- ');
      
      default:
        return true; // Other formats are always valid
    }
  }

  /**
   * Get normalization recommendations
   */
  public getRecommendations(content: string): string[] {
    const recommendations: string[] = [];
    
    // Check for mixed line endings
    const hasCRLF = content.includes('\r\n');
    const hasLF = content.includes('\n') && !content.includes('\r\n');
    const hasCR = content.includes('\r') && !content.includes('\r\n');
    
    if ((hasCRLF && hasLF) || (hasCRLF && hasCR) || (hasLF && hasCR)) {
      recommendations.push('Content has mixed line endings. Consider normalizing to LF.');
    }
    
    // Check for trailing whitespace
    const lines = content.split('\n');
    const trailingWhitespaceLines = lines.filter(line => line.match(/\s+$/)).length;
    if (trailingWhitespaceLines > 0) {
      recommendations.push( lines have trailing whitespace.);
    }
    
    // Check for inconsistent indentation
    const spaceIndentLines = lines.filter(line => line.match(/^ +[^ ]/)).length;
    const tabIndentLines = lines.filter(line => line.match(/^\t[^\t]/)).length;
    
    if (spaceIndentLines > 0 && tabIndentLines > 0) {
      recommendations.push('Content uses mixed indentation (spaces and tabs).');
    }
    
    // Check for very long lines
    const longLines = lines.filter(line => line.length > 200).length;
    if (longLines > 0) {
      recommendations.push( lines exceed 200 characters. Consider breaking them up.);
    }
    
    return recommendations;
  }

  /**
   * Create a normalization report
   */
  public async createReport(
    original: string,
    normalized: string,
    options: NormalizationOptions
  ): Promise<NormalizationResult> {
    const changes: NormalizationChange[] = [];
    const processingTimeMs = 0; // Would be actual time in real implementation
    
    // Re-apply normalization to track changes
    await this.normalize(original, ClipboardFormat.TEXT, options);
    
    const statistics = this.calculateStatistics(original, normalized, processingTimeMs);
    const metadata = this.extractMetadata(normalized, ClipboardFormat.TEXT);
    
    return {
      original,
      normalized,
      changes,
      statistics,
      metadata,
    };
  }

  /**
   * Check if normalizer is ready
   */
  public isReady(): boolean {
    return this.isInitialized;
  }

  /**
   * Reset normalizer state
   */
  public reset(): void {
    this.llog.debug('Normalizer reset');
    // No state to reset in this implementation
  }
}




