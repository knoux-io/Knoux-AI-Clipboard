// Enhanced Clipboard IPC with Real Database Integration
// Generated by Knoux-Integrator AI ‚Äî 2026-01-26

const { ipcMain } = require('electron');
const { realClipboardWatcher } = require('../clipboard/real-watcher');

// Mock clipboard service (fallback when database unavailable)
const mockClipboardService = {
  items: [
    { id: 1, content: 'Welcome to Knoux Clipboard AI! üöÄ', type: 'text', timestamp: Date.now() - 1000, isFavorite: false },
    { id: 2, content: 'https://github.com/knoux/clipboard-ai', type: 'url', timestamp: Date.now() - 2000, isFavorite: true },
    { id: 3, content: 'console.log("Hello World!");', type: 'code', timestamp: Date.now() - 3000, isFavorite: false }
  ],
  
  async getRecentItems(limit = 50) {
    return this.items.slice(0, limit);
  },
  
  async pushItem(item) {
    const newItem = {
      id: Date.now(),
      content: item.content || '',
      type: item.type || 'text',
      timestamp: item.timestamp || Date.now(),
      isFavorite: false,
      source: 'user'
    };
    
    this.items.unshift(newItem);
    if (this.items.length > 100) {
      this.items = this.items.slice(0, 100);
    }
    
    return { success: true, id: newItem.id };
  },
  
  async getHistory() {
    return this.getRecentItems();
  },
  
  async normalize(content) {
    return { 
      normalized: content.trim(), 
      changes: ['trimmed'],
      type: this.detectType(content),
      wordCount: content.split(/\s+/).length
    };
  },
  
  async format(content, format) {
    let formatted = content;
    
    switch (format) {
      case 'uppercase':
        formatted = content.toUpperCase();
        break;
      case 'lowercase':
        formatted = content.toLowerCase();
        break;
      case 'title':
        formatted = content.replace(/\w\S*/g, (txt) => 
          txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()
        );
        break;
      case 'trim':
        formatted = content.trim();
        break;
      default:
        formatted = content;
    }
    
    return { formatted, format, original: content };
  },
  
  detectType(content) {
    if (!content) return 'unknown';
    if (/^https?:\/\/.+/.test(content.trim())) return 'url';
    if (/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(content.trim())) return 'email';
    if (/^\d+(\.\d+)?$/.test(content.trim())) return 'number';
    if (/^(function|class|const|let|var)\s/.test(content)) return 'code';
    return 'text';
  }
};

function registerClipboardIPC() {
  console.log('üìã Registering Enhanced Clipboard IPC handlers...');
  
  // Start real clipboard monitoring
  try {
    realClipboardWatcher.start();
    console.log('‚úÖ Real clipboard monitoring started');
  } catch (error) {
    console.warn('‚ö†Ô∏è Real clipboard monitoring failed, using fallback:', error);
  }

  // Read clipboard items (prioritize real watcher)
  ipcMain.handle('knoux.clipboard.read', async () => {
    try {
      // Try real clipboard watcher first
      const realItems = await realClipboardWatcher.getRecentItems(50);
      if (realItems && realItems.length > 0) {
        return { ok: true, data: realItems, source: 'database' };
      }
      
      // Fallback to mock service
      const mockItems = await mockClipboardService.getRecentItems();
      return { ok: true, data: mockItems, source: 'mock' };
    } catch (error) {
      console.error('‚ùå Clipboard read error:', error);
      return { ok: false, error: error.message };
    }
  });

  // Write to clipboard
  ipcMain.handle('knoux.clipboard.write', async (evt, item) => {
    try {
      // Try real clipboard watcher first
      if (realClipboardWatcher) {
        await realClipboardWatcher.handleNewContent(item.content);
        return { ok: true, source: 'real' };
      }
      
      // Fallback to mock service
      const result = await mockClipboardService.pushItem(item);
      return { ok: true, ...result, source: 'mock' };
    } catch (error) {
      console.error('‚ùå Clipboard write error:', error);
      return { ok: false, error: error.message };
    }
  });

  // Get clipboard history
  ipcMain.handle('knoux.clipboard.history', async () => {
    try {
      const realItems = await realClipboardWatcher.getRecentItems(100);
      if (realItems && realItems.length > 0) {
        return { ok: true, data: realItems, source: 'database' };
      }
      
      const mockItems = await mockClipboardService.getHistory();
      return { ok: true, data: mockItems, source: 'mock' };
    } catch (error) {
      console.error('‚ùå Clipboard history error:', error);
      return { ok: false, error: error.message };
    }
  });

  // Search clipboard items
  ipcMain.handle('knoux.clipboard.search', async (evt, query) => {
    try {
      const realResults = await realClipboardWatcher.searchItems(query, 50);
      if (realResults && realResults.length > 0) {
        return { ok: true, data: realResults, source: 'database' };
      }
      
      // Fallback search in mock data
      const mockResults = mockClipboardService.items.filter(item => 
        item.content.toLowerCase().includes(query.toLowerCase())
      );
      return { ok: true, data: mockResults, source: 'mock' };
    } catch (error) {
      console.error('‚ùå Clipboard search error:', error);
      return { ok: false, error: error.message };
    }
  });

  // Normalize clipboard content
  ipcMain.handle('knoux.clipboard.normalize', async (evt, content) => {
    try {
      const result = await mockClipboardService.normalize(content);
      return { ok: true, data: result };
    } catch (error) {
      console.error('‚ùå Clipboard normalize error:', error);
      return { ok: false, error: error.message };
    }
  });

  // Format clipboard content
  ipcMain.handle('knoux.clipboard.format', async (evt, { content, format }) => {
    try {
      const result = await mockClipboardService.format(content, format);
      return { ok: true, data: result };
    } catch (error) {
      console.error('‚ùå Clipboard format error:', error);
      return { ok: false, error: error.message };
    }
  });

  console.log('‚úÖ Enhanced Clipboard IPC handlers registered');
}

// Cleanup function
function cleanupClipboardIPC() {
  try {
    realClipboardWatcher.stop();
    console.log('‚úÖ Clipboard IPC cleanup completed');
  } catch (error) {
    console.error('‚ùå Clipboard IPC cleanup error:', error);
  }
}

module.exports = { registerClipboardIPC, cleanupClipboardIPC };
