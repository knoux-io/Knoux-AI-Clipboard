// Enhanced Storage IPC with Database Integration
// Generated by Knoux-Integrator AI ‚Äî 2026-01-26

const { ipcMain } = require('electron');
const path = require('path');
const fs = require('fs');

// Try to import database service
let databaseService = null;
try {
  const dbModule = require('../services/databaseService');
  databaseService = dbModule.databaseService;
} catch (error) {
  console.warn('‚ö†Ô∏è Database service not available for storage IPC:', error.message);
}

// Enhanced storage service with multiple backends
class EnhancedStorageService {
  constructor() {
    this.memoryStorage = new Map();
    this.fileStoragePath = path.join(process.cwd(), 'data', 'storage.json');
    this.isInitialized = false;
  }

  async initialize() {
    if (this.isInitialized) return;
    
    try {
      // Ensure storage directory exists
      const dir = path.dirname(this.fileStoragePath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
      
      // Load existing file storage
      if (fs.existsSync(this.fileStoragePath)) {
        const data = JSON.parse(fs.readFileSync(this.fileStoragePath, 'utf8'));
        Object.entries(data).forEach(([key, value]) => {
          this.memoryStorage.set(key, value);
        });
        console.log('‚úÖ File storage loaded');
      }
      
      this.isInitialized = true;
    } catch (error) {
      console.error('‚ùå Storage initialization failed:', error);
    }
  }

  async get(key) {
    await this.initialize();
    
    try {
      // Try database first
      if (databaseService && typeof databaseService.getSetting === 'function') {
        const dbValue = await databaseService.getSetting(key);
        if (dbValue !== null) {
          try {
            return JSON.parse(dbValue);
          } catch {
            return dbValue;
          }
        }
      }
      
      // Fallback to memory storage
      return this.memoryStorage.get(key) || null;
    } catch (error) {
      console.error('‚ùå Storage get error:', error);
      return this.memoryStorage.get(key) || null;
    }
  }

  async set(key, value) {
    await this.initialize();
    
    try {
      // Store in database if available
      if (databaseService && typeof databaseService.setSetting === 'function') {
        const serialized = typeof value === 'string' ? value : JSON.stringify(value);
        await databaseService.setSetting(key, serialized);
      }
      
      // Always store in memory
      this.memoryStorage.set(key, value);
      
      // Persist to file
      await this.persistToFile();
      
      return { success: true, timestamp: Date.now() };
    } catch (error) {
      console.error('‚ùå Storage set error:', error);
      // Still store in memory as fallback
      this.memoryStorage.set(key, value);
      return { success: false, error: error.message };
    }
  }

  async delete(key) {
    await this.initialize();
    
    try {
      // Delete from database if available
      if (databaseService && typeof databaseService.setSetting === 'function') {
        await databaseService.setSetting(key, null);
      }
      
      // Delete from memory
      const existed = this.memoryStorage.has(key);
      this.memoryStorage.delete(key);
      
      // Persist to file
      await this.persistToFile();
      
      return { success: true, existed };
    } catch (error) {
      console.error('‚ùå Storage delete error:', error);
      return { success: false, error: error.message };
    }
  }

  async clear() {
    await this.initialize();
    
    try {
      // Clear memory
      this.memoryStorage.clear();
      
      // Clear file
      if (fs.existsSync(this.fileStoragePath)) {
        fs.unlinkSync(this.fileStoragePath);
      }
      
      return { success: true, timestamp: Date.now() };
    } catch (error) {
      console.error('‚ùå Storage clear error:', error);
      return { success: false, error: error.message };
    }
  }

  async export() {
    await this.initialize();
    
    try {
      const data = Object.fromEntries(this.memoryStorage);
      const exportData = {
        data,
        timestamp: Date.now(),
        version: '1.0.0',
        source: 'knoux-clipboard-ai',
        itemCount: Object.keys(data).length
      };
      
      return exportData;
    } catch (error) {
      console.error('‚ùå Storage export error:', error);
      return { error: error.message };
    }
  }

  async import(importData) {
    await this.initialize();
    
    try {
      if (!importData || !importData.data) {
        throw new Error('Invalid import data format');
      }
      
      let importCount = 0;
      
      for (const [key, value] of Object.entries(importData.data)) {
        await this.set(key, value);
        importCount++;
      }
      
      return { 
        success: true, 
        importCount, 
        timestamp: Date.now() 
      };
    } catch (error) {
      console.error('‚ùå Storage import error:', error);
      return { success: false, error: error.message };
    }
  }

  async getStats() {
    await this.initialize();
    
    try {
      const stats = {
        itemCount: this.memoryStorage.size,
        totalSize: JSON.stringify(Object.fromEntries(this.memoryStorage)).length,
        hasFileBackup: fs.existsSync(this.fileStoragePath),
        hasDatabaseBackup: databaseService !== null,
        lastModified: Date.now()
      };
      
      return stats;
    } catch (error) {
      console.error('‚ùå Storage stats error:', error);
      return { error: error.message };
    }
  }

  async persistToFile() {
    try {
      const data = Object.fromEntries(this.memoryStorage);
      fs.writeFileSync(this.fileStoragePath, JSON.stringify(data, null, 2));
    } catch (error) {
      console.error('‚ùå File persistence error:', error);
    }
  }
}

// Singleton instance
const enhancedStorageService = new EnhancedStorageService();

function registerStorageIPC() {
  console.log('üíæ Registering Enhanced Storage IPC handlers...');

  // Get value by key
  ipcMain.handle('knoux.storage.get', async (evt, key) => {
    try {
      const value = await enhancedStorageService.get(key);
      return { ok: true, data: value };
    } catch (error) {
      console.error('‚ùå Storage get error:', error);
      return { ok: false, error: error.message };
    }
  });

  // Set value by key
  ipcMain.handle('knoux.storage.set', async (evt, key, value) => {
    try {
      const result = await enhancedStorageService.set(key, value);
      return { ok: result.success, ...result };
    } catch (error) {
      console.error('‚ùå Storage set error:', error);
      return { ok: false, error: error.message };
    }
  });

  // Delete value by key
  ipcMain.handle('knoux.storage.delete', async (evt, key) => {
    try {
      const result = await enhancedStorageService.delete(key);
      return { ok: result.success, ...result };
    } catch (error) {
      console.error('‚ùå Storage delete error:', error);
      return { ok: false, error: error.message };
    }
  });

  // Clear all storage
  ipcMain.handle('knoux.storage.clear', async () => {
    try {
      const result = await enhancedStorageService.clear();
      return { ok: result.success, ...result };
    } catch (error) {
      console.error('‚ùå Storage clear error:', error);
      return { ok: false, error: error.message };
    }
  });

  // Export all data
  ipcMain.handle('knoux.storage.export', async () => {
    try {
      const result = await enhancedStorageService.export();
      return { ok: true, data: result };
    } catch (error) {
      console.error('‚ùå Storage export error:', error);
      return { ok: false, error: error.message };
    }
  });

  // Import data
  ipcMain.handle('knoux.storage.import', async (evt, importData) => {
    try {
      const result = await enhancedStorageService.import(importData);
      return { ok: result.success, ...result };
    } catch (error) {
      console.error('‚ùå Storage import error:', error);
      return { ok: false, error: error.message };
    }
  });

  // Get storage statistics
  ipcMain.handle('knoux.storage.stats', async () => {
    try {
      const stats = await enhancedStorageService.getStats();
      return { ok: true, data: stats };
    } catch (error) {
      console.error('‚ùå Storage stats error:', error);
      return { ok: false, error: error.message };
    }
  });

  // Batch operations
  ipcMain.handle('knoux.storage.batch', async (evt, operations) => {
    try {
      const results = [];
      
      for (const op of operations) {
        let result;
        switch (op.type) {
          case 'get':
            result = await enhancedStorageService.get(op.key);
            break;
          case 'set':
            result = await enhancedStorageService.set(op.key, op.value);
            break;
          case 'delete':
            result = await enhancedStorageService.delete(op.key);
            break;
          default:
            result = { error: `Unknown operation: ${op.type}` };
        }
        results.push({ operation: op, result });
      }
      
      return { ok: true, data: results };
    } catch (error) {
      console.error('‚ùå Storage batch error:', error);
      return { ok: false, error: error.message };
    }
  });

  console.log('‚úÖ Enhanced Storage IPC handlers registered');
}

// Cleanup function
function cleanupStorageIPC() {
  try {
    enhancedStorageService.persistToFile();
    console.log('‚úÖ Storage IPC cleanup completed');
  } catch (error) {
    console.error('‚ùå Storage IPC cleanup error:', error);
  }
}

module.exports = { registerStorageIPC, cleanupStorageIPC, enhancedStorageService };
