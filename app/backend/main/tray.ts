/**
 * Knoux Clipboard AI - System Tray Manager
 * Manages the system tray icon and context menu
 * Generated by Knoux — Abu Retaj
 * Clipboard Intelligence • Desktop Precision • Premium Engineering
 */

import { Tray, Menu, BrowserWindow, nativeImage, app } from 'electron';
import { join } from 'path';
import { llog } from '../../shared/localized-logger';
import { AppConfig } from '../../shared/config-schema';
import { APP_NAME, UI } from '../../shared/constants';
import { AppEventType } from '../../shared/enums';

// ==================== TYPES ====================

/**
 * Tray menu item configuration
 */
export interface TrayMenuItem {
  id: string;
  label: string;
  type?: 'normal' | 'separator' | 'submenu' | 'checkbox' | 'radio';
  enabled?: boolean;
  checked?: boolean;
  submenu?: TrayMenuItem[];
  accelerator?: string;
  click?: () => void;
}

/**
 * Tray manager configuration
 */
export interface TrayManagerConfig {
  showTrayIcon: boolean;
  minimizeToTray: boolean;
  startMinimized: boolean;
  alwaysOnTop: boolean;
}

// ==================== CONSTANTS ====================

/**
 * Tray icon paths for different states
 */
const TRAY_ICONS = {
  NORMAL: 'tray-icon.ico',
  ACTIVE: 'tray-icon-active.ico',
  ERROR: 'tray-icon-error.ico',
  WARNING: 'tray-icon-warning.ico',
} as const;

/**
 * Tray tooltip base text
 */
const TRAY_TOOLTIP = `${APP_NAME}\nYour Clipboard... Finally Thinks.`;

// ==================== TRAY MANAGER CLASS ====================

export class TrayManager {
  private tray: Tray | null = null;
  private window: BrowserWindow;
  private config: TrayManagerConfig;
  private logger = createLogger({ module: 'tray-manager' });
  private iconPath: string;
  private menu: Menu | null = null;
  private isInitialized = false;
  private clipboardCount = 0;
  private unreadNotifications = 0;
  private currentIconState: keyof typeof TRAY_ICONS = 'NORMAL';

  constructor(window: BrowserWindow, config: AppConfig) {
    this.window = window;
    this.config = this.mapConfig(config);
    this.iconPath = join(__dirname, '../../assets', TRAY_ICONS.NORMAL);

    this.initialize();
  }

  // ==================== INITIALIZATION ====================

  /**
   * Map application config to tray manager config
   */
  private mapConfig(config: AppConfig): TrayManagerConfig {
    return {
      showTrayIcon: config.ui.window.showTrayIcon,
      minimizeToTray: config.ui.window.minimizeToTray,
      startMinimized: config.ui.window.startMinimized,
      alwaysOnTop: config.ui.window.alwaysOnTop,
    };
  }

  /**
   * Initialize tray manager
   */
  private initialize(): void {
    if (this.isInitialized) {
      return;
    }

    this.llog.info('Initializing tray manager', {
      config: this.config,
    });

    // Create tray icon if enabled
    if (this.config.showTrayIcon) {
      this.createTrayIcon();
    }

    this.isInitialized = true;
    this.llog.debug('Tray manager initialized');
  }

  // ==================== TRAY ICON MANAGEMENT ====================

  /**
   * Create system tray icon
   */
  private createTrayIcon(): void {
    try {
      // Load tray icon
      const icon = nativeImage.createFromPath(this.iconPath);

      if (icon.isEmpty()) {
        throw new Error('Failed to load tray icon');
      }

      // Create tray instance
      this.tray = new Tray(icon);

      // Set initial tooltip
      this.updateTooltip();

      // Create context menu
      this.createContextMenu();

      // Setup event handlers
      this.setupTrayEvents();

      this.llog.info('Tray icon created successfully');

    } catch (error) {
      this.llog.error('Failed to create tray icon', error as Error, {
        iconPath: this.iconPath,
      });
    }
  }

  /**
   * Update tray icon based on state
   */
  private updateTrayIcon(state: keyof typeof TRAY_ICONS = 'NORMAL'): void {
    if (!this.tray || this.currentIconState === state) {
      return;
    }

    try {
      const newIconPath = join(__dirname, '../../assets', TRAY_ICONS[state]);
      const icon = nativeImage.createFromPath(newIconPath);

      if (!icon.isEmpty()) {
        this.tray.setImage(icon);
        this.currentIconState = state;
        this.llog.debug('Tray icon updated', { state });
      }
    } catch (error) {
      this.llog.error('Failed to update tray icon', error as Error, { state });
    }
  }

  /**
   * Update tray tooltip
   */
  private updateTooltip(): void {
    if (!this.tray) {
      return;
    }

    let tooltip = TRAY_TOOLTIP;

    if (this.clipboardCount > 0) {
      tooltip += `\n\nClipboard Items: ${this.clipboardCount}`;
    }

    if (this.unreadNotifications > 0) {
      tooltip += `\nUnread Notifications: ${this.unreadNotifications}`;
    }

    this.tray.setToolTip(tooltip);
  }

  // ==================== CONTEXT MENU MANAGEMENT ====================

  /**
   * Create context menu for tray icon
   */
  private createContextMenu(): void {
    if (!this.tray) {
      return;
    }

    const menuItems = this.buildMenuItems();
    this.menu = Menu.buildFromTemplate(menuItems);
    this.tray.setContextMenu(this.menu);

    this.llog.debug('Context menu created');
  }

  /**
   * Build menu items for context menu
   */
  private buildMenuItems(): TrayMenuItem[] {
    const isWindowVisible = this.window.isVisible();
    const isWindowMinimized = this.window.isMinimized();

    return [
      {
        id: 'app-name',
        label: APP_NAME,
        enabled: false,
        type: 'normal',
      },
      {
        id: 'separator-1',
        type: 'separator',
      },
      {
        id: 'show-hide',
        label: isWindowVisible ? 'Hide Window' : 'Show Window',
        accelerator: 'Ctrl+Shift+K',
        click: () => this.toggleWindowVisibility(),
      },
      {
        id: 'quick-search',
        label: 'Quick Search',
        accelerator: UI.HOTKEYS.QUICK_SEARCH,
        click: () => this.focusSearch(),
      },
      {
        id: 'separator-2',
        type: 'separator',
      },
      {
        id: 'clipboard-history',
        label: 'Clipboard History',
        click: () => this.showClipboardHistory(),
      },
      {
        id: 'ai-insights',
        label: 'AI Insights',
        click: () => this.showAIInsights(),
      },
      {
        id: 'security-center',
        label: 'Security Center',
        click: () => this.showSecurityCenter(),
      },
      {
        id: 'separator-3',
        type: 'separator',
      },
      {
        id: 'settings',
        label: 'Settings',
        click: () => this.showSettings(),
      },
      {
        id: 'separator-4',
        type: 'separator',
      },
      {
        id: 'always-on-top',
        label: 'Always on Top',
        type: 'checkbox',
        checked: this.config.alwaysOnTop,
        click: () => this.toggleAlwaysOnTop(),
      },
      {
        id: 'minimize-to-tray',
        label: 'Minimize to Tray',
        type: 'checkbox',
        checked: this.config.minimizeToTray,
        click: () => this.toggleMinimizeToTray(),
      },
      {
        id: 'separator-5',
        type: 'separator',
      },
      {
        id: 'check-updates',
        label: 'Check for Updates',
        click: () => this.checkForUpdates(),
      },
      {
        id: 'about',
        label: `About ${APP_NAME}`,
        click: () => this.showAbout(),
      },
      {
        id: 'separator-6',
        type: 'separator',
      },
      {
        id: 'quit',
        label: 'Quit',
        accelerator: 'Ctrl+Q',
        click: () => this.quitApplication(),
      },
    ];
  }

  /**
   * Update context menu
   */
  private updateContextMenu(): void {
    if (!this.tray || !this.menu) {
      return;
    }

    const newMenuItems = this.buildMenuItems();
    this.menu = Menu.buildFromTemplate(newMenuItems);
    this.tray.setContextMenu(this.menu);

    this.llog.debug('Context menu updated');
  }

  // ==================== TRAY EVENT HANDLERS ====================

  /**
   * Setup tray event handlers
   */
  private setupTrayEvents(): void {
    if (!this.tray) {
      return;
    }

    // Single click: toggle window visibility
    this.tray.on('click', (event) => {
      this.llog.debug('Tray icon clicked');
      this.toggleWindowVisibility();
    });

    // Double click: show window and focus
    this.tray.on('double-click', () => {
      this.llog.debug('Tray icon double-clicked');
      this.showAndFocusWindow();
    });

    // Right click handled by context menu

    // Balloon notification events (Windows)
    this.tray.on('balloon-show', () => {
      this.llog.debug('Tray balloon notification shown');
    });

    this.tray.on('balloon-click', () => {
      this.llog.debug('Tray balloon notification clicked');
      this.showAndFocusWindow();
    });

    this.tray.on('balloon-closed', () => {
      this.llog.debug('Tray balloon notification closed');
    });

    this.llog.debug('Tray event handlers setup completed');
  }

  // ==================== MENU ACTION HANDLERS ====================

  /**
   * Toggle window visibility
   */
  private toggleWindowVisibility(): void {
    if (this.window.isVisible()) {
      if (this.config.minimizeToTray) {
        this.window.hide();
        this.llog.debug('Window hidden to tray');
      } else {
        this.window.minimize();
        this.llog.debug('Window minimized');
      }
    } else {
      this.showAndFocusWindow();
    }

    // Update context menu
    setTimeout(() => this.updateContextMenu(), 100);
  }

  /**
   * Show and focus window
   */
  private showAndFocusWindow(): void {
    if (this.window.isMinimized()) {
      this.window.restore();
    }

    this.window.show();
    this.window.focus();

    this.llog.debug('Window shown and focused');

    // Send event to renderer
    this.sendToRenderer(AppEventType.TRAY_ICON_CLICKED, { action: 'show-window' });
  }

  /**
   * Focus search input
   */
  private focusSearch(): void {
    this.showAndFocusWindow();

    // Send event to renderer to focus search
    this.sendToRenderer('focus-search', {});

    this.llog.debug('Search focus requested');
  }

  /**
   * Show clipboard history view
   */
  private showClipboardHistory(): void {
    this.showAndFocusWindow();
    this.sendToRenderer('navigate-to', { view: 'clipboard-history' });
    this.llog.debug('Clipboard history view requested');
  }

  /**
   * Show AI insights view
   */
  private showAIInsights(): void {
    this.showAndFocusWindow();
    this.sendToRenderer('navigate-to', { view: 'ai-insights' });
    this.llog.debug('AI insights view requested');
  }

  /**
   * Show security center view
   */
  private showSecurityCenter(): void {
    this.showAndFocusWindow();
    this.sendToRenderer('navigate-to', { view: 'security-center' });
    this.llog.debug('Security center view requested');
  }

  /**
   * Show settings view
   */
  private showSettings(): void {
    this.showAndFocusWindow();
    this.sendToRenderer('navigate-to', { view: 'settings' });
    this.llog.debug('Settings view requested');
  }

  /**
   * Toggle always on top
   */
  private toggleAlwaysOnTop(): void {
    const newState = !this.window.isAlwaysOnTop();
    this.window.setAlwaysOnTop(newState);
    this.config.alwaysOnTop = newState;

    this.llog.debug('Always on top toggled', { alwaysOnTop: newState });

    // Update context menu
    this.updateContextMenu();
  }

  /**
   * Toggle minimize to tray
   */
  private toggleMinimizeToTray(): void {
    this.config.minimizeToTray = !this.config.minimizeToTray;

    this.llog.debug('Minimize to tray toggled', {
      minimizeToTray: this.config.minimizeToTray
    });

    // Update context menu
    this.updateContextMenu();
  }

  /**
   * Check for updates
   */
  private checkForUpdates(): void {
    this.llog.debug('Check for updates requested');
    this.sendToRenderer(AppEventType.UPDATE_AVAILABLE, { manualCheck: true });
  }

  /**
   * Show about dialog
   */
  private showAbout(): void {
    this.showAndFocusWindow();
    this.sendToRenderer('navigate-to', { view: 'about' });
    this.llog.debug('About view requested');
  }

  /**
   * Quit application
   */
  private quitApplication(): void {
    this.llog.info('Quit requested from tray menu');

    // Send quit event to main process
    const { ipcMain } = require('electron');
    ipcMain.emit('app-quit-requested');

    app.quit();
  }

  // ==================== PUBLIC METHODS ====================

  /**
   * Update clipboard item count
   */
  public updateClipboardCount(count: number): void {
    this.clipboardCount = count;
    this.updateTooltip();

    // Update icon state based on count
    if (count > 50) {
      this.updateTrayIcon('WARNING');
    } else {
      this.updateTrayIcon('NORMAL');
    }

    this.llog.debug('Clipboard count updated', { count });
  }

  /**
   * Update notification count
   */
  public updateNotificationCount(count: number): void {
    this.unreadNotifications = count;
    this.updateTooltip();

    // Update icon state based on notifications
    if (count > 0) {
      this.updateTrayIcon('ACTIVE');
    } else {
      this.updateTrayIcon('NORMAL');
    }

    this.llog.debug('Notification count updated', { count });
  }

  /**
   * Show tray notification (balloon on Windows)
   */
  public showNotification(title: string, content: string, iconType: 'info' | 'warning' | 'error' = 'info'): void {
    if (!this.tray) {
      return;
    }

    try {
      // Map icon type to tray icon state
      const iconState: keyof typeof TRAY_ICONS =
        iconType === 'error' ? 'ERROR' :
        iconType === 'warning' ? 'WARNING' : 'NORMAL';

      // Temporarily change icon for notification
      const originalState = this.currentIconState;
      this.updateTrayIcon(iconState);

      // Show notification (balloon on Windows, falls back to tooltip on other platforms)
      if (process.platform === 'win32') {
        this.tray.displayBalloon({
          title,
          content,
          iconType: iconType === 'error' ? 'error' : 'info',
        });
      } else {
        // On macOS/Linux, update tooltip with notification
        this.tray.setToolTip(`${title}\n${content}`);

        // Reset tooltip after 5 seconds
        setTimeout(() => {
          this.updateTooltip();
          this.updateTrayIcon(originalState);
        }, 5000);
      }

      this.llog.debug('Tray notification shown', { title, iconType });

      // Restore original icon after notification
      if (process.platform === 'win32') {
        setTimeout(() => {
          this.updateTrayIcon(originalState);
        }, 3000);
      }

    } catch (error) {
      this.llog.error('Failed to show tray notification', error as Error, { title });
    }
  }

  /**
   * Update configuration
   */
  public updateConfig(config: AppConfig): void {
    const newConfig = this.mapConfig(config);
    const configChanged = JSON.stringify(this.config) !== JSON.stringify(newConfig);

    this.config = newConfig;

    if (configChanged) {
      this.llog.info('Tray manager configuration updated', {
        newConfig: this.config,
      });

      // Update tray icon visibility
      if (this.config.showTrayIcon && !this.tray) {
        this.createTrayIcon();
      } else if (!this.config.showTrayIcon && this.tray) {
        this.destroy();
      } else if (this.tray) {
        this.updateContextMenu();
      }
    }
  }

  /**
   * Send data to renderer process
   */
  private sendToRenderer(eventType: string, data?: any): void {
    if (this.window.isDestroyed()) {
      return;
    }

    try {
      this.window.webContents.send('app:event', {
        type: eventType,
        data,
        timestamp: Date.now(),
      });
    } catch (error) {
      this.llog.error('Failed to send event to renderer', error as Error, {
        eventType,
      });
    }
  }

  /**
   * Cleanup resources
   */
  public destroy(): void {
    if (this.tray) {
      this.tray.destroy();
      this.tray = null;
    }

    this.menu = null;
    this.isInitialized = false;

    this.llog.info('Tray manager destroyed');
  }
}

