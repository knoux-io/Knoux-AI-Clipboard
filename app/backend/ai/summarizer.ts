/**
 * Knoux Clipboard AI - Intelligent Content Summarizer
 * Advanced text and code summarization with context preservation
 * Generated by Knoux - Abu Retaj
 * Clipboard Intelligence • Desktop Precision • Premium Engineering
 */

import { llog } from '../../shared/localized-logger';
import { AI, CONTENT_TYPES } from '../../shared/constants';
import { ContentClassification, TextLocation } from '../../shared/types';
import { ProgrammingLanguage, ContentCategory, TextType } from '../../shared/enums';
import { ContentClassifier } from './classifier';
import { AIEngine } from './ai-engine';

/**
 * Summarization options
 */
export interface SummarizationOptions {
  maxLength?: number; // Maximum characters in summary
  targetLength?: number; // Target length (characters)
  compressionRatio?: number; // 0.1 = 10% of original, 0.5 = 50% of original
  preserveKeyPoints?: boolean;
  includeExamples?: boolean;
  includeNumbers?: boolean;
  includeDates?: boolean;
  includeNames?: boolean;
  language?: string;
  format?: 'plain' | 'bullet' | 'numbered' | 'paragraph';
  detailLevel?: 'brief' | 'standard' | 'detailed';
}

/**
 * Summary result
 */
export interface SummaryResult {
  original: string;
  summary: string;
  originalLength: number;
  summaryLength: number;
  compressionRatio: number;
  keyPoints: string[];
  metadata: SummaryMetadata;
  processingTimeMs: number;
  confidence: number;
}

/**
 * Summary metadata
 */
export interface SummaryMetadata {
  sentenceCount: number;
  paragraphCount: number;
  wordCount: number;
  estimatedReadingTime: number; // minutes
  language: string;
  contentType: string;
  topics: string[];
  entities: string[];
  readabilityScore: number;
}

/**
 * Extracted entity
 */
export interface ExtractedEntity {
  type: 'person' | 'organization' | 'location' | 'date' | 'number' | 'url' | 'email';
  value: string;
  count: number;
  locations: TextLocation[];
}

/**
 * Summary cache entry
 */
export interface SummaryCacheEntry {
  summary: string;
  keyPoints: string[];
  metadata: SummaryMetadata;
  timestamp: number;
  optionsHash: string;
}

export class ContentSummarizer {
  private logger = createLogger({ module: 'summarizer' });
  private classifier: ContentClassifier;
  private aiEngine: AIEngine;
  private summaryCache: Map<string, SummaryCacheEntry> = new Map();
  private isInitialized = false;

  constructor(classifier: ContentClassifier, aiEngine: AIEngine) {
    this.classifier = classifier;
    this.aiEngine = aiEngine;
  }

  /**
   * Initialize summarizer
   */
  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    this.llog.info('Initializing content summarizer');

    try {
      // Ensure dependencies are initialized
      if (!this.classifier.isReady()) {
        await this.classifier.initialize();
      }

      if (!this.aiEngine.isReady()) {
        await this.aiEngine.initialize();
      }

      this.isInitialized = true;
      this.llog.info('Content summarizer initialized successfully');
    } catch (error) {
      this.llog.error('Failed to initialize summarizer', error as Error);
      throw error;
    }
  }

  /**
   * Summarize content
   */
  public async summarize(
    content: string,
    options: SummarizationOptions = {}
  ): Promise<SummaryResult> {
    const startTime = Date.now();
    
    if (!this.isInitialized) {
      await this.initialize();
    }

    // Validate input
    if (!content || content.trim().length === 0) {
      throw new Error('Cannot summarize empty content');
    }

    this.llog.debug('Summarizing content', {
      contentLength: content.length,
      options,
    });

    // Check cache first
    const cacheKey = this.generateCacheKey(content, options);
    const cachedResult = this.summaryCache.get(cacheKey);
    
    if (cachedResult && this.isCacheValid(cachedResult.timestamp)) {
      this.llog.debug('Summary cache hit', { cacheKey });
      
      const processingTimeMs = Date.now() - startTime;
      return this.createSummaryResult(
        content,
        cachedResult.summary,
        cachedResult.keyPoints,
        cachedResult.metadata,
        processingTimeMs,
        options
      );
    }

    try {
      // Classify content to determine summarization strategy
      const classification = await this.classifier.classify(content, {
        detailedAnalysis: true,
      });

      // Choose summarization strategy based on content type
      let summary: string;
      let keyPoints: string[] = [];
      let metadata: SummaryMetadata;

      switch (classification.primaryType) {
        case CONTENT_TYPES.CODE.JAVASCRIPT:
        case CONTENT_TYPES.CODE.TYPESCRIPT:
        case CONTENT_TYPES.CODE.PYTHON:
        case CONTENT_TYPES.CODE.POWERSHELL:
        case CONTENT_TYPES.CODE.BASH:
          // Code summarization
          ({ summary, keyPoints, metadata } = await this.summarizeCode(
            content,
            classification,
            options
          ));
          break;

        case CONTENT_TYPES.CODE.JSON:
        case CONTENT_TYPES.CODE.YAML:
        case CONTENT_TYPES.CODE.XML:
          // Data structure summarization
          ({ summary, keyPoints, metadata } = await this.summarizeData(
            content,
            classification,
            options
          ));
          break;

        case CONTENT_TYPES.TEXT.EMAIL:
          // Email summarization
          ({ summary, keyPoints, metadata } = await this.summarizeEmail(
            content,
            classification,
            options
          ));
          break;

        case CONTENT_TYPES.TEXT.PROMPT:
          // Prompt summarization
          ({ summary, keyPoints, metadata } = await this.summarizePrompt(
            content,
            classification,
            options
          ));
          break;

        default:
          // General text summarization
          ({ summary, keyPoints, metadata } = await this.summarizeText(
            content,
            classification,
            options
          ));
      }

      // Ensure summary length constraints
      summary = this.enforceLengthConstraints(summary, content, options);

      // Extract additional key points if needed
      if (options.preserveKeyPoints && keyPoints.length < 3) {
        keyPoints = this.extractKeyPoints(content, summary, classification);
      }

      // Update metadata
      metadata = this.updateMetadata(metadata, content, summary, classification);

      // Cache the result
      const cacheEntry: SummaryCacheEntry = {
        summary,
        keyPoints,
        metadata,
        timestamp: Date.now(),
        optionsHash: this.hashOptions(options),
      };

      this.summaryCache.set(cacheKey, cacheEntry);
      this.cleanupCache();

      const processingTimeMs = Date.now() - startTime;
      const result = this.createSummaryResult(
        content,
        summary,
        keyPoints,
        metadata,
        processingTimeMs,
        options
      );

      this.llog.info('Content summarized successfully', {
        originalLength: content.length,
        summaryLength: summary.length,
        compressionRatio: result.compressionRatio,
        processingTimeMs,
        contentType: classification.primaryType,
      });

      return result;

    } catch (error) {
      this.llog.error('Content summarization failed', error as Error, {
        contentLength: content.length,
      });

      // Return fallback summary
      return this.createFallbackSummary(content, options);
    }
  }

  /**
   * Summarize code content
   */
  private async summarizeCode(
    content: string,
    classification: ContentClassification,
    options: SummarizationOptions
  ): Promise<{
    summary: string;
    keyPoints: string[];
    metadata: SummaryMetadata;
  }> {
    this.llog.debug('Summarizing code content', {
      language: classification.language,
      length: content.length,
    });

    const language = classification.language || ProgrammingLanguage.JAVASCRIPT;
    const lines = content.split('\n');
    const functions: string[] = [];
    const imports: string[] = [];
    const variables: string[] = [];

    // Simple code analysis
    lines.forEach(line => {
      const trimmed = line.trim();
      
      if (trimmed.startsWith('function ') || trimmed.startsWith('def ') || trimmed.match(/^\w+\s*\(.*\)\s*\{?/)) {
        const funcName = this.extractFunctionName(trimmed, language);
        if (funcName) functions.push(funcName);
      }
      
      if (trimmed.startsWith('import ') || trimmed.startsWith('require(') || trimmed.startsWith('from ')) {
        imports.push(trimmed);
      }
      
      if (trimmed.startsWith('const ') || trimmed.startsWith('let ') || trimmed.startsWith('var ') || 
          trimmed.startsWith('$') || trimmed.match(/^\w+\s*=/)) {
        const varName = this.extractVariableName(trimmed);
        if (varName) variables.push(varName);
      }
    });

    // Build summary
    let summary = Code summary ():\n;
    summary += - Lines: \n;
    
    if (functions.length > 0) {
      summary += - Functions: ;
      if (functions.length > 5) summary +=  and  more;
      summary += '\n';
    }
    
    if (imports.length > 0) {
      summary += - Imports:  module\n;
    }
    
    if (variables.length > 0) {
      summary += - Variables: ;
      if (variables.length > 3) summary +=  and  more;
      summary += '\n';
    }

    // Extract key points
    const keyPoints = [
       lines of  code,
      functions.length > 0 ?  function defined : 'No functions defined',
      imports.length > 0 ? Uses  import : 'No imports',
    ];

    // Create metadata
    const metadata = this.createMetadata(content, classification);
    metadata.topics = ['code', language.toLowerCase(), 'programming'];

    return { summary, keyPoints, metadata };
  }

  /**
   * Summarize data structures (JSON, YAML, XML)
   */
  private async summarizeData(
    content: string,
    classification: ContentClassification,
    options: SummarizationOptions
  ): Promise<{
    summary: string;
    keyPoints: string[];
    metadata: SummaryMetadata;
  }> {
    this.llog.debug('Summarizing data content', {
      type: classification.primaryType,
      length: content.length,
    });

    let summary = Data structure summary ():\n;
    let keyPoints: string[] = [];
    let structureInfo = '';

    try {
      switch (classification.primaryType) {
        case CONTENT_TYPES.CODE.JSON:
          const jsonData = JSON.parse(content);
          structureInfo = this.analyzeJsonStructure(jsonData);
          keyPoints = this.extractJsonKeyPoints(jsonData);
          break;

        case CONTENT_TYPES.CODE.YAML:
          structureInfo = this.analyzeYamlStructure(content);
          keyPoints = this.extractYamlKeyPoints(content);
          break;

        case CONTENT_TYPES.CODE.XML:
          structureInfo = this.analyzeXmlStructure(content);
          keyPoints = this.extractXmlKeyPoints(content);
          break;
      }
    } catch (error) {
      this.llog.warn('Failed to parse data structure', error as Error);
      structureInfo = 'Unable to parse data structure';
      keyPoints = ['Data structure parsing failed'];
    }

    summary += structureInfo;

    const metadata = this.createMetadata(content, classification);
    metadata.topics = ['data', classification.primaryType.toLowerCase(), 'structure'];

    return { summary, keyPoints, metadata };
  }

  /**
   * Summarize email content
   */
  private async summarizeEmail(
    content: string,
    classification: ContentClassification,
    options: SummarizationOptions
  ): Promise<{
    summary: string;
    keyPoints: string[];
    metadata: SummaryMetadata;
  }> {
    this.llog.debug('Summarizing email content', { length: content.length });

    // Extract email components
    const fromMatch = content.match(/From:\s*(.+)/i);
    const toMatch = content.match(/To:\s*(.+)/i);
    const subjectMatch = content.match(/Subject:\s*(.+)/i);
    const dateMatch = content.match(/Date:\s*(.+)/i);

    const from = fromMatch ? fromMatch[1].trim() : 'Unknown';
    const to = toMatch ? toMatch[1].trim() : 'Unknown';
    const subject = subjectMatch ? subjectMatch[1].trim() : 'No subject';
    const date = dateMatch ? dateMatch[1].trim() : 'Unknown date';

    // Extract body (remove headers)
    let body = content;
    const headerEnd = content.indexOf('\n\n');
    if (headerEnd !== -1) {
      body = content.substring(headerEnd).trim();
    }

    // Build summary
    let summary = Email summary:\n;
    summary += - From: \n;
    summary += - To: \n;
    summary += - Subject: \n;
    summary += - Date: \n;
    summary += - Body length:  characters\n;

    // Extract key points from body
    const sentences = body.split(/[.!?]+/).filter(s => s.trim().length > 0);
    const keyPoints = sentences.slice(0, 3).map(s => s.trim() + '.');

    // Create metadata
    const metadata = this.createMetadata(content, classification);
    metadata.entities = [from, to];
    metadata.topics = ['email', 'communication'];

    return { summary, keyPoints, metadata };
  }

  /**
   * Summarize prompt content
   */
  private async summarizePrompt(
    content: string,
    classification: ContentClassification,
    options: SummarizationOptions
  ): Promise<{
    summary: string;
    keyPoints: string[];
    metadata: SummaryMetadata;
  }> {
    this.llog.debug('Summarizing prompt content', { length: content.length });

    // Analyze prompt structure
    const hasContext = content.toLowerCase().includes('context') || content.includes('background');
    const hasInstructions = content.toLowerCase().includes('instruction') || content.includes('please');
    const hasExamples = content.includes('example') || content.includes('sample');
    const hasFormatting = content.includes('\n') || content.includes('#') || content.includes('- ');

    // Build summary
    let summary = AI Prompt summary:\n;
    summary += - Length:  characters\n;
    summary += - Context provided: \n;
    summary += - Instructions: \n;
    summary += - Examples: \n;
    summary += - Formatting: \n;

    // Extract key instructions
    const lines = content.split('\n').filter(line => line.trim().length > 0);
    const instructionLines = lines.filter(line => 
      line.toLowerCase().includes('do') || 
      line.toLowerCase().includes('create') ||
      line.toLowerCase().includes('write') ||
      line.toLowerCase().includes('generate') ||
      line.includes(':') ||
      line.includes('- ')
    );

    const keyPoints = instructionLines.slice(0, 5).map(line => line.trim());

    // Create metadata
    const metadata = this.createMetadata(content, classification);
    metadata.topics = ['ai', 'prompt', 'instruction'];

    return { summary, keyPoints, metadata };
  }

  /**
   * Summarize general text content
   */
  private async summarizeText(
    content: string,
    classification: ContentClassification,
    options: SummarizationOptions
  ): Promise<{
    summary: string;
    keyPoints: string[];
    metadata: SummaryMetadata;
  }> {
    this.llog.debug('Summarizing text content', { length: content.length });

    // Use AI engine for better text summarization
    try {
      const aiResult = await this.aiEngine.summarizeContent(content, {
        maxTokens: this.calculateMaxTokens(content, options),
        temperature: 0.3,
      });

      const summary = aiResult.text;
      
      // Extract key points using simple heuristic
      const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
      const keyPoints = this.extractImportantSentences(sentences, 3);
      
      // Create metadata
      const metadata = this.createMetadata(content, classification);
      
      return { summary, keyPoints, metadata };

    } catch (error) {
      this.llog.warn('AI summarization failed, using heuristic', error as Error);
      
      // Fallback to heuristic summarization
      return this.summarizeTextHeuristic(content, classification, options);
    }
  }

  /**
   * Heuristic text summarization (fallback)
   */
  private summarizeTextHeuristic(
    content: string,
    classification: ContentClassification,
    options: SummarizationOptions
  ): {
    summary: string;
    keyPoints: string[];
    metadata: SummaryMetadata;
  } {
    const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
    const paragraphs = content.split(/\n\s*\n/).filter(p => p.trim().length > 0);
    
    if (sentences.length === 0) {
      return {
        summary: 'No content to summarize.',
        keyPoints: [],
        metadata: this.createMetadata(content, classification),
      };
    }

    // Simple summarization: first and last sentences
    const firstSentence = sentences[0].trim() + '.';
    const lastSentence = sentences.length > 1 ? sentences[sentences.length - 1].trim() + '.' : '';
    
    let summary = firstSentence;
    if (lastSentence && lastSentence !== firstSentence) {
      summary += ' ' + lastSentence;
    }

    // Extract key points (important sentences)
    const keyPoints = this.extractImportantSentences(sentences, 3);
    
    // Create metadata
    const metadata = this.createMetadata(content, classification);

    return { summary, keyPoints, metadata };
  }

  /**
   * Extract important sentences
   */
  private extractImportantSentences(sentences: string[], count: number): string[] {
    if (sentences.length <= count) {
      return sentences.map(s => s.trim() + '.');
    }

    // Simple heuristic: first, middle, last sentences
    const importantIndices = [
      0, // First sentence
      Math.floor(sentences.length / 2), // Middle sentence
      sentences.length - 1, // Last sentence
    ];

    return Array.from(new Set(importantIndices))
      .filter(idx => idx < sentences.length)
      .slice(0, count)
      .map(idx => sentences[idx].trim() + '.');
  }

  /**
   * Analyze JSON structure
   */
  private analyzeJsonStructure(data: any): string {
    const analyze = (obj: any, depth = 0): string => {
      if (depth > 2) return '...'; // Limit depth
      
      if (Array.isArray(obj)) {
        return Array[];
      } else if (obj && typeof obj === 'object') {
        const keys = Object.keys(obj);
        if (keys.length === 0) return 'Empty object';
        
        let result = Object with  propert: ;
        result += keys.slice(0, 3).join(', ');
        if (keys.length > 3) result += , ...;
        return result;
      } else {
        return typeof obj;
      }
    };

    return analyze(data);
  }

  /**
   * Extract JSON key points
   */
  private extractJsonKeyPoints(data: any): string[] {
    const keyPoints: string[] = [];
    
    if (Array.isArray(data)) {
      keyPoints.push(Array with  element);
      
      if (data.length > 0) {
        const sampleType = typeof data[0];
        keyPoints.push(Elements are of type: );
      }
    } else if (data && typeof data === 'object') {
      const keys = Object.keys(data);
      keyPoints.push(Object with  propert);
      
      if (keys.length > 0) {
        keyPoints.push(Properties: );
      }
    }
    
    return keyPoints;
  }

  /**
   * Analyze YAML structure
   */
  private analyzeYamlStructure(content: string): string {
    const lines = content.split('\n').filter(line => line.trim().length > 0);
    const topLevelKeys = lines
      .filter(line => line.trim().startsWith('- ') || line.match(/^\w+:/))
      .map(line => line.trim().split(':')[0] || line.trim().substring(2))
      .slice(0, 5);
    
    return YAML document with  lines, top-level: ;
  }

  /**
   * Extract YAML key points
   */
  private extractYamlKeyPoints(content: string): string[] {
    const lines = content.split('\n').filter(line => line.trim().length > 0);
    const keyPoints: string[] = [];
    
    keyPoints.push( lines of YAML);
    
    const hasArrays = content.includes('- ');
    const hasNested = content.includes('  ') || content.includes('\t');
    
    if (hasArrays) keyPoints.push('Contains arrays/lists');
    if (hasNested) keyPoints.push('Contains nested structures');
    
    return keyPoints;
  }

  /**
   * Analyze XML structure
   */
  private analyzeXmlStructure(content: string): string {
    const tags = content.match(/<([a-zA-Z][a-zA-Z0-9]*)[^>]*>/g) || [];
    const uniqueTags = Array.from(new Set(tags.map(tag => {
      const match = tag.match(/<([a-zA-Z][a-zA-Z0-9]*)/);
      return match ? match[1] : 'unknown';
    })));
    
    return XML with  tags, unique tags: ;
  }

  /**
   * Extract XML key points
   */
  private extractXmlKeyPoints(content: string): string[] {
    const tags = content.match(/<([a-zA-Z][a-zA-Z0-9]*)[^>]*>/g) || [];
    const uniqueTags = Array.from(new Set(tags.map(tag => {
      const match = tag.match(/<([a-zA-Z][a-zA-Z0-9]*)/);
      return match ? match[1] : 'unknown';
    })));
    
    return [
       XML tags,
       unique element types,
      uniqueTags.length > 0 ? Elements:  : 'No elements',
    ];
  }

  /**
   * Extract function name from line
   */
  private extractFunctionName(line: string, language: ProgrammingLanguage): string | null {
    const patterns: Record<ProgrammingLanguage, RegExp> = {
      [ProgrammingLanguage.JAVASCRIPT]: /(?:function\s+(\w+)|const\s+(\w+)\s*=\s*\(|let\s+(\w+)\s*=\s*\(|var\s+(\w+)\s*=\s*\()/,
      [ProgrammingLanguage.TYPESCRIPT]: /(?:function\s+(\w+)|const\s+(\w+)\s*:\s*.*=\s*\(|(\w+)\s*\(.*\):\s*.*\{)/,
      [ProgrammingLanguage.PYTHON]: /def\s+(\w+)/,
      [ProgrammingLanguage.POWERSHELL]: /function\s+(\w+)/,
      [ProgrammingLanguage.BASH]: /(\w+)\s*\(\)\s*\{/,
      [ProgrammingLanguage.JAVA]: /(?:public|private|protected)\s+(?:\w+\s+)*(\w+)\s*\(/,
      [ProgrammingLanguage.CSHARP]: /(?:public|private|protected)\s+(?:\w+\s+)*(\w+)\s*\(/,
      [ProgrammingLanguage.CPP]: /(?:\w+\s+)*(\w+)\s*\(/,
      [ProgrammingLanguage.C]: /(?:\w+\s+)*(\w+)\s*\(/,
    };

    const pattern = patterns[language] || patterns[ProgrammingLanguage.JAVASCRIPT];
    const match = line.match(pattern);
    
    if (match) {
      // Find the first non-null capture group
      for (let i = 1; i < match.length; i++) {
        if (match[i]) return match[i];
      }
    }
    
    return null;
  }

  /**
   * Extract variable name from line
   */
  private extractVariableName(line: string): string | null {
    const patterns = [
      /(?:const|let|var)\s+(\w+)/,
      /\$(\w+)/,
      /(\w+)\s*=/,
    ];
    
    for (const pattern of patterns) {
      const match = line.match(pattern);
      if (match && match[1]) {
        return match[1];
      }
    }
    
    return null;
  }

  /**
   * Calculate max tokens for AI summarization
   */
  private calculateMaxTokens(content: string, options: SummarizationOptions): number {
    if (options.targetLength) {
      return options.targetLength;
    }
    
    if (options.compressionRatio) {
      return Math.floor(content.length * options.compressionRatio);
    }
    
    if (options.maxLength) {
      return options.maxLength;
    }
    
    // Default: 20% of original length, max 500 tokens
    return Math.min(500, Math.floor(content.length * 0.2));
  }

  /**
   * Enforce length constraints on summary
   */
  private enforceLengthConstraints(
    summary: string,
    original: string,
    options: SummarizationOptions
  ): string {
    let maxLength = options.maxLength;
    
    if (!maxLength) {
      if (options.targetLength) {
        maxLength = options.targetLength;
      } else if (options.compressionRatio) {
        maxLength = Math.floor(original.length * options.compressionRatio);
      } else {
        // Default: 30% of original, max 1000 characters
        maxLength = Math.min(1000, Math.floor(original.length * 0.3));
      }
    }
    
    if (summary.length <= maxLength) {
      return summary;
    }
    
    // Truncate summary intelligently
    const sentences = summary.split(/[.!?]+/).filter(s => s.trim().length > 0);
    let truncated = '';
    
    for (const sentence of sentences) {
      const withSentence = truncated + (truncated ? ' ' : '') + sentence.trim() + '.';
      if (withSentence.length <= maxLength) {
        truncated = withSentence;
      } else {
        break;
      }
    }
    
    if (truncated.length === 0) {
      // If even one sentence is too long, take first part
      truncated = summary.substring(0, maxLength - 3) + '...';
    }
    
    return truncated;
  }

  /**
   * Extract key points from content
   */
  private extractKeyPoints(
    content: string,
    summary: string,
    classification: ContentClassification
  ): string[] {
    const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
    const keyPoints: string[] = [];
    
    // Add classification info
    keyPoints.push(Content type: );
    
    if (classification.language) {
      keyPoints.push(Language: );
    }
    
    if (classification.isSensitive && classification.sensitiveType) {
      keyPoints.push(Contains sensitive: );
    }
    
    // Add important sentences
    const importantSentences = this.extractImportantSentences(sentences, 2);
    keyPoints.push(...importantSentences);
    
    return keyPoints.slice(0, 5); // Limit to 5 key points
  }

  /**
   * Create metadata for content
   */
  private createMetadata(
    content: string,
    classification: ContentClassification
  ): SummaryMetadata {
    const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
    const paragraphs = content.split(/\n\s*\n/).filter(p => p.trim().length > 0);
    const words = content.split(/\s+/).filter(w => w.length > 0);
    
    const wordCount = words.length;
    const estimatedReadingTime = wordCount / 200; // 200 words per minute
    
    // Calculate simple readability score
    const avgSentenceLength = sentences.length > 0 ? wordCount / sentences.length : 0;
    const avgWordLength = words.reduce((sum, w) => sum + w.length, 0) / (wordCount || 1);
    const readabilityScore = Math.max(0, Math.min(100, 100 - (avgSentenceLength * 0.5 + avgWordLength * 2)));
    
    // Extract entities (simplified)
    const entities = this.extractEntities(content).slice(0, 10);
    
    return {
      sentenceCount: sentences.length,
      paragraphCount: paragraphs.length,
      wordCount,
      estimatedReadingTime,
      language: classification.language || 'unknown',
      contentType: classification.primaryType,
      topics: [],
      entities: entities.map(e => e.value),
      readabilityScore,
    };
  }

  /**
   * Update metadata with summary information
   */
  private updateMetadata(
    metadata: SummaryMetadata,
    original: string,
    summary: string,
    classification: ContentClassification
  ): SummaryMetadata {
    const summaryWords = summary.split(/\s+/).filter(w => w.length > 0);
    const compressionRatio = 1 - (summary.length / original.length);
    
    return {
      ...metadata,
      wordCount: summaryWords.length,
      estimatedReadingTime: summaryWords.length / 200,
      readabilityScore: this.calculateReadability(summary),
    };
  }

  /**
   * Calculate readability score
   */
  private calculateReadability(text: string): number {
    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
    const words = text.split(/\s+/).filter(w => w.length > 0);
    
    if (sentences.length === 0 || words.length === 0) {
      return 50;
    }
    
    const avgSentenceLength = words.length / sentences.length;
    const avgWordLength = words.reduce((sum, w) => sum + w.length, 0) / words.length;
    
    // Simplified Flesch-Kincaid-like score
    let score = 100 - (avgSentenceLength * 1.5 + avgWordLength * 3);
    return Math.max(0, Math.min(100, score));
  }

  /**
   * Extract entities from text
   */
  private extractEntities(text: string): ExtractedEntity[] {
    const entities: ExtractedEntity[] = [];
    
    // Email addresses
    const emailMatches = text.matchAll(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g);
    for (const match of emailMatches) {
      entities.push({
        type: 'email',
        value: match[0],
        count: 1,
        locations: [{
          start: match.index!,
          end: match.index! + match[0].length,
          line: 0,
          column: 0,
        }],
      });
    }
    
    // URLs
    const urlMatches = text.matchAll(/(?:https?:\/\/|www\.)[^\s/$.?#].[^\s]*/g);
    for (const match of urlMatches) {
      entities.push({
        type: 'url',
        value: match[0],
        count: 1,
        locations: [{
          start: match.index!,
          end: match.index! + match[0].length,
          line: 0,
          column: 0,
        }],
      });
    }
    
    // Numbers (significant ones)
    const numberMatches = text.matchAll(/\b\d{3,}\b/g);
    for (const match of numberMatches) {
      entities.push({
        type: 'number',
        value: match[0],
        count: 1,
        locations: [{
          start: match.index!,
          end: match.index! + match[0].length,
          line: 0,
          column: 0,
        }],
      });
    }
    
    return entities;
  }

  /**
   * Create summary result object
   */
  private createSummaryResult(
    original: string,
    summary: string,
    keyPoints: string[],
    metadata: SummaryMetadata,
    processingTimeMs: number,
    options: SummarizationOptions
  ): SummaryResult {
    const compressionRatio = 1 - (summary.length / original.length);
    const confidence = this.calculateSummaryConfidence(original, summary, metadata);
    
    return {
      original,
      summary,
      originalLength: original.length,
      summaryLength: summary.length,
      compressionRatio,
      keyPoints,
      metadata,
      processingTimeMs,
      confidence,
    };
  }

  /**
   * Calculate summary confidence
   */
  private calculateSummaryConfidence(
    original: string,
    summary: string,
    metadata: SummaryMetadata
  ): number {
    let confidence = 0.7; // Base confidence
    
    // Boost confidence for good compression
    const compressionRatio = 1 - (summary.length / original.length);
    if (compressionRatio > 0.3 && compressionRatio < 0.8) {
      confidence += 0.1;
    }
    
    // Boost confidence for good readability
    if (metadata.readabilityScore > 60) {
      confidence += 0.1;
    }
    
    // Reduce confidence for very short summaries
    if (summary.length < 50) {
      confidence -= 0.2;
    }
    
    return Math.max(0.1, Math.min(1.0, confidence));
  }

  /**
   * Create fallback summary
   */
  private createFallbackSummary(
    content: string,
    options: SummarizationOptions
  ): SummaryResult {
    const summary = content.length > 100 
      ? content.substring(0, 97) + '...'
      : content;
    
    const metadata = this.createMetadata(content, {
      primaryType: 'unknown',
      secondaryTypes: [],
      confidence: 0.1,
      isSensitive: false,
      patterns: [],
    });
    
    return this.createSummaryResult(
      content,
      summary,
      ['Fallback summary generated'],
      metadata,
      0,
      options
    );
  }

  /**
   * Generate cache key
   */
  private generateCacheKey(content: string, options: SummarizationOptions): string {
    const optionsHash = this.hashOptions(options);
    const contentHash = btoa(content.substring(0, 100)).replace(/[^a-zA-Z0-9]/g, '_');
    return summary__;
  }

  /**
   * Hash options for cache key
   */
  private hashOptions(options: SummarizationOptions): string {
    return JSON.stringify(options);
  }

  /**
   * Check if cache entry is valid
   */
  private isCacheValid(timestamp: number): boolean {
    const cacheAge = Date.now() - timestamp;
    return cacheAge < AI.CACHE_DURATION_MINUTES * 60 * 1000;
  }

  /**
   * Cleanup old cache entries
   */
  private cleanupCache(): void {
    if (this.summaryCache.size > 500) {
      const keysToDelete: string[] = [];
      const now = Date.now();
      
      for (const [key, entry] of this.summaryCache.entries()) {
        if (!this.isCacheValid(entry.timestamp)) {
          keysToDelete.push(key);
        }
      }
      
      keysToDelete.forEach(key => this.summaryCache.delete(key));
      
      if (keysToDelete.length > 0) {
        this.llog.debug('Cleaned up summary cache', { count: keysToDelete.length });
      }
    }
  }

  /**
   * Clear summary cache
   */
  public clearCache(): void {
    this.summaryCache.clear();
    this.llog.debug('Summary cache cleared');
  }

  /**
   * Get cache statistics
   */
  public getCacheStats(): { size: number; hitRate: number } {
    // Simplified cache stats
    return {
      size: this.summaryCache.size,
      hitRate: 0.6, // Would track actual hit rate in production
    };
  }

  /**
   * Check if summarizer is ready
   */
  public isReady(): boolean {
    return this.isInitialized;
  }
}





