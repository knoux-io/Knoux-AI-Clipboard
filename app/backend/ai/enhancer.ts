/**
 * Knoux Clipboard AI - AI Content Enhancer
 * Intelligent content enhancement engine for text, code, and prompts
 * Generated by Knoux — Abu Retaj
 * Clipboard Intelligence • Desktop Precision • Premium Engineering
 */

import { logger, createLogger } from '../../shared/logger';
import { CONTENT_TYPES, AI, ERROR_CODES } from '../../shared/constants';
import { AISuggestion, ContentClassification, ProgrammingLanguage } from '../../shared/types';
import { AIModelType, SuggestionCategory } from '../../shared/enums';
import { AIEngine } from './ai-engine';
import { Classifier } from './classifier';
import { PromptLibrary } from './prompt-library';

/**
 * Enhancement options for different content types
 */
export interface EnhancementOptions {
  targetLanguage?: ProgrammingLanguage;
  complexityLevel?: 'beginner' | 'intermediate' | 'advanced' | 'expert';
  tone?: 'formal' | 'casual' | 'technical' | 'creative';
  maxLength?: number;
  includeExamples?: boolean;
  securityCheck?: boolean;
  optimizeForPerformance?: boolean;
}

/**
 * Enhancement result
 */
export interface EnhancementResult {
  original: string;
  enhanced: string;
  improvements: string[];
  confidence: number;
  processingTimeMs: number;
  modelUsed: string;
  suggestions: AISuggestion[];
  metadata: EnhancementMetadata;
}

/**
 * Enhancement metadata
 */
export interface EnhancementMetadata {
  originalLength: number;
  enhancedLength: number;
  reductionPercentage?: number;
  expansionPercentage?: number;
  readabilityScore?: number;
  complexityScore?: number;
  securityIssuesFixed?: number;
  performanceImprovements?: number;
}

export class ContentEnhancer {
  private logger = createLogger({ module: 'enhancer' });
  private aiEngine: AIEngine;
  private classifier: Classifier;
  private promptLibrary: PromptLibrary;
  private enhancementCache: Map<string, EnhancementResult> = new Map();
  private isInitialized = false;

  constructor(aiEngine: AIEngine, classifier: Classifier, promptLibrary: PromptLibrary) {
    this.aiEngine = aiEngine;
    this.classifier = classifier;
    this.promptLibrary = promptLibrary;
  }

  /**
   * Initialize the enhancer
   */
  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    this.logger.info('Initializing content enhancer');
    
    try {
      // Verify AI engine is ready
      await this.aiEngine.ensureReady();
      
      // Initialize prompt library
      await this.promptLibrary.initialize();
      
      this.isInitialized = true;
      this.logger.info('Content enhancer initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize content enhancer', error as Error);
      throw error;
    }
  }

  /**
   * Enhance content based on its type
   */
  public async enhanceContent(
    content: string,
    contentType?: string,
    options: EnhancementOptions = {}
  ): Promise<EnhancementResult> {
    const startTime = Date.now();
    
    if (!this.isInitialized) {
      await this.initialize();
    }

    // Check cache first
    const cacheKey = this.generateCacheKey(content, contentType, options);
    const cachedResult = this.enhancementCache.get(cacheKey);
    if (cachedResult && this.isCacheValid(cachedResult)) {
      this.logger.debug('Enhancement cache hit', { cacheKey });
      return cachedResult;
    }

    this.logger.debug('Enhancing content', {
      contentLength: content.length,
      contentType,
      options,
    });

    try {
      // Classify content if type not provided
      let classification: ContentClassification;
      if (contentType) {
        classification = await this.classifier.classify(content, { forceType: contentType });
      } else {
        classification = await this.classifier.classify(content);
      }

      // Enhance based on content type
      let enhancedContent: string;
      let improvements: string[] = [];
      let confidence = 0.8; // Default confidence

      switch (classification.primaryType) {
        case 'CODE':
          enhancedContent = await this.enhanceCode(content, classification, options);
          improvements = await this.analyzeCodeImprovements(content, enhancedContent, classification);
          confidence = 0.85;
          break;

        case 'PROMPT':
          enhancedContent = await this.enhancePrompt(content, classification, options);
          improvements = await this.analyzePromptImprovements(content, enhancedContent);
          confidence = 0.9;
          break;

        case 'TEXT':
          enhancedContent = await this.enhanceText(content, classification, options);
          improvements = await this.analyzeTextImprovements(content, enhancedContent, classification);
          confidence = 0.75;
          break;

        default:
          enhancedContent = content;
          improvements = ['Content type not supported for enhancement'];
          confidence = 0.3;
      }

      // Generate suggestions
      const suggestions = await this.generateSuggestions(content, enhancedContent, classification, options);

      // Calculate metadata
      const metadata = this.calculateMetadata(content, enhancedContent, improvements);

      const processingTimeMs = Date.now() - startTime;
      const result: EnhancementResult = {
        original: content,
        enhanced: enhancedContent,
        improvements,
        confidence,
        processingTimeMs,
        modelUsed: this.aiEngine.getActiveModel(),
        suggestions,
        metadata,
      };

      // Cache the result
      this.enhancementCache.set(cacheKey, result);
      this.cleanupCache();

      this.logger.info('Content enhanced successfully', {
        originalLength: content.length,
        enhancedLength: enhancedContent.length,
        processingTimeMs,
        confidence,
        improvementsCount: improvements.length,
      });

      return result;

    } catch (error) {
      this.logger.error('Failed to enhance content', error as Error, {
        contentLength: content.length,
        contentType,
      });
      
      throw new Error(`Enhancement failed: ${(error as Error).message}`);
    }
  }

  /**
   * Enhance code content
   */
  private async enhanceCode(
    content: string,
    classification: ContentClassification,
    options: EnhancementOptions
  ): Promise<string> {
    this.logger.debug('Enhancing code content', {
      language: classification.language,
      length: content.length,
    });

    const language = classification.language || options.targetLanguage || ProgrammingLanguage.JAVASCRIPT;
    const prompt = this.promptLibrary.getCodeEnhancementPrompt(language, options);

    try {
      const enhanced = await this.aiEngine.generateCompletion(prompt, {
        context: content,
        maxTokens: Math.min(content.length * 2, AI.MAX_CONTEXT_LENGTH),
        temperature: 0.3,
        topP: 0.9,
      });

      // Validate enhanced code
      const isValid = await this.validateCode(enhanced, language);
      if (!isValid) {
        this.logger.warn('Enhanced code validation failed, returning original');
        return content;
      }

      return enhanced.trim();

    } catch (error) {
      this.logger.error('Code enhancement failed', error as Error);
      return content; // Fallback to original
    }
  }

  /**
   * Enhance prompt content
   */
  private async enhancePrompt(
    content: string,
    classification: ContentClassification,
    options: EnhancementOptions
  ): Promise<string> {
    this.logger.debug('Enhancing prompt content', { length: content.length });

    const prompt = this.promptLibrary.getPromptEnhancementPrompt(options);

    try {
      const enhanced = await this.aiEngine.generateCompletion(prompt, {
        context: content,
        maxTokens: Math.min(content.length * 1.5, AI.MAX_CONTEXT_LENGTH),
        temperature: 0.4,
        topP: 0.95,
      });

      // Extract enhanced prompt from response
      const extracted = this.extractEnhancedPrompt(enhanced, content);
      return extracted;

    } catch (error) {
      this.logger.error('Prompt enhancement failed', error as Error);
      return content; // Fallback to original
    }
  }

  /**
   * Enhance text content
   */
  private async enhanceText(
    content: string,
    classification: ContentClassification,
    options: EnhancementOptions
  ): Promise<string> {
    this.logger.debug('Enhancing text content', { length: content.length });

    const textType = classification.secondaryTypes.includes('EMAIL') ? 'email' :
                    classification.secondaryTypes.includes('DOCUMENT') ? 'document' : 'general';
    
    const prompt = this.promptLibrary.getTextEnhancementPrompt(textType, options);

    try {
      const enhanced = await this.aiEngine.generateCompletion(prompt, {
        context: content,
        maxTokens: options.maxLength || Math.min(content.length * 1.2, AI.MAX_CONTEXT_LENGTH),
        temperature: 0.5,
        topP: 0.9,
      });

      return enhanced.trim();

    } catch (error) {
      this.logger.error('Text enhancement failed', error as Error);
      return content; // Fallback to original
    }
  }

  /**
   * Generate enhancement suggestions
   */
  private async generateSuggestions(
    original: string,
    enhanced: string,
    classification: ContentClassification,
    options: EnhancementOptions
  ): Promise<AISuggestion[]> {
    const suggestions: AISuggestion[] = [];
    const now = Date.now();

    // Compare lengths
    if (enhanced.length < original.length * 0.8) {
      suggestions.push({
        id: `suggestion_${now}_1`,
        type: 'optimization',
        title: 'Content Optimized',
        description: `Content reduced by ${Math.round((1 - enhanced.length / original.length) * 100)}%`,
        priority: 'medium',
        confidence: 0.8,
        applyAutomatically: true,
      });
    }

    // Check for complexity reduction
    if (classification.primaryType === 'CODE') {
      const originalComplexity = this.estimateComplexity(original);
      const enhancedComplexity = this.estimateComplexity(enhanced);
      
      if (enhancedComplexity < originalComplexity * 0.7) {
        suggestions.push({
          id: `suggestion_${now}_2`,
          type: 'code_improvement',
          title: 'Complexity Reduced',
          description: `Code complexity reduced by ${Math.round((1 - enhancedComplexity / originalComplexity) * 100)}%`,
          priority: 'high',
          confidence: 0.75,
          applyAutomatically: true,
        });
      }
    }

    // Security improvements
    if (options.securityCheck) {
      const securityIssues = await this.detectSecurityIssues(original);
      const fixedIssues = await this.detectSecurityIssues(enhanced);
      
      if (securityIssues.length > fixedIssues.length) {
        suggestions.push({
          id: `suggestion_${now}_3`,
          type: 'security_fix',
          title: 'Security Improvements',
          description: `Fixed ${securityIssues.length - fixedIssues.length} security issues`,
          priority: 'critical',
          confidence: 0.9,
          applyAutomatically: true,
        });
      }
    }

    return suggestions;
  }

  /**
   * Analyze code improvements
   */
  private async analyzeCodeImprovements(
    original: string,
    enhanced: string,
    classification: ContentClassification
  ): Promise<string[]> {
    const improvements: string[] = [];
    
    // Check for syntax errors
    const originalErrors = await this.detectSyntaxErrors(original, classification.language);
    const enhancedErrors = await this.detectSyntaxErrors(enhanced, classification.language);
    
    if (enhancedErrors.length < originalErrors.length) {
      improvements.push(`Fixed ${originalErrors.length - enhancedErrors.length} syntax errors`);
    }

    // Check for best practices
    const originalBestPractices = this.checkCodeBestPractices(original, classification.language);
    const enhancedBestPractices = this.checkCodeBestPractices(enhanced, classification.language);
    
    if (enhancedBestPractices.score > originalBestPractices.score) {
      improvements.push(`Improved code quality score from ${originalBestPractices.score}/10 to ${enhancedBestPractices.score}/10`);
    }

    // Performance improvements
    const performanceDiff = this.estimatePerformanceImprovement(original, enhanced);
    if (performanceDiff > 0.1) {
      improvements.push(`Estimated ${Math.round(performanceDiff * 100)}% performance improvement`);
    }

    return improvements;
  }

  /**
   * Analyze prompt improvements
   */
  private async analyzePromptImprovements(original: string, enhanced: string): Promise<string[]> {
    const improvements: string[] = [];
    
    // Clarity improvement
    const originalClarity = this.assessClarity(original);
    const enhancedClarity = this.assessClarity(enhanced);
    
    if (enhancedClarity > originalClarity) {
      improvements.push(`Improved clarity from ${originalClarity}/10 to ${enhancedClarity}/10`);
    }

    // Specificity improvement
    const originalSpecificity = this.assessSpecificity(original);
    const enhancedSpecificity = this.assessSpecificity(enhanced);
    
    if (enhancedSpecificity > originalSpecificity) {
      improvements.push(`Improved specificity from ${originalSpecificity}/10 to ${enhancedSpecificity}/10`);
    }

    // Structure improvement
    const originalStructure = this.assessStructure(original);
    const enhancedStructure = this.assessStructure(enhanced);
    
    if (enhancedStructure > originalStructure) {
      improvements.push(`Improved structure from ${originalStructure}/10 to ${enhancedStructure}/10`);
    }

    return improvements;
  }

  /**
   * Analyze text improvements
   */
  private async analyzeTextImprovements(
    original: string,
    enhanced: string,
    classification: ContentClassification
  ): Promise<string[]> {
    const improvements: string[] = [];
    
    // Readability improvement
    const originalReadability = this.calculateReadability(original);
    const enhancedReadability = this.calculateReadability(enhanced);
    
    if (enhancedReadability.score > originalReadability.score) {
      improvements.push(`Improved readability from ${originalReadability.grade} to ${enhancedReadability.grade}`);
    }

    // Grammar improvement
    const grammarIssues = await this.checkGrammar(original);
    if (grammarIssues.length > 0) {
      improvements.push(`Fixed ${grammarIssues.length} grammar issues`);
    }

    // Conciseness improvement
    if (enhanced.length < original.length * 0.9) {
      improvements.push(`Made text ${Math.round((1 - enhanced.length / original.length) * 100)}% more concise`);
    }

    return improvements;
  }

  /**
   * Calculate enhancement metadata
   */
  private calculateMetadata(
    original: string,
    enhanced: string,
    improvements: string[]
  ): EnhancementMetadata {
    const originalLength = original.length;
    const enhancedLength = enhanced.length;
    
    let reductionPercentage: number | undefined;
    let expansionPercentage: number | undefined;
    
    if (enhancedLength < originalLength) {
      reductionPercentage = (1 - enhancedLength / originalLength) * 100;
    } else if (enhancedLength > originalLength) {
      expansionPercentage = (enhancedLength / originalLength - 1) * 100;
    }

    const readabilityScore = this.calculateReadability(enhanced).score;
    const complexityScore = this.estimateComplexity(enhanced);

    return {
      originalLength,
      enhancedLength,
      reductionPercentage,
      expansionPercentage,
      readabilityScore,
      complexityScore,
      securityIssuesFixed: improvements.filter(i => i.includes('security')).length,
      performanceImprovements: improvements.filter(i => i.includes('performance')).length,
    };
  }

  /**
   * Generate cache key
   */
  private generateCacheKey(content: string, contentType?: string, options?: EnhancementOptions): string {
    const optionsHash = options ? JSON.stringify(options) : '';
    return `${content.substring(0, 100)}_${contentType}_${optionsHash}`.replace(/[^a-zA-Z0-9_]/g, '_');
  }

  /**
   * Check if cache entry is valid
   */
  private isCacheValid(result: EnhancementResult): boolean {
    const cacheAge = Date.now() - (result.processingTimeMs + Date.now() - result.processingTimeMs);
    return cacheAge < AI.CACHE_DURATION_MINUTES * 60 * 1000;
  }

  /**
   * Cleanup old cache entries
   */
  private cleanupCache(): void {
    if (this.enhancementCache.size > 100) {
      const keysToDelete: string[] = [];
      const now = Date.now();
      
      for (const [key, result] of this.enhancementCache.entries()) {
        if (!this.isCacheValid(result)) {
          keysToDelete.push(key);
        }
      }
      
      keysToDelete.forEach(key => this.enhancementCache.delete(key));
      
      if (keysToDelete.length > 0) {
        this.logger.debug('Cleaned up cache entries', { count: keysToDelete.length });
      }
    }
  }

  /**
   * Estimate code complexity
   */
  private estimateComplexity(code: string): number {
    // Simple complexity estimation
    const lines = code.split('\n').length;
    const nesting = (code.match(/{/g) || []).length;
    const conditionals = (code.match(/(if|else|switch|case)/gi) || []).length;
    const loops = (code.match(/(for|while|do)/gi) || []).length;
    
    return lines * 0.1 + nesting * 0.3 + conditionals * 0.2 + loops * 0.4;
  }

  /**
   * Calculate readability score
   */
  private calculateReadability(text: string): { score: number; grade: string } {
    // Simplified Flesch-Kincaid reading ease
    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
    const words = text.split(/\s+/).filter(w => w.length > 0);
    const syllables = words.reduce((count, word) => count + this.countSyllables(word), 0);
    
    if (sentences.length === 0 || words.length === 0) {
      return { score: 0, grade: 'N/A' };
    }
    
    const score = 206.835 - 1.015 * (words.length / sentences.length) - 84.6 * (syllables / words.length);
    
    let grade = 'Very Difficult';
    if (score >= 90) grade = 'Very Easy';
    else if (score >= 80) grade = 'Easy';
    else if (score >= 70) grade = 'Fairly Easy';
    else if (score >= 60) grade = 'Standard';
    else if (score >= 50) grade = 'Fairly Difficult';
    else if (score >= 30) grade = 'Difficult';
    
    return { score, grade };
  }

  /**
   * Count syllables in a word
   */
  private countSyllables(word: string): number {
    word = word.toLowerCase();
    if (word.length <= 3) return 1;
    
    const vowels = word.match(/[aeiouy]+/g);
    return vowels ? vowels.length : 1;
  }

  /**
   * Extract enhanced prompt from AI response
   */
  private extractEnhancedPrompt(response: string, original: string): string {
    // Try to find the enhanced prompt in the response
    const patterns = [
      /Enhanced Prompt:\s*\n?\s*([\s\S]+?)(?:\n\n|\n#|$)/i,
      /Here(?:'s| is) the enhanced version:\s*\n?\s*([\s\S]+?)(?:\n\n|\n#|$)/i,
      /Improved version:\s*\n?\s*([\s\S]+?)(?:\n\n|\n#|$)/i,
    ];
    
    for (const pattern of patterns) {
      const match = response.match(pattern);
      if (match && match[1].trim().length > 10) {
        return match[1].trim();
      }
    }
    
    // If no pattern matched, return the response or original
    return response.trim().length > original.length * 0.5 ? response.trim() : original;
  }

  /**
   * Validate code syntax
   */
  private async validateCode(code: string, language: ProgrammingLanguage): Promise<boolean> {
    // Basic validation - could be extended with language-specific validators
    if (language === ProgrammingLanguage.JSON) {
      try {
        JSON.parse(code);
        return true;
      } catch {
        return false;
      }
    }
    
    // For other languages, check for balanced braces and basic structure
    const openBraces = (code.match(/{/g) || []).length;
    const closeBraces = (code.match(/}/g) || []).length;
    
    if (Math.abs(openBraces - closeBraces) > 2) {
      return false;
    }
    
    return true;
  }

  /**
   * Detect syntax errors in code
   */
  private async detectSyntaxErrors(code: string, language?: ProgrammingLanguage): Promise<string[]> {
    // Simplified syntax error detection
    const errors: string[] = [];
    
    // Check for unmatched quotes
    const singleQuotes = (code.match(/'/g) || []).length;
    const doubleQuotes = (code.match(/"/g) || []).length;
    
    if (singleQuotes % 2 !== 0) errors.push('Unmatched single quotes');
    if (doubleQuotes % 2 !== 0) errors.push('Unmatched double quotes');
    
    // Check for common syntax issues
    const lines = code.split('\n');
    lines.forEach((line, index) => {
      if (line.includes('===') && line.includes('==')) {
        errors.push(`Line ${index + 1}: Mixed equality operators`);
      }
    });
    
    return errors;
  }

  /**
   * Check code best practices
   */
  private checkCodeBestPractices(code: string, language?: ProgrammingLanguage): { score: number; issues: string[] } {
    let score = 10;
    const issues: string[] = [];
    
    // Check line length
    const lines = code.split('\n');
    const longLines = lines.filter(line => line.length > 120);
    if (longLines.length > 0) {
      score -= longLines.length * 0.5;
      issues.push(`${longLines.length} lines exceed 120 characters`);
    }
    
    // Check for TODO comments
    const todoCount = (code.match(/TODO:/gi) || []).length;
    if (todoCount > 0) {
      score -= todoCount;
      issues.push(`${todoCount} TODO comments found`);
    }
    
    // Check for console.log in production code
    if (code.includes('console.log') && !code.includes('// debug')) {
      score -= 2;
      issues.push('console.log statements found');
    }
    
    return { score: Math.max(0, score), issues };
  }

  /**
   * Estimate performance improvement
   */
  private estimatePerformanceImprovement(original: string, enhanced: string): number {
    // Simplified performance estimation
    const originalLoops = (original.match(/(for|while|forEach|map|filter|reduce)/gi) || []).length;
    const enhancedLoops = (enhanced.match(/(for|while|forEach|map|filter|reduce)/gi) || []).length;
    
    if (originalLoops === 0) return 0;
    
    return Math.max(0, (originalLoops - enhancedLoops) / originalLoops);
  }

  /**
   * Assess prompt clarity
   */
  private assessClarity(prompt: string): number {
    // Simple clarity assessment
    const sentences = prompt.split(/[.!?]+/).filter(s => s.trim().length > 0);
    const avgSentenceLength = sentences.reduce((sum, s) => sum + s.length, 0) / (sentences.length || 1);
    
    if (avgSentenceLength < 20) return 9;
    if (avgSentenceLength < 40) return 7;
    if (avgSentenceLength < 60) return 5;
    if (avgSentenceLength < 80) return 3;
    return 1;
  }

  /**
   * Assess prompt specificity
   */
  private assessSpecificity(prompt: string): number {
    // Count specific indicators
    const specificIndicators = [
      /\d+/g, // Numbers
      /["'][^"']+["']/g, // Quotes
      /(specific|concrete|detailed|exact|precise)/gi, // Specificity words
    ];
    
    let score = 0;
    specificIndicators.forEach(indicator => {
      const matches = prompt.match(indicator) || [];
      score += matches.length * 2;
    });
    
    return Math.min(10, score);
  }

  /**
   * Assess prompt structure
   */
  private assessStructure(prompt: string): number {
    const hasSections = prompt.includes('\n') || prompt.includes('#') || prompt.includes('- ');
    const hasContext = prompt.toLowerCase().includes('context') || prompt.toLowerCase().includes('background');
    const hasInstructions = prompt.toLowerCase().includes('instruction') || prompt.toLowerCase().includes('please');
    
    let score = 0;
    if (hasSections) score += 4;
    if (hasContext) score += 3;
    if (hasInstructions) score += 3;
    
    return score;
  }

  /**
   * Check grammar
   */
  private async checkGrammar(text: string): Promise<string[]> {
    // Simplified grammar check
    const issues: string[] = [];
    
    // Common grammar mistakes
    if (text.includes(' alot ')) issues.push('Use "a lot" instead of "alot"');
    if (text.includes(' its ') && !text.includes(" it's ")) {
      // Check if it's actually possessive
      const itsMatches = text.match(/\bits\b/g);
      if (itsMatches && itsMatches.length > 0) {
        issues.push('Check "its" vs "it\'s" usage');
      }
    }
    
    // Double spaces
    if (text.includes('  ')) issues.push('Multiple consecutive spaces');
    
    // Capitalization after period
    const sentences = text.split(/[.!?]+/);
    for (let i = 0; i < sentences.length - 1; i++) {
      const nextChar = text.charAt(text.indexOf(sentences[i]) + sentences[i].length + 1);
      if (nextChar && nextChar.match(/[a-z]/)) {
        issues.push('Sentence not starting with capital letter');
        break;
      }
    }
    
    return issues;
  }

  /**
   * Detect security issues
   */
  private async detectSecurityIssues(content: string): Promise<string[]> {
    const issues: string[] = [];
    
    // Common security patterns
    const securityPatterns = [
      { pattern: /eval\s*\(/, issue: 'eval() function usage' },
      { pattern: /document\.write/, issue: 'document.write() usage' },
      { pattern: /innerHTML\s*=/, issue: 'innerHTML assignment' },
      { pattern: /localStorage\.setItem/, issue: 'localStorage usage' },
      { pattern: /password\s*[:=]/, issue: 'Hardcoded password' },
      { pattern: /api[_-]?key\s*[:=]/, issue: 'Hardcoded API key' },
    ];
    
    securityPatterns.forEach(({ pattern, issue }) => {
      if (pattern.test(content)) {
        issues.push(issue);
      }
    });
    
    return issues;
  }

  /**
   * Clear enhancement cache
   */
  public clearCache(): void {
    this.enhancementCache.clear();
    this.logger.debug('Enhancement cache cleared');
  }

  /**
   * Get cache statistics
   */
  public getCacheStats(): { size: number; hitRate: number } {
    // Simplified cache stats
    return {
      size: this.enhancementCache.size,
      hitRate: 0.7, // Would track actual hit rate in production
    };
  }

  /**
   * Check if enhancer is ready
   */
  public isReady(): boolean {
    return this.isInitialized;
  }
}
