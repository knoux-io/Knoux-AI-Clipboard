/**
 * Knoux Clipboard AI - Content Classifier
 * Intelligent content type detection and classification engine
 * Generated by Knoux - Abu Retaj
 * Clipboard Intelligence • Desktop Precision • Premium Engineering
 */

import { llog } from '../../shared/localized-logger';
import { CONTENT_TYPES, SECURITY, AI } from '../../shared/constants';
import { ContentClassification, ClassificationPattern, TextLocation } from '../../shared/types';
import { ProgrammingLanguage, TextType, DataFormat, ContentCategory } from '../../shared/enums';

/**
 * Classification options
 */
export interface ClassificationOptions {
  forceType?: string;
  detailedAnalysis?: boolean;
  confidenceThreshold?: number;
  languageHints?: string[];
  includePatterns?: boolean;
}

/**
 * Pattern detection rule
 */
export interface PatternRule {
  pattern: RegExp;
  type: string;
  confidence: number;
  category: ContentCategory;
  description: string;
}

/**
 * Language detection pattern
 */
export interface LanguagePattern {
  language: ProgrammingLanguage;
  patterns: RegExp[];
  extensions: string[];
  mimeTypes: string[];
  confidence: number;
}

/**
 * Classifier statistics
 */
export interface ClassifierStats {
  totalClassifications: number;
  cacheHits: number;
  cacheMisses: number;
  averageConfidence: number;
  accuracyByType: Record<string, number>;
  processingTimeAverage: number;
}

export class ContentClassifier {
  private logger = createLogger({ module: 'classifier' });
  private classificationCache: Map<string, ContentClassification> = new Map();
  private patternRules: PatternRule[] = [];
  private languagePatterns: LanguagePattern[] = [];
  private isInitialized = false;

  constructor() {
    this.initializePatterns();
  }

  /**
   * Initialize classification patterns and rules
   */
  private initializePatterns(): void {
    this.llog.info('Initializing classification patterns');

    // ==================== CODE PATTERNS ====================
    
    // JavaScript/TypeScript patterns
    this.addPatternRule({
      pattern: /(?:function\s+\w+|const\s+\w+\s*=\s*\(|let\s+\w+\s*=\s*\(|var\s+\w+\s*=\s*\(|=>|import\s+|export\s+|console\.log)/,
      type: CONTENT_TYPES.CODE.JAVASCRIPT,
      confidence: 0.85,
      category: ContentCategory.CODE,
      description: 'JavaScript/TypeScript code pattern',
    });

    this.addPatternRule({
      pattern: /(?:interface\s+\w+|type\s+\w+|:\s*\w+;|as\s+\w+)/,
      type: CONTENT_TYPES.CODE.TYPESCRIPT,
      confidence: 0.9,
      category: ContentCategory.CODE,
      description: 'TypeScript specific syntax',
    });

    // Python patterns
    this.addPatternRule({
      pattern: /(?:def\s+\w+|import\s+\w+|from\s+\w+|print\(|#.*|""".*?"""|'''.*?''')/,
      type: CONTENT_TYPES.CODE.PYTHON,
      confidence: 0.88,
      category: ContentCategory.CODE,
      description: 'Python code pattern',
    });

    this.addPatternRule({
      pattern: /(?:self\.|__init__|@\w+)/,
      type: CONTENT_TYPES.CODE.PYTHON,
      confidence: 0.95,
      category: ContentCategory.CODE,
      description: 'Python class and decorator pattern',
    });

    // PowerShell patterns
    this.addPatternRule({
      pattern: /(?:Get-|Set-|Write-|Start-|Stop-|\$[a-zA-Z_]+|\$ErrorActionPreference)/,
      type: CONTENT_TYPES.CODE.POWERSHELL,
      confidence: 0.92,
      category: ContentCategory.CODE,
      description: 'PowerShell cmdlet pattern',
    });

    this.addPatternRule({
      pattern: /(?:param\(|\[CmdletBinding\(\)\]|\[Parameter\(\)\])/,
      type: CONTENT_TYPES.CODE.POWERSHELL,
      confidence: 0.96,
      category: ContentCategory.CODE,
      description: 'PowerShell advanced function pattern',
    });

    // Bash/Shell patterns
    this.addPatternRule({
      pattern: /(?:#!/bin/|#!/usr/bin/|echo\s+|cd\s+|ls\s+|grep\s+|awk\s+|sed\s+)/,
      type: CONTENT_TYPES.CODE.BASH,
      confidence: 0.8,
      category: ContentCategory.CODE,
      description: 'Bash/Shell script pattern',
    });

    // JSON patterns
    this.addPatternRule({
      pattern: /^\s*[\{\[]/,
      type: CONTENT_TYPES.CODE.JSON,
      confidence: 0.7,
      category: ContentCategory.DATA,
      description: 'JSON object/array start',
    });

    this.addPatternRule({
      pattern: /"[^"]*"\s*:\s*(?:"[^"]*"|\d+|true|false|null)/,
      type: CONTENT_TYPES.CODE.JSON,
      confidence: 0.9,
      category: ContentCategory.DATA,
      description: 'JSON key-value pair',
    });

    // YAML patterns
    this.addPatternRule({
      pattern: /(?:^---|^\.\.\.|^[a-zA-Z_]+:\s|^-\s+)/,
      type: CONTENT_TYPES.CODE.YAML,
      confidence: 0.85,
      category: ContentCategory.DATA,
      description: 'YAML document structure',
    });

    // HTML patterns
    this.addPatternRule({
      pattern: /<[a-zA-Z][^>]*>|<\/[a-zA-Z][^>]*>/,
      type: CONTENT_TYPES.CODE.HTML,
      confidence: 0.95,
      category: ContentCategory.CODE,
      description: 'HTML tag pattern',
    });

    // CSS patterns
    this.addPatternRule({
      pattern: /[a-zA-Z\-]+\s*\{[^}]*\}/,
      type: CONTENT_TYPES.CODE.CSS,
      confidence: 0.9,
      category: ContentCategory.CODE,
      description: 'CSS rule pattern',
    });

    // SQL patterns
    this.addPatternRule({
      pattern: /(?:SELECT\s+|INSERT\s+INTO|UPDATE\s+|DELETE\s+FROM|CREATE\s+TABLE)/i,
      type: CONTENT_TYPES.CODE.SQL,
      confidence: 0.88,
      category: ContentCategory.CODE,
      description: 'SQL command pattern',
    });

    // Markdown patterns
    this.addPatternRule({
      pattern: /(?:^#+|^\-+|\*\*[^*]+\*\*|__[^_]+__|\[[^\]]+\]\([^)]+\))/,
      type: CONTENT_TYPES.CODE.MARKDOWN,
      confidence: 0.8,
      category: ContentCategory.DOCUMENT,
      description: 'Markdown formatting',
    });

    // XML patterns
    this.addPatternRule({
      pattern: /<\?xml[^?>]*\?>|<[a-zA-Z_][^>]*\/>|<[a-zA-Z_][^>]*>[^<]*<\/[a-zA-Z_][^>]*>/,
      type: CONTENT_TYPES.CODE.XML,
      confidence: 0.9,
      category: ContentCategory.DATA,
      description: 'XML tag pattern',
    });

    // ==================== TEXT PATTERNS ====================

    // Email patterns
    this.addPatternRule({
      pattern: /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/,
      type: CONTENT_TYPES.TEXT.EMAIL,
      confidence: 0.99,
      category: ContentCategory.TEXT,
      description: 'Email address pattern',
    });

    // URL patterns
    this.addPatternRule({
      pattern: /(?:https?:\/\/|ftp:\/\/|www\.)[^\s/$.?#].[^\s]*/,
      type: CONTENT_TYPES.TEXT.URL,
      confidence: 0.95,
      category: ContentCategory.TEXT,
      description: 'URL pattern',
    });

    // Prompt patterns
    this.addPatternRule({
      pattern: /(?:Act as|You are|I need|Generate|Create|Write|Explain|Summarize|Translate)/i,
      type: CONTENT_TYPES.TEXT.PROMPT,
      confidence: 0.75,
      category: ContentCategory.TEXT,
      description: 'AI prompt pattern',
    });

    // Note patterns
    this.addPatternRule({
      pattern: /(?:TODO:|NOTE:|IMPORTANT:|REMINDER:|ACTION:|@\w+)/,
      type: CONTENT_TYPES.TEXT.NOTE,
      confidence: 0.8,
      category: ContentCategory.TEXT,
      description: 'Note or todo pattern',
    });

    // Document patterns
    this.addPatternRule({
      pattern: /(?:Dear\s+[A-Za-z]+,|Sincerely,|Best regards,|To whom it may concern)/,
      type: CONTENT_TYPES.TEXT.DOCUMENT,
      confidence: 0.85,
      category: ContentCategory.DOCUMENT,
      description: 'Formal document pattern',
    });

    // ==================== SENSITIVE PATTERNS ====================

    // API Key patterns
    this.addPatternRule({
      pattern: SECURITY.SENSITIVE_PATTERNS.API_KEY,
      type: CONTENT_TYPES.SENSITIVE.API_KEY,
      confidence: 0.9,
      category: ContentCategory.OTHER,
      description: 'API key pattern',
    });

    // Password patterns
    this.addPatternRule({
      pattern: SECURITY.SENSITIVE_PATTERNS.PASSWORD,
      type: CONTENT_TYPES.SENSITIVE.PASSWORD,
      confidence: 0.85,
      category: ContentCategory.OTHER,
      description: 'Password pattern',
    });

    // JWT Token patterns
    this.addPatternRule({
      pattern: SECURITY.SENSITIVE_PATTERNS.JWT_TOKEN,
      type: CONTENT_TYPES.SENSITIVE.TOKEN,
      confidence: 0.95,
      category: ContentCategory.OTHER,
      description: 'JWT token pattern',
    });

    // Credit card patterns
    this.addPatternRule({
      pattern: SECURITY.SENSITIVE_PATTERNS.CREDIT_CARD,
      type: CONTENT_TYPES.SENSITIVE.CREDIT_CARD,
      confidence: 0.8,
      category: ContentCategory.OTHER,
      description: 'Credit card number pattern',
    });

    // Private key patterns
    this.addPatternRule({
      pattern: /-----BEGIN (?:RSA|DSA|EC|OPENSSH) PRIVATE KEY-----/,
      type: CONTENT_TYPES.SENSITIVE.PRIVATE_KEY,
      confidence: 0.99,
      category: ContentCategory.OTHER,
      description: 'Private key pattern',
    });

    // ==================== LANGUAGE DETECTION PATTERNS ====================

    this.initializeLanguagePatterns();

    this.llog.info(`Initialized ${this.patternRules.length} pattern rules and ${this.languagePatterns.length} language patterns`);
  }

  /**
   * Initialize language-specific patterns
   */
  private initializeLanguagePatterns(): void {
    // JavaScript/TypeScript
    this.languagePatterns.push({
      language: ProgrammingLanguage.JAVASCRIPT,
      patterns: [
        /function\s+\w+\s*\([^)]*\)\s*\{/,
        /const\s+\w+\s*=\s*\([^)]*\)\s*=>/,
        /console\.log\(/,
        /document\.getElementById\(/,
      ],
      extensions: ['.js', '.jsx', '.mjs', '.cjs'],
      mimeTypes: ['application/javascript', 'text/javascript'],
      confidence: 0.9,
    });

    this.languagePatterns.push({
      language: ProgrammingLanguage.TYPESCRIPT,
      patterns: [
        /interface\s+\w+\s*\{/,
        /type\s+\w+\s*=/,
        /:\s*\w+;/,
        /as\s+\w+/,
      ],
      extensions: ['.ts', '.tsx'],
      mimeTypes: ['application/typescript', 'text/typescript'],
      confidence: 0.95,
    });

    // Python
    this.languagePatterns.push({
      language: ProgrammingLanguage.PYTHON,
      patterns: [
        /def\s+\w+\s*\([^)]*\):/,
        /class\s+\w+\s*:/,
        /import\s+\w+/,
        /from\s+\w+\s+import/,
        /if\s+__name__\s*==\s*['"]__main__['"]:/,
      ],
      extensions: ['.py', '.pyw', '.pyc', '.pyo'],
      mimeTypes: ['text/x-python', 'application/x-python'],
      confidence: 0.92,
    });

    // PowerShell
    this.languagePatterns.push({
      language: ProgrammingLanguage.POWERSHELL,
      patterns: [
        /function\s+\w+\s*\{/,
        /param\(\[/,
        /Write-Host/,
        /Get-ChildItem/,
        /\$[a-zA-Z_]\w*\s*=/,
      ],
      extensions: ['.ps1', '.psm1', '.psd1'],
      mimeTypes: ['application/x-powershell'],
      confidence: 0.94,
    });

    // HTML
    this.languagePatterns.push({
      language: ProgrammingLanguage.HTML,
      patterns: [
        /<!DOCTYPE\s+html>/i,
        /<html[^>]*>/i,
        /<head[^>]*>/i,
        /<body[^>]*>/i,
        /<div[^>]*>/i,
      ],
      extensions: ['.html', '.htm', '.xhtml'],
      mimeTypes: ['text/html', 'application/xhtml+xml'],
      confidence: 0.98,
    });

    // CSS
    this.languagePatterns.push({
      language: ProgrammingLanguage.CSS,
      patterns: [
        /[a-zA-Z\-]+\s*\{[^}]*\}/,
        /@media[^{]*\{[^}]*\}/,
        /@keyframes\s+\w+/,
        /:\s*(hover|focus|active)/,
      ],
      extensions: ['.css', '.scss', '.sass', '.less'],
      mimeTypes: ['text/css'],
      confidence: 0.9,
    });

    // JSON
    this.languagePatterns.push({
      language: ProgrammingLanguage.JSON,
      patterns: [
        /^\s*\{[^}]*\}\s*$/,
        /^\s*\[[^\]]*\]\s*$/,
        /"[^"]*"\s*:\s*(?:"[^"]*"|\d+|true|false|null)/,
      ],
      extensions: ['.json', '.jsonl', '.jsonc'],
      mimeTypes: ['application/json'],
      confidence: 0.99,
    });

    // YAML
    this.languagePatterns.push({
      language: ProgrammingLanguage.YAML,
      patterns: [
        /^---\s*$/,
        /^\.\.\.\s*$/,
        /^[a-zA-Z_]+:\s*(?:\||>)?/,
        /^-\s+[a-zA-Z_]+:/,
      ],
      extensions: ['.yaml', '.yml'],
      mimeTypes: ['application/x-yaml', 'text/yaml'],
      confidence: 0.85,
    });

    // Markdown
    this.languagePatterns.push({
      language: ProgrammingLanguage.MARKDOWN,
      patterns: [
        /^#+\s+.+$/,
        /^\*\*\s*.+\*\*\s*$/,
        /^-\s+\[[ x]\]\s*.+$/,
        /^```[a-zA-Z]*$/,
      ],
      extensions: ['.md', '.markdown', '.mdown'],
      mimeTypes: ['text/markdown'],
      confidence: 0.8,
    });
  }

  /**
   * Add a pattern rule
   */
  private addPatternRule(rule: PatternRule): void {
    this.patternRules.push(rule);
  }

  /**
   * Initialize classifier
   */
  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    this.llog.info('Initializing content classifier');

    try {
      // Load any custom patterns from storage
      await this.loadCustomPatterns();
      
      // Warm up the classifier with sample data
      await this.warmUp();
      
      this.isInitialized = true;
      this.llog.info('Content classifier initialized successfully', {
        patternCount: this.patternRules.length,
        languagePatternCount: this.languagePatterns.length,
      });
    } catch (error) {
      this.llog.error('Failed to initialize classifier', error as Error);
      throw error;
    }
  }

  /**
   * Load custom patterns from storage
   */
  private async loadCustomPatterns(): Promise<void> {
    // In production, this would load user-defined patterns
    this.llog.debug('Would load custom patterns from storage');
  }

  /**
   * Warm up classifier with sample data
   */
  private async warmUp(): Promise<void> {
    const samples = [
      'const x = 5; // JavaScript',
      'def hello(): # Python',
      'Get-ChildItem -Path C:\\ # PowerShell',
      '{"key": "value"} // JSON',
      '# Hello Markdown',
    ];

    for (const sample of samples) {
      await this.classify(sample, { detailedAnalysis: false });
    }

    this.llog.debug('Classifier warmed up with sample data');
  }

  /**
   * Classify content
   */
  public async classify(
    content: string,
    options: ClassificationOptions = {}
  ): Promise<ContentClassification> {
    const startTime = Date.now();
    
    if (!this.isInitialized) {
      await this.initialize();
    }

    // Check cache first
    const cacheKey = this.generateCacheKey(content, options);
    const cachedResult = this.classificationCache.get(cacheKey);
    if (cachedResult && this.isCacheValid(cachedResult)) {
      this.llog.debug('Classification cache hit', { cacheKey });
      return cachedResult;
    }

    this.llog.debug('Classifying content', {
      contentLength: content.length,
      options,
    });

    try {
      // If forceType is specified, use it directly
      if (options.forceType) {
        const forcedResult = this.createForcedClassification(content, options.forceType);
        this.classificationCache.set(cacheKey, forcedResult);
        return forcedResult;
      }

      // Analyze content
      const analysis = this.analyzeContent(content, options);
      
      // Determine primary type
      const primaryType = this.determinePrimaryType(analysis, options);
      
      // Check for sensitive content
      const sensitiveAnalysis = this.analyzeSensitiveContent(content);
      
      // Detect programming language
      const language = this.detectProgrammingLanguage(content, primaryType);
      
      // Create classification object
      const classification: ContentClassification = {
        primaryType,
        secondaryTypes: this.getSecondaryTypes(analysis, primaryType),
        confidence: this.calculateConfidence(analysis, primaryType),
        language,
        framework: this.detectFramework(content, language),
        isSensitive: sensitiveAnalysis.isSensitive,
        sensitiveType: sensitiveAnalysis.sensitiveType,
        patterns: options.includePatterns ? analysis.patterns : [],
      };

      // Cache the result
      this.classificationCache.set(cacheKey, classification);
      this.cleanupCache();

      const processingTime = Date.now() - startTime;
      this.llog.info('Content classification completed', {
        contentLength: content.length,
        primaryType,
        confidence: classification.confidence,
        isSensitive: classification.isSensitive,
        processingTime,
      });

      return classification;

    } catch (error) {
      this.llog.error('Content classification failed', error as Error, {
        contentLength: content.length,
      });
      
      // Return a fallback classification
      return this.createFallbackClassification(content);
    }
  }

  /**
   * Analyze content using pattern rules
   */
  private analyzeContent(content: string, options: ClassificationOptions): {
    patterns: ClassificationPattern[];
    scores: Map<string, number>;
  } {
    const patterns: ClassificationPattern[] = [];
    const scores = new Map<string, number>();

    // Apply all pattern rules
    for (const rule of this.patternRules) {
      const matches = this.applyPatternRule(content, rule);
      
      if (matches.length > 0) {
        patterns.push(...matches);
        
        // Update scores based on matches
        const currentScore = scores.get(rule.type) || 0;
        scores.set(rule.type, currentScore + (rule.confidence * matches.length));
      }
    }

    // Apply language detection
    if (options.languageHints) {
      for (const hint of options.languageHints) {
        scores.set(hint, (scores.get(hint) || 0) + 0.3);
      }
    }

    return { patterns, scores };
  }

  /**
   * Apply a single pattern rule to content
   */
  private applyPatternRule(content: string, rule: PatternRule): ClassificationPattern[] {
    const patterns: ClassificationPattern[] = [];
    const regex = new RegExp(rule.pattern.source, rule.pattern.flags + 'g');
    
    let match;
    while ((match = regex.exec(content)) !== null) {
      const lineNumber = this.getLineNumber(content, match.index);
      const column = this.getColumn(content, match.index);
      
      patterns.push({
        type: rule.type,
        pattern: rule.pattern.source,
        confidence: rule.confidence,
        location: {
          start: match.index,
          end: match.index + match[0].length,
          line: lineNumber,
          column,
        },
      });
    }
    
    return patterns;
  }

  /**
   * Determine primary content type from analysis
   */
  private determinePrimaryType(
    analysis: { scores: Map<string, number> },
    options: ClassificationOptions
  ): string {
    const threshold = options.confidenceThreshold || AI.CONFIDENCE_THRESHOLD;
    
    // Convert scores to array and sort by score
    const scoresArray = Array.from(analysis.scores.entries())
      .sort((a, b) => b[1] - a[1]);
    
    // If we have a high-confidence match, use it
    if (scoresArray.length > 0 && scoresArray[0][1] >= threshold) {
      return scoresArray[0][0];
    }
    
    // Check for specific type patterns
    if (this.isLikelyCode(analysis.scores)) {
      return CONTENT_TYPES.CODE.JAVASCRIPT; // Default to JavaScript for code
    }
    
    if (this.isLikelyText(analysis.scores)) {
      return CONTENT_TYPES.TEXT.PLAIN; // Default to plain text
    }
    
    // Fallback to unknown
    return 'unknown';
  }

  /**
   * Check if content is likely code
   */
  private isLikelyCode(scores: Map<string, number>): boolean {
    const codeTypes = Object.values(CONTENT_TYPES.CODE);
    let codeScore = 0;
    
    for (const [type, score] of scores.entries()) {
      if (codeTypes.includes(type as any)) {
        codeScore += score;
      }
    }
    
    return codeScore > 1.0;
  }

  /**
   * Check if content is likely text
   */
  private isLikelyText(scores: Map<string, number>): boolean {
    const textTypes = Object.values(CONTENT_TYPES.TEXT);
    let textScore = 0;
    
    for (const [type, score] of scores.entries()) {
      if (textTypes.includes(type as any)) {
        textScore += score;
      }
    }
    
    return textScore > 0.5;
  }

  /**
   * Get secondary types from analysis
   */
  private getSecondaryTypes(
    analysis: { scores: Map<string, number> },
    primaryType: string
  ): string[] {
    const secondaryTypes: string[] = [];
    const threshold = 0.3;
    
    // Get all types with significant scores, excluding primary
    for (const [type, score] of analysis.scores.entries()) {
      if (type !== primaryType && score >= threshold) {
        secondaryTypes.push(type);
      }
    }
    
    // Limit to top 3 secondary types
    return secondaryTypes.slice(0, 3);
  }

  /**
   * Calculate overall confidence
   */
  private calculateConfidence(
    analysis: { scores: Map<string, number> },
    primaryType: string
  ): number {
    const primaryScore = analysis.scores.get(primaryType) || 0;
    const totalScore = Array.from(analysis.scores.values()).reduce((a, b) => a + b, 0);
    
    if (totalScore === 0) {
      return 0.1; // Very low confidence
    }
    
    // Confidence is primary score normalized by total score
    let confidence = primaryScore / totalScore;
    
    // Boost confidence for high scores
    if (primaryScore > 2.0) {
      confidence = Math.min(1.0, confidence * 1.3);
    }
    
    return Math.min(1.0, Math.max(0.1, confidence));
  }

  /**
   * Analyze sensitive content
   */
  private analyzeSensitiveContent(content: string): {
    isSensitive: boolean;
    sensitiveType?: string;
  } {
    const sensitiveTypes = Object.values(CONTENT_TYPES.SENSITIVE);
    
    for (const rule of this.patternRules) {
      if (sensitiveTypes.includes(rule.type as any)) {
        if (rule.pattern.test(content)) {
          return {
            isSensitive: true,
            sensitiveType: rule.type,
          };
        }
      }
    }
    
    return { isSensitive: false };
  }

  /**
   * Detect programming language
   */
  private detectProgrammingLanguage(content: string, primaryType: string): ProgrammingLanguage | undefined {
    // Only detect language for code types
    const codeTypes = Object.values(CONTENT_TYPES.CODE);
    if (!codeTypes.includes(primaryType as any)) {
      return undefined;
    }
    
    // Try to match against language patterns
    let bestMatch: { language: ProgrammingLanguage; confidence: number } | null = null;
    
    for (const langPattern of this.languagePatterns) {
      let matchCount = 0;
      
      for (const pattern of langPattern.patterns) {
        if (pattern.test(content)) {
          matchCount++;
        }
      }
      
      if (matchCount > 0) {
        const confidence = langPattern.confidence * (matchCount / langPattern.patterns.length);
        
        if (!bestMatch || confidence > bestMatch.confidence) {
          bestMatch = { language: langPattern.language, confidence };
        }
      }
    }
    
    // If we found a good match, return it
    if (bestMatch && bestMatch.confidence > 0.5) {
      return bestMatch.language;
    }
    
    // Try to infer from primary type
    const typeToLanguage: Record<string, ProgrammingLanguage> = {
      [CONTENT_TYPES.CODE.JAVASCRIPT]: ProgrammingLanguage.JAVASCRIPT,
      [CONTENT_TYPES.CODE.TYPESCRIPT]: ProgrammingLanguage.TYPESCRIPT,
      [CONTENT_TYPES.CODE.PYTHON]: ProgrammingLanguage.PYTHON,
      [CONTENT_TYPES.CODE.POWERSHELL]: ProgrammingLanguage.POWERSHELL,
      [CONTENT_TYPES.CODE.BASH]: ProgrammingLanguage.BASH,
      [CONTENT_TYPES.CODE.HTML]: ProgrammingLanguage.HTML,
      [CONTENT_TYPES.CODE.CSS]: ProgrammingLanguage.CSS,
      [CONTENT_TYPES.CODE.JSON]: ProgrammingLanguage.JSON,
      [CONTENT_TYPES.CODE.YAML]: ProgrammingLanguage.YAML,
      [CONTENT_TYPES.CODE.MARKDOWN]: ProgrammingLanguage.MARKDOWN,
      [CONTENT_TYPES.CODE.XML]: ProgrammingLanguage.XML,
      [CONTENT_TYPES.CODE.SQL]: ProgrammingLanguage.SQL,
    };
    
    return typeToLanguage[primaryType];
  }

  /**
   * Detect framework from content
   */
  private detectFramework(content: string, language?: ProgrammingLanguage): string | undefined {
    if (!language) {
      return undefined;
    }
    
    const frameworkPatterns: Record<ProgrammingLanguage, Array<{ pattern: RegExp; framework: string }>> = {
      [ProgrammingLanguage.JAVASCRIPT]: [
        { pattern: /React\.|import.*from 'react'/, framework: 'React' },
        { pattern: /Vue\.|import.*from 'vue'/, framework: 'Vue.js' },
        { pattern: /angular\.|@Component/, framework: 'Angular' },
        { pattern: /require\('express'\)|import.*from 'express'/, framework: 'Express.js' },
        { pattern: /next\/|import.*from 'next'/, framework: 'Next.js' },
      ],
      [ProgrammingLanguage.PYTHON]: [
        { pattern: /from flask import|Flask\(/, framework: 'Flask' },
        { pattern: /from django|Django settings/, framework: 'Django' },
        { pattern: /import fastapi|FastAPI\(/, framework: 'FastAPI' },
        { pattern: /import numpy|np\./, framework: 'NumPy' },
        { pattern: /import pandas|pd\./, framework: 'Pandas' },
      ],
      [ProgrammingLanguage.TYPESCRIPT]: [
        { pattern: /@nestjs|NestFactory/, framework: 'NestJS' },
        { pattern: /@angular|NgModule/, framework: 'Angular' },
      ],
    };
    
    const patterns = frameworkPatterns[language];
    if (!patterns) {
      return undefined;
    }
    
    for (const { pattern, framework } of patterns) {
      if (pattern.test(content)) {
        return framework;
      }
    }
    
    return undefined;
  }

  /**
   * Create forced classification
   */
  private createForcedClassification(content: string, forcedType: string): ContentClassification {
    return {
      primaryType: forcedType,
      secondaryTypes: [],
      confidence: 0.9, // High confidence for forced types
      isSensitive: false,
      patterns: [],
    };
  }

  /**
   * Create fallback classification
   */
  private createFallbackClassification(content: string): ContentClassification {
    // Simple heuristic for fallback
    const lines = content.split('\n');
    const avgLineLength = content.length / (lines.length || 1);
    
    let primaryType: string;
    if (lines.length > 1 && avgLineLength < 100) {
      primaryType = CONTENT_TYPES.TEXT.PLAIN;
    } else if (content.includes('=') || content.includes('{') || content.includes('[')) {
      primaryType = CONTENT_TYPES.CODE.JSON;
    } else {
      primaryType = CONTENT_TYPES.TEXT.PLAIN;
    }
    
    return {
      primaryType,
      secondaryTypes: [],
      confidence: 0.3, // Low confidence for fallback
      isSensitive: false,
      patterns: [],
    };
  }

  /**
   * Get line number from character index
   */
  private getLineNumber(content: string, charIndex: number): number {
    const lines = content.substring(0, charIndex).split('\n');
    return lines.length;
  }

  /**
   * Get column from character index
   */
  private getColumn(content: string, charIndex: number): number {
    const lines = content.substring(0, charIndex).split('\n');
    const lastLine = lines[lines.length - 1] || '';
    return lastLine.length;
  }

  /**
   * Generate cache key
   */
  private generateCacheKey(content: string, options: ClassificationOptions): string {
    const optionsHash = JSON.stringify(options);
    const contentHash = btoa(content.substring(0, 100)).replace(/[^a-zA-Z0-9]/g, '_');
    return `classify_${contentHash}_${optionsHash}`;
  }

  /**
   * Check if cache entry is valid
   */
  private isCacheValid(classification: ContentClassification): boolean {
    // Cache is always valid for forced classifications
    if (classification.confidence >= 0.9) {
      return true;
    }
    
    // Otherwise use standard cache duration
    const cacheDuration = AI.CACHE_DURATION_MINUTES * 60 * 1000;
    return true; // Always valid in this simplified implementation
  }

  /**
   * Cleanup old cache entries
   */
  private cleanupCache(): void {
    if (this.classificationCache.size > 1000) {
      const keysToDelete: string[] = [];
      
      for (const [key, classification] of this.classificationCache.entries()) {
        if (!this.isCacheValid(classification)) {
          keysToDelete.push(key);
        }
      }
      
      keysToDelete.forEach(key => this.classificationCache.delete(key));
      
      if (keysToDelete.length > 0) {
        this.llog.debug('Cleaned up classification cache', { count: keysToDelete.length });
      }
    }
  }

  /**
   * Clear classification cache
   */
  public clearCache(): void {
    this.classificationCache.clear();
    this.llog.debug('Classification cache cleared');
  }

  /**
   * Get classifier statistics
   */
  public getStats(): ClassifierStats {
    const classifications = Array.from(this.classificationCache.values());
    
    return {
      totalClassifications: classifications.length,
      cacheHits: 0, // Would track in production
      cacheMisses: 0, // Would track in production
      averageConfidence: classifications.reduce((sum, c) => sum + c.confidence, 0) / (classifications.length || 1),
      accuracyByType: {}, // Would track in production
      processingTimeAverage: 0, // Would track in production
    };
  }

  /**
   * Add custom pattern rule
   */
  public addCustomPattern(rule: Omit<PatternRule, 'category'>): void {
    const fullRule: PatternRule = {
      ...rule,
      category: this.inferCategory(rule.type),
    };
    
    this.patternRules.push(fullRule);
    this.llog.info('Custom pattern added', { type: rule.type, pattern: rule.pattern });
  }

  /**
   * Infer category from type
   */
  private inferCategory(type: string): ContentCategory {
    if (Object.values(CONTENT_TYPES.CODE).includes(type as any)) {
      return ContentCategory.CODE;
    }
    
    if (Object.values(CONTENT_TYPES.TEXT).includes(type as any)) {
      return ContentCategory.TEXT;
    }
    
    if (Object.values(CONTENT_TYPES.SENSITIVE).includes(type as any)) {
      return ContentCategory.OTHER;
    }
    
    if (Object.values(CONTENT_TYPES.MEDIA).includes(type as any)) {
      return ContentCategory.MEDIA;
    }
    
    return ContentCategory.OTHER;
  }

  /**
   * Check if classifier is ready
   */
  public isReady(): boolean {
    return this.isInitialized;
  }

  /**
   * Validate content against type
   */
  public validateContentType(content: string, expectedType: string): boolean {
    const classification = this.classify(content, { detailedAnalysis: false });
    return classification.then(c => c.primaryType === expectedType);
  }

  /**
   * Get all detected patterns in content
   */
  public async getContentPatterns(content: string): Promise<ClassificationPattern[]> {
    const analysis = this.analyzeContent(content, { includePatterns: true });
    return analysis.patterns;
  }

  /**
   * Extract specific type from content
   */
  public async extractByType(content: string, type: string): Promise<string[]> {
    const patterns = await this.getContentPatterns(content);
    const matchingPatterns = patterns.filter(p => p.type === type);
    
    return matchingPatterns.map(pattern => {
      return content.substring(pattern.location.start, pattern.location.end);
    });
  }
}

