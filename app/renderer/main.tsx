/**
 * Knoux Clipboard AI - Renderer Main Entry Point
 * React application bootstrap and initialization
 * Generated by Knoux — Abu Retaj
 * Clipboard Intelligence • Desktop Precision • Premium Engineering
 */

import React from 'react';
import ReactDOM from 'react-dom/client';
import { HashRouter } from 'react-router-dom';
import { Provider } from 'react-redux';
import { ThemeProvider } from 'styled-components';
import { ToastContainer } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';

// Application imports
import App from './App.tsx';
import { store } from './store';
import { theme } from './styles/theme';
import { logger, createLogger } from './shared/logger';
import { ErrorBoundary } from './components/ErrorBoundary';
import { LoadingOverlay } from './components/LoadingOverlay';
import { initializeApp } from './services/initialization';

// Import global styles
import './styles/global.css';
import './styles/animations.css';

// Initialize renderer logger
const rendererLogger = createLogger({ module: 'renderer' });

// ==================== TYPE DECLARATIONS ====================

// Extend Window interface for Electron context bridge
declare global {
  interface Window {
    knoux: {
      // System
      getPlatform: () => Promise<string>;
      setAutostart: (enabled: boolean) => Promise<{ success: boolean; error?: string }>;
      restartApp: () => Promise<void>;
      quitApp: () => Promise<void>;
      
      // Settings
      getAllSettings: () => Promise<any>;
      updateSettings: (updates: any) => Promise<{ success: boolean; error?: string }>;
      resetSettings: () => Promise<{ success: boolean; error?: string }>;
      
      // Clipboard
      getClipboardHistory: (options?: any) => Promise<any[]>;
      addClipboardItem: (item: any) => Promise<{ success: boolean; id?: string; error?: string }>;
      deleteClipboardItem: (id: string) => Promise<{ success: boolean; error?: string }>;
      clearClipboardHistory: () => Promise<{ success: boolean; error?: string }>;
      
      // AI
      analyzeContent: (content: string, options?: any) => Promise<any>;
      getSuggestions: (content: string, context?: any) => Promise<any[]>;
      classifyContent: (content: string) => Promise<any>;
      
      // Security
      checkSensitive: (content: string) => Promise<any>;
      encryptData: (data: string, options?: any) => Promise<{ success: boolean; encrypted?: string; error?: string }>;
      
      // Window Management
      minimizeWindow: () => Promise<void>;
      maximizeWindow: () => Promise<void>;
      closeWindow: () => Promise<void>;
      toggleWindow: () => Promise<void>;
      
      // Events
      onAppEvent: (callback: (event: any) => void) => () => void;
      sendEvent: (eventType: string, data?: any) => Promise<void>;
      
      // Utility
      openExternal: (url: string) => Promise<void>;
      getAppVersion: () => Promise<string>;
    };
    
    knouxLogger: {
      debug: (message: string, data?: any) => void;
      info: (message: string, data?: any) => void;
      warn: (message: string, data?: any) => void;
      error: (message: string, error?: Error, data?: any) => void;
    };
    
    // Debug utilities
    __KNOUX_DEBUG?: {
      showLoading: () => void;
      showError: (title: string, message: string) => void;
      getLoadTime: () => number;
    };
  }
}

// ==================== APPLICATION INITIALIZATION ====================

/**
 * Check if we're running in Electron context
 */
function isElectronContext(): boolean {
  return typeof window !== 'undefined' && 
         window.process && 
         window.process.type === 'renderer';
}

/**
 * Check if required APIs are available
 */
function checkRequiredAPIs(): boolean {
  if (!isElectronContext()) {
    rendererLogger.error('Not running in Electron renderer context');
    return false;
  }
  
  if (!window.knoux) {
    rendererLogger.error('Knoux API not available in window context');
    return false;
  }
  
  if (!window.knouxLogger) {
    rendererLogger.error('Knoux logger not available in window context');
    return false;
  }
  
  // Check essential methods
  const requiredMethods = [
    'getPlatform',
    'getAllSettings',
    'getClipboardHistory',
    'onAppEvent',
  ];
  
  for (const method of requiredMethods) {
    if (typeof (window.knoux as any)[method] !== 'function') {
      rendererLogger.error(`Required method ${method} not available`);
      return false;
    }
  }
  
  return true;
}

/**
 * Setup global error handlers
 */
function setupGlobalErrorHandlers(): void {
  // Window error handler
  window.addEventListener('error', (event) => {
    rendererLogger.error('Uncaught error', event.error, {
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
    });
    
    // Prevent default error dialog in development
    if (process.env.NODE_ENV === 'development') {
      event.preventDefault();
    }
  });
  
  // Unhandled promise rejections
  window.addEventListener('unhandledrejection', (event) => {
    rendererLogger.error('Unhandled promise rejection', event.reason, {
      reason: String(event.reason),
    });
    
    // Prevent default error in development
    if (process.env.NODE_ENV === 'development') {
      event.preventDefault();
    }
  });
  
  // React error boundary fallback
  const originalConsoleError = console.error;
  console.error = (...args) => {
    originalConsoleError.apply(console, args);
    
    // Log React errors
    if (args[0] && typeof args[0] === 'string' && args[0].includes('React')) {
      rendererLogger.error('React error detected', new Error(args[0]), {
        args: args.slice(1),
      });
    }
  };
}

/**
 * Setup IPC event listeners
 */
function setupIpcEventListeners(): void {
  if (!window.knoux || !window.knoux.onAppEvent) {
    return;
  }
  
  // Subscribe to app events
  const unsubscribe = window.knoux.onAppEvent((event) => {
    const { type, data, timestamp } = event;
    
    rendererLogger.debug(`App event received: ${type}`, { data, timestamp });
    
    // Dispatch events to Redux store or handle them
    switch (type) {
      case 'clipboard:updated':
        // Handle clipboard updates
        // store.dispatch(updateClipboardItems(data.items));
        break;
        
      case 'ai:analysis-complete':
        // Handle AI analysis completion
        // store.dispatch(updateAIAnalysis(data));
        break;
        
      case 'security:alert':
        // Handle security alerts
        // store.dispatch(addSecurityAlert(data));
        break;
        
      case 'settings:changed':
        // Handle settings changes
        // store.dispatch(updateSettings(data));
        break;
        
      case 'system:event':
        // Handle system events
        handleSystemEvent(data);
        break;
        
      case 'window:state-changed':
        // Handle window state changes
        // store.dispatch(updateWindowState(data));
        break;
    }
  });
  
  // Store unsubscribe for cleanup
  (window as any).__unsubscribeAppEvents = unsubscribe;
}

/**
 * Handle system events from main process
 */
function handleSystemEvent(data: any): void {
  const { event, payload } = data || {};
  
  switch (event) {
    case 'app-started':
      rendererLogger.info('Application started from main process', payload);
      break;
      
    case 'update-available':
      rendererLogger.info('Update available', payload);
      // Show update notification
      break;
      
    case 'memory-warning':
      rendererLogger.warn('Memory warning received', payload);
      // Optimize memory usage
      break;
      
    case 'focus':
      rendererLogger.debug('Window focused');
      // Resume intensive operations
      break;
      
    case 'blur':
      rendererLogger.debug('Window blurred');
      // Pause intensive operations
      break;
  }
}

/**
 * Initialize application services
 */
async function initializeServices(): Promise<boolean> {
  try {
    rendererLogger.info('Initializing application services');
    
    // 1. Get platform information
    const platform = await window.knoux.getPlatform();
    rendererLogger.info(`Running on platform: ${platform}`);
    
    // 2. Load application settings
    const settings = await window.knoux.getAllSettings();
    rendererLogger.info('Settings loaded', { 
      theme: settings.ui?.theme,
      version: settings.version,
    });
    
    // 3. Load initial clipboard history
    const clipboardHistory = await window.knoux.getClipboardHistory({ limit: 50 });
    rendererLogger.info('Clipboard history loaded', { 
      count: clipboardHistory?.length || 0,
    });
    
    // 4. Initialize additional services
    const initResult = await initializeApp(settings);
    
    if (!initResult.success) {
      throw new Error(initResult.error || 'Failed to initialize application');
    }
    
    rendererLogger.info('Application services initialized successfully');
    return true;
    
  } catch (error) {
    rendererLogger.error('Failed to initialize services', error as Error);
    return false;
  }
}

/**
 * Setup performance monitoring
 */
function setupPerformanceMonitoring(): void {
  // Monitor render performance
  if (typeof PerformanceObserver !== 'undefined') {
    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.entryType === 'longtask') {
          rendererLogger.warn('Long task detected', {
            duration: entry.duration,
            startTime: entry.startTime,
            name: entry.name,
          });
        }
      }
    });
    
    observer.observe({ entryTypes: ['longtask'] });
    
    // Store for cleanup
    (window as any).__performanceObserver = observer;
  }
  
  // Monitor memory usage
  if ('memory' in performance) {
    setInterval(() => {
      const memory = (performance as any).memory;
      if (memory.usedJSHeapSize > 100 * 1024 * 1024) { // 100MB threshold
        rendererLogger.warn('High memory usage detected', {
          used: Math.round(memory.usedJSHeapSize / 1024 / 1024) + 'MB',
          total: Math.round(memory.totalJSHeapSize / 1024 / 1024) + 'MB',
        });
      }
    }, 30000);
  }
}

/**
 * Cleanup resources before unload
 */
function setupCleanup(): void {
  window.addEventListener('beforeunload', () => {
    rendererLogger.info('Application unloading, cleaning up resources');
    
    // Unsubscribe from events
    if ((window as any).__unsubscribeAppEvents) {
      (window as any).__unsubscribeAppEvents();
    }
    
    // Disconnect performance observer
    if ((window as any).__performanceObserver) {
      (window as any).__performanceObserver.disconnect();
    }
    
    // Flush logs
    if (window.knouxLogger) {
      // Log final message
      window.knouxLogger.info('Application cleanup complete');
    }
  });
}

// ==================== REACT APPLICATION RENDER ====================

/**
 * Main application render function
 */
async function renderApplication(): Promise<void> {
  try {
    rendererLogger.info('Starting React application render');
    
    // Get root element
    const rootElement = document.getElementById('root');
    if (!rootElement) {
      throw new Error('Root element not found');
    }
    
    // Create React root
    const root = ReactDOM.createRoot(rootElement);
    
    // Initial render with loading state
    root.render(
      <React.StrictMode>
        <ErrorBoundary>
          <LoadingOverlay message="Initializing application..." />
        </ErrorBoundary>
      </React.StrictMode>
    );
    
    // Initialize services
    const servicesInitialized = await initializeServices();
    if (!servicesInitialized) {
      throw new Error('Failed to initialize application services');
    }
    
    // Full application render
    root.render(
      <React.StrictMode>
        <ErrorBoundary>
          <Provider store={store}>
            <ThemeProvider theme={theme}>
              <HashRouter>
                <App />
                <ToastContainer
                  position="bottom-right"
                  autoClose={5000}
                  hideProgressBar={false}
                  newestOnTop
                  closeOnClick
                  rtl={false}
                  pauseOnFocusLoss
                  draggable
                  pauseOnHover
                  theme="dark"
                />
              </HashRouter>
            </ThemeProvider>
          </Provider>
        </ErrorBoundary>
      </React.StrictMode>
    );
    
    rendererLogger.info('React application rendered successfully');
    
    // Hide loading screen
    const loadingScreen = document.getElementById('loadingScreen');
    if (loadingScreen) {
      loadingScreen.classList.add('fade-out');
      setTimeout(() => {
        loadingScreen.style.display = 'none';
      }, 500);
    }
    
  } catch (error) {
    rendererLogger.error('Failed to render application', error as Error);
    
    // Show error screen
    const errorScreen = document.getElementById('errorScreen');
    const errorTitle = document.getElementById('errorTitle');
    const errorMessage = document.getElementById('errorMessage');
    
    if (errorScreen && errorTitle && errorMessage) {
      errorTitle.textContent = 'Application Failed to Start';
      errorMessage.textContent = error instanceof Error ? error.message : 'Unknown error occurred';
      errorScreen.style.display = 'flex';
      
      const loadingScreen = document.getElementById('loadingScreen');
      if (loadingScreen) {
        loadingScreen.style.display = 'none';
      }
    }
    
    throw error;
  }
}

// ==================== MAIN ENTRY POINT ====================

/**
 * Application bootstrap function
 */
async function bootstrap(): Promise<void> {
  try {
    rendererLogger.info('Bootstrapping Knoux Clipboard AI application');
    
    // 1. Check environment
    if (!isElectronContext()) {
      throw new Error('Application must run within Electron');
    }
    
    // 2. Check required APIs
    if (!checkRequiredAPIs()) {
      throw new Error('Required APIs not available');
    }
    
    // 3. Setup global error handlers
    setupGlobalErrorHandlers();
    
    // 4. Setup IPC event listeners
    setupIpcEventListeners();
    
    // 5. Setup performance monitoring
    setupPerformanceMonitoring();
    
    // 6. Setup cleanup handlers
    setupCleanup();
    
    // 7. Render application
    await renderApplication();
    
    rendererLogger.info('Application bootstrap completed successfully');
    
  } catch (error) {
    rendererLogger.error('Application bootstrap failed', error as Error);
    
    // Show error to user
    const errorScreen = document.getElementById('errorScreen');
    const errorTitle = document.getElementById('errorTitle');
    const errorMessage = document.getElementById('errorMessage');
    
    if (errorScreen && errorTitle && errorMessage) {
      errorTitle.textContent = 'Bootstrap Failed';
      errorMessage.textContent = error instanceof Error ? error.message : 'Failed to start application';
      errorScreen.style.display = 'flex';
    }
    
    // Re-throw for debugging
    throw error;
  }
}

// ==================== DEBUG UTILITIES ====================

// Expose debug utilities in development
if (process.env.NODE_ENV === 'development') {
  (window as any).__KNOUX_DEBUG = {
    ...(window.__KNOUX_DEBUG || {}),
    reloadApp: () => {
      if (window.knoux && window.knoux.restartApp) {
        window.knoux.restartApp();
      }
    },
    getState: () => store.getState(),
    getLogs: () => {
      // Return recent logs (simplified)
      return [];
    },
    testError: () => {
      throw new Error('Test error from debug utilities');
    },
  };
}

// ==================== START APPLICATION ====================

// Start application when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', bootstrap);
} else {
  bootstrap();
}

// Export for potential module usage
export { bootstrap };
export default bootstrap;
