/**
 * Knoux Clipboard AI - Clipboard Item Component
 * Individual clipboard history item display and interactions
 * Generated by Knoux — Abu Retaj
 * Clipboard Intelligence • Desktop Precision • Premium Engineering
 */

import React, { useState, useCallback, useMemo } from 'react';
import styled from 'styled-components';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  Copy, 
  Star, 
  Trash2, 
  Eye, 
  EyeOff,
  Lock, 
  AlertCircle,
  Code,
  FileText,
  Link,
  Mail,
  Terminal,
  Image,
  ChevronRight,
  Check,
  MoreVertical,
  Clock,
  Tag,
  Sparkles
} from 'lucide-react';

// Types
import { ClipboardItem, ContentClassification } from '../../shared/types';
import { ContentCategory, ProgrammingLanguage } from '../../shared/enums';

// Sub-components
import { Badge } from './Badge';
import { Tooltip } from './Tooltip';
import { ContextMenu } from './ContextMenu';

// ==================== STYLED COMPONENTS ====================

const ItemContainer = styled.div<{ 
  isSelected: boolean; 
  isSensitive: boolean;
  isDeleting: boolean;
}>`
  display: flex;
  flex-direction: column;
  padding: 1rem;
  border-radius: 8px;
  background: ${props => {
    if (props.isSelected) return props.theme.colors.primary}10;
    if (props.isSensitive) return props.theme.colors.warning}10;
    if (props.isDeleting) return props.theme.colors.error}10;
    return props.theme.colors.background.primary;
  }};
  border: 1px solid ${props => {
    if (props.isSelected) return props.theme.colors.primary;
    if (props.isSensitive) return props.theme.colors.warning;
    if (props.isDeleting) return props.theme.colors.error;
    return props.theme.colors.border;
  }};
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
  overflow: hidden;
  
  &:hover {
    transform: translateY(-2px);
    box-shadow: ${props => props.theme.shadows.medium};
    border-color: ${props => props.theme.colors.primary};
    
    .item-actions {
      opacity: 1;
      transform: translateX(0);
    }
  }
  
  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 4px;
    height: 100%;
    background: ${props => {
      if (props.isSelected) return props.theme.colors.primary;
      if (props.isSensitive) return props.theme.colors.warning;
      return 'transparent';
    }};
    transition: background 0.2s ease;
  }
`;

const ItemHeader = styled.div`
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  margin-bottom: 0.75rem;
  gap: 0.75rem;
`;

const ContentPreview = styled.div`
  flex: 1;
  min-width: 0;
`;

const ContentText = styled.div`
  font-family: ${props => {
    if (props['data-language'] === 'code') return "'JetBrains Mono', monospace";
    return "'Inter', sans-serif";
  }};
  font-size: 0.9375rem;
  line-height: 1.5;
  color: ${props => props.theme.colors.text.primary};
  margin-bottom: 0.5rem;
  white-space: pre-wrap;
  word-break: break-word;
  max-height: 4.5em;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  
  .sensitive {
    background: ${props => props.theme.colors.warning}20;
    color: ${props => props.theme.colors.warning};
    padding: 0.125rem 0.25rem;
    border-radius: 4px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.875em;
  }
  
  .highlight {
    background: ${props => props.theme.colors.primary}20;
    color: ${props => props.theme.colors.primary};
    padding: 0.125rem 0.25rem;
    border-radius: 4px;
  }
`;

const Metadata = styled.div`
  display: flex;
  align-items: center;
  gap: 0.75rem;
  font-size: 0.8125rem;
  color: ${props => props.theme.colors.text.secondary};
  flex-wrap: wrap;
`;

const MetadataItem = styled.div`
  display: flex;
  align-items: center;
  gap: 0.375rem;
  
  svg {
    width: 0.875rem;
    height: 0.875rem;
    opacity: 0.7;
  }
`;

const TypeBadge = styled.div<{ type: string }>`
  display: flex;
  align-items: center;
  gap: 0.375rem;
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  font-size: 0.75rem;
  font-weight: 500;
  background: ${props => {
    switch (props.type) {
      case ContentCategory.CODE: return props.theme.colors.primary}20;
      case ContentCategory.TEXT: return props.theme.colors.info}20;
      case 'sensitive': return props.theme.colors.warning}20;
      case 'url': return props.theme.colors.success}20;
      default: return props.theme.colors.background.secondary;
    }
  }};
  color: ${props => {
    switch (props.type) {
      case ContentCategory.CODE: return props.theme.colors.primary;
      case ContentCategory.TEXT: return props.theme.colors.info;
      case 'sensitive': return props.theme.colors.warning;
      case 'url': return props.theme.colors.success;
      default: return props.theme.colors.text.secondary;
    }
  }};
  border: 1px solid ${props => {
    switch (props.type) {
      case ContentCategory.CODE: return props.theme.colors.primary}40;
      case ContentCategory.TEXT: return props.theme.colors.info}40;
      case 'sensitive': return props.theme.colors.warning}40;
      case 'url': return props.theme.colors.success}40;
      default: return props.theme.colors.border;
    }
  }};
`;

const ActionsContainer = styled.div`
  display: flex;
  align-items: center;
  gap: 0.5rem;
  opacity: 0;
  transform: translateX(10px);
  transition: all 0.2s ease;
  
  @media (max-width: 768px) {
    opacity: 1;
    transform: translateX(0);
  }
`;

const ActionButton = styled.button<{ variant?: 'primary' | 'danger' | 'warning' }>`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  border-radius: 6px;
  border: 1px solid ${props => {
    switch (props.variant) {
      case 'danger': return props.theme.colors.error}40;
      case 'warning': return props.theme.colors.warning}40;
      default: return props.theme.colors.border;
    }
  }};
  background: ${props => {
    switch (props.variant) {
      case 'danger': return props.theme.colors.error}10;
      case 'warning': return props.theme.colors.warning}10;
      default: return props.theme.colors.background.primary;
    }
  }};
  color: ${props => {
    switch (props.variant) {
      case 'danger': return props.theme.colors.error;
      case 'warning': return props.theme.colors.warning;
      default: return props.theme.colors.text.primary;
    }
  }};
  cursor: pointer;
  transition: all 0.2s ease;
  
  &:hover {
    transform: translateY(-2px);
    border-color: ${props => {
      switch (props.variant) {
        case 'danger': return props.theme.colors.error;
        case 'warning': return props.theme.colors.warning;
        default: return props.theme.colors.primary;
      }
    }};
    background: ${props => {
      switch (props.variant) {
        case 'danger': return props.theme.colors.error}20;
        case 'warning': return props.theme.colors.warning}20;
        default: return props.theme.colors.primary}10;
    }};
    color: ${props => {
      switch (props.variant) {
        case 'danger': return props.theme.colors.error;
        case 'warning': return props.theme.colors.warning;
        default: return props.theme.colors.primary;
      }
    }};
  }
  
  &:active {
    transform: translateY(0);
  }
  
  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }
  
  svg {
    width: 16px;
    height: 16px;
  }
`;

const TagsContainer = styled.div`
  display: flex;
  flex-wrap: wrap;
  gap: 0.375rem;
  margin-top: 0.75rem;
`;

const TagItem = styled.div`
  display: flex;
  align-items: center;
  gap: 0.25rem;
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  font-size: 0.75rem;
  background: ${props => props.theme.colors.background.secondary};
  color: ${props => props.theme.colors.text.secondary};
  border: 1px solid ${props => props.theme.colors.border};
  
  svg {
    width: 10px;
    height: 10px;
    opacity: 0.7;
  }
`;

const AIIndicator = styled.div<{ hasAnalysis: boolean }>`
  display: flex;
  align-items: center;
  gap: 0.375rem;
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  font-size: 0.75rem;
  background: ${props => props.hasAnalysis ? props.theme.colors.success}20 : props.theme.colors.background.secondary};
  color: ${props => props.hasAnalysis ? props.theme.colors.success : props.theme.colors.text.secondary};
  border: 1px solid ${props => props.hasAnalysis ? props.theme.colors.success}40 : props.theme.colors.border};
  
  svg {
    width: 12px;
    height: 12px;
  }
`;

const SensitiveIndicator = styled.div`
  display: flex;
  align-items: center;
  gap: 0.375rem;
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  font-size: 0.75rem;
  background: ${props => props.theme.colors.warning}20;
  color: ${props => props.theme.colors.warning};
  border: 1px solid ${props => props.theme.colors.warning}40;
  
  svg {
    width: 12px;
    height: 12px;
  }
`;

const ExpandedContent = styled(motion.div)`
  margin-top: 1rem;
  padding-top: 1rem;
  border-top: 1px solid ${props => props.theme.colors.border};
`;

const ContentDetails = styled.div`
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.875rem;
  line-height: 1.6;
  background: ${props => props.theme.colors.background.secondary};
  border-radius: 6px;
  padding: 1rem;
  overflow-x: auto;
  max-height: 300px;
  overflow-y: auto;
  
  pre {
    margin: 0;
    white-space: pre-wrap;
    word-break: break-word;
  }
  
  code {
    font-family: inherit;
    font-size: inherit;
  }
  
  .line-number {
    color: ${props => props.theme.colors.text.tertiary};
    margin-right: 1rem;
    user-select: none;
  }
  
  .highlight {
    background: ${props => props.theme.colors.primary}20;
    color: ${props => props.theme.colors.primary};
    padding: 0.125rem 0.25rem;
    border-radius: 2px;
  }
`;

const ContextMenuTrigger = styled.div`
  position: absolute;
  top: 0.5rem;
  right: 0.5rem;
  opacity: 0;
  transition: opacity 0.2s ease;
  
  ${ItemContainer}:hover & {
    opacity: 1;
  }
`;

// ==================== UTILITY FUNCTIONS ====================

/**
 * Get icon for content type
 */
function getContentTypeIcon(type: string | undefined) {
  switch (type) {
    case ContentCategory.CODE:
      return <Code size={12} />;
    case 'url':
      return <Link size={12} />;
    case 'email':
      return <Mail size={12} />;
    case 'command':
      return <Terminal size={12} />;
    case 'image':
      return <Image size={12} />;
    case 'sensitive':
      return <Lock size={12} />;
    default:
      return <FileText size={12} />;
  }
}

/**
 * Format content for preview
 */
function formatContentPreview(content: string, maxLength: number = 200): string {
  if (content.length <= maxLength) {
    return content;
  }
  
  // Try to cut at a word boundary
  const trimmed = content.substring(0, maxLength);
  const lastSpace = trimmed.lastIndexOf(' ');
  
  if (lastSpace > maxLength * 0.7) {
    return trimmed.substring(0, lastSpace) + '...';
  }
  
  return trimmed + '...';
}

/**
 * Mask sensitive content
 */
function maskSensitiveContent(content: string, isSensitive: boolean): string {
  if (!isSensitive) {
    return content;
  }
  
  // Simple masking - in production this would use more sophisticated pattern matching
  return content.replace(/./g, '•');
}

/**
 * Format timestamp
 */
function formatTimestamp(timestamp: number): string {
  const date = new Date(timestamp);
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  
  // Less than 1 minute
  if (diffMs < 60000) {
    return 'Just now';
  }
  
  // Less than 1 hour
  if (diffMs < 3600000) {
    const minutes = Math.floor(diffMs / 60000);
    return `${minutes}m ago`;
  }
  
  // Less than 1 day
  if (diffMs < 86400000) {
    const hours = Math.floor(diffMs / 3600000);
    return `${hours}h ago`;
  }
  
  // Less than 1 week
  if (diffMs < 604800000) {
    const days = Math.floor(diffMs / 86400000);
    return `${days}d ago`;
  }
  
  // Return full date
  return date.toLocaleDateString();
}

/**
 * Get programming language name from classification
 */
function getLanguageName(classification?: ContentClassification): string {
  if (!classification?.language) {
    return 'Unknown';
  }
  
  const langMap: Record<string, string> = {
    [ProgrammingLanguage.JAVASCRIPT]: 'JavaScript',
    [ProgrammingLanguage.TYPESCRIPT]: 'TypeScript',
    [ProgrammingLanguage.PYTHON]: 'Python',
    [ProgrammingLanguage.JAVA]: 'Java',
    [ProgrammingLanguage.CSHARP]: 'C#',
    [ProgrammingLanguage.CPP]: 'C++',
    [ProgrammingLanguage.C]: 'C',
    [ProgrammingLanguage.GO]: 'Go',
    [ProgrammingLanguage.RUST]: 'Rust',
    [ProgrammingLanguage.PHP]: 'PHP',
    [ProgrammingLanguage.RUBY]: 'Ruby',
    [ProgrammingLanguage.SWIFT]: 'Swift',
    [ProgrammingLanguage.KOTLIN]: 'Kotlin',
    [ProgrammingLanguage.DART]: 'Dart',
    [ProgrammingLanguage.POWERSHELL]: 'PowerShell',
    [ProgrammingLanguage.BASH]: 'Bash',
    [ProgrammingLanguage.SQL]: 'SQL',
    [ProgrammingLanguage.HTML]: 'HTML',
    [ProgrammingLanguage.CSS]: 'CSS',
    [ProgrammingLanguage.JSON]: 'JSON',
    [ProgrammingLanguage.YAML]: 'YAML',
    [ProgrammingLanguage.XML]: 'XML',
    [ProgrammingLanguage.MARKDOWN]: 'Markdown',
  };
  
  return langMap[classification.language] || classification.language;
}

// ==================== MAIN COMPONENT ====================

interface ClipboardItemProps {
  item: ClipboardItem;
  isSelected: boolean;
  isDeleting: boolean;
  onClick: (item: ClipboardItem) => void;
  onCopy: (item: ClipboardItem) => Promise<void>;
  onDelete: (itemId: string) => Promise<void>;
  onFavorite: (itemId: string, favorite: boolean) => Promise<void>;
  onTagAdd?: (itemId: string, tag: string) => Promise<void>;
  onTagRemove?: (itemId: string, tag: string) => Promise<void>;
  className?: string;
}

export const ClipboardItemComponent: React.FC<ClipboardItemProps> = ({
  item,
  isSelected,
  isDeleting,
  onClick,
  onCopy,
  onDelete,
  onFavorite,
  onTagAdd,
  onTagRemove,
  className
}) => {
  // State
  const [isExpanded, setIsExpanded] = useState(false);
  const [isCopying, setIsCopying] = useState(false);
  const [isFavoriting, setIsFavoriting] = useState(false);
  const [showContextMenu, setShowContextMenu] = useState(false);
  const [showSensitiveContent, setShowSensitiveContent] = useState(false);
  
  // Memoized values
  const isFavorite = useMemo(() => item.metadata?.isFavorite || false, [item.metadata]);
  const contentType = useMemo(() => item.classifiedType?.primaryType || 'text', [item.classifiedType]);
  const languageName = useMemo(() => getLanguageName(item.classifiedType), [item.classifiedType]);
  const hasAI = useMemo(() => !!item.aiAnalysis, [item.aiAnalysis]);
  const isCode = useMemo(() => contentType === ContentCategory.CODE, [contentType]);
  
  const displayContent = useMemo(() => {
    if (item.isSensitive && !showSensitiveContent) {
      return maskSensitiveContent(item.preview, true);
    }
    return formatContentPreview(item.content);
  }, [item.content, item.preview, item.isSensitive, showSensitiveContent]);
  
  const formattedTime = useMemo(() => formatTimestamp(item.timestamp), [item.timestamp]);
  
  // Event handlers
  const handleClick = useCallback(() => {
    onClick(item);
  }, [item, onClick]);
  
  const handleCopy = useCallback(async () => {
    try {
      setIsCopying(true);
      await onCopy(item);
      
      // Show temporary success feedback
      setTimeout(() => setIsCopying(false), 1000);
    } catch (error) {
      setIsCopying(false);
      console.error('Failed to copy item:', error);
    }
  }, [item, onCopy]);
  
  const handleFavorite = useCallback(async () => {
    try {
      setIsFavoriting(true);
      await onFavorite(item.id, !isFavorite);
    } finally {
      setIsFavoriting(false);
    }
  }, [item.id, isFavorite, onFavorite]);
  
  const handleDelete = useCallback(() => {
    if (window.confirm('Are you sure you want to delete this item?')) {
      onDelete(item.id);
    }
  }, [item.id, onDelete]);
  
  const handleToggleExpand = useCallback(() => {
    setIsExpanded(!isExpanded);
  }, [isExpanded]);
  
  const handleToggleSensitiveContent = useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    setShowSensitiveContent(!showSensitiveContent);
  }, [showSensitiveContent]);
  
  const handleContextMenu = useCallback((e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setShowContextMenu(true);
  }, []);
  
  const handleContextMenuClose = useCallback(() => {
    setShowContextMenu(false);
  }, []);
  
  // Context menu items
  const contextMenuItems = useMemo(() => [
    {
      label: isFavorite ? 'Remove from Favorites' : 'Add to Favorites',
      icon: <Star size={14} />,
      onClick: handleFavorite,
      disabled: isFavoriting
    },
    {
      label: 'Copy',
      icon: <Copy size={14} />,
      onClick: handleCopy,
      disabled: isCopying
    },
    {
      label: 'Expand',
      icon: <ChevronRight size={14} />,
      onClick: handleToggleExpand
    },
    {
      label: 'divider'
    },
    {
      label: 'Analyze with AI',
      icon: <Sparkles size={14} />,
      onClick: () => console.log('Analyze with AI:', item.id)
    },
    {
      label: 'divider'
    },
    {
      label: 'Delete',
      icon: <Trash2 size={14} />,
      onClick: handleDelete,
      variant: 'danger' as const
    }
  ], [isFavorite, isFavoriting, isCopying, handleFavorite, handleCopy, handleToggleExpand, handleDelete, item.id]);
  
  // Render code with syntax highlighting
  const renderCodeContent = useCallback(() => {
    const lines = item.content.split('\n');
    
    return (
      <ContentDetails>
        <pre>
          {lines.map((line, index) => (
            <div key={index} style={{ display: 'flex' }}>
              <span className="line-number">{index + 1}</span>
              <code>{line}</code>
            </div>
          ))}
        </pre>
      </ContentDetails>
    );
  }, [item.content]);
  
  // Render regular text content
  const renderTextContent = useCallback(() => {
    return (
      <ContentDetails>
        <pre>{item.content}</pre>
      </ContentDetails>
    );
  }, [item.content]);
  
  return (
    <>
      <ItemContainer
        className={className}
        isSelected={isSelected}
        isSensitive={item.isSensitive}
        isDeleting={isDeleting}
        onClick={handleClick}
        onContextMenu={handleContextMenu}
      >
        {/* Context Menu Trigger */}
        <ContextMenuTrigger>
          <ActionButton onClick={(e) => { e.stopPropagation(); setShowContextMenu(true); }}>
            <MoreVertical size={16} />
          </ActionButton>
        </ContextMenuTrigger>
        
        {/* Header */}
        <ItemHeader>
          <ContentPreview>
            <ContentText 
              data-language={isCode ? 'code' : 'text'}
              dangerouslySetInnerHTML={{ 
                __html: displayContent.replace(/\n/g, '<br/>')
              }}
            />
            
            <Metadata>
              <MetadataItem>
                <Clock size={14} />
                <span>{formattedTime}</span>
              </MetadataItem>
              
              <TypeBadge type={contentType}>
                {getContentTypeIcon(contentType)}
                <span>
                  {isCode ? languageName : contentType}
                </span>
              </TypeBadge>
              
              {item.isSensitive && (
                <SensitiveIndicator>
                  <Lock size={12} />
                  <span>Sensitive</span>
                </SensitiveIndicator>
              )}
              
              {hasAI && (
                <AIIndicator hasAnalysis={hasAI}>
                  <Sparkles size={12} />
                  <span>AI Analyzed</span>
                </AIIndicator>
              )}
              
              {item.sizeBytes && (
                <MetadataItem>
                  <span>{Math.ceil(item.sizeBytes / 1024)} KB</span>
                </MetadataItem>
              )}
              
              {item.sourceApp && (
                <MetadataItem>
                  <span>From: {item.sourceApp}</span>
                </MetadataItem>
              )}
            </Metadata>
          </ContentPreview>
          
          <ActionsContainer className="item-actions">
            {item.isSensitive && (
              <Tooltip content={showSensitiveContent ? "Hide sensitive content" : "Show sensitive content"}>
                <ActionButton 
                  variant="warning"
                  onClick={handleToggleSensitiveContent}
                >
                  {showSensitiveContent ? <EyeOff size={16} /> : <Eye size={16} />}
                </ActionButton>
              </Tooltip>
            )}
            
            <Tooltip content={isFavorite ? "Remove from favorites" : "Add to favorites"}>
              <ActionButton 
                onClick={handleFavorite}
                disabled={isFavoriting}
                variant={isFavorite ? 'primary' : undefined}
              >
                {isFavorite ? <Star size={16} fill="currentColor" /> : <Star size={16} />}
              </ActionButton>
            </Tooltip>
            
            <Tooltip content="Copy to clipboard">
              <ActionButton 
                onClick={handleCopy}
                disabled={isCopying}
              >
                {isCopying ? <Check size={16} /> : <Copy size={16} />}
              </ActionButton>
            </Tooltip>
            
            <Tooltip content="Delete item">
              <ActionButton 
                variant="danger"
                onClick={handleDelete}
                disabled={isDeleting}
              >
                <Trash2 size={16} />
              </ActionButton>
            </Tooltip>
          </ActionsContainer>
        </ItemHeader>
        
        {/* Tags */}
        {item.tags.length > 0 && (
          <TagsContainer>
            <Tag size={12} opacity={0.7} />
            {item.tags.map(tag => (
              <TagItem key={tag}>
                {tag}
              </TagItem>
            ))}
          </TagsContainer>
        )}
        
        {/* Expanded Content */}
        <AnimatePresence>
          {isExpanded && (
            <ExpandedContent
              initial={{ height: 0, opacity: 0 }}
              animate={{ height: 'auto', opacity: 1 }}
              exit={{ height: 0, opacity: 0 }}
              transition={{ duration: 0.2 }}
            >
              {isCode ? renderCodeContent() : renderTextContent()}
            </ExpandedContent>
          )}
        </AnimatePresence>
      </ItemContainer>
      
      {/* Context Menu */}
      <ContextMenu
        isOpen={showContextMenu}
        onClose={handleContextMenuClose}
        items={contextMenuItems}
        position="fixed"
      />
    </>
  );
};

// ==================== EXPORT ====================

export default ClipboardItemComponent;

// Performance optimization
export const MemoizedClipboardItem = React.memo(ClipboardItemComponent);
