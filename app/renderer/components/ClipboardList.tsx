/**
 * Knoux Clipboard AI - Clipboard List Component
 * Displays and manages the list of clipboard history items
 * Generated by Knoux — Abu Retaj
 * Clipboard Intelligence • Desktop Precision • Premium Engineering
 */

import React, { useState, useMemo, useCallback, useEffect } from 'react';
import styled from 'styled-components';
import { FixedSizeList as List } from 'react-window';
import AutoSizer from 'react-virtualized-auto-sizer';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  Search, 
  Filter, 
  Clock, 
  Star, 
  Copy, 
  Trash2, 
  Eye, 
  EyeOff,
  ChevronDown,
  ChevronUp,
  Code,
  FileText,
  Lock,
  AlertCircle
} from 'lucide-react';

// Types
import { ClipboardItem, ContentClassification } from '../../shared/types';
import { ContentCategory, ProgrammingLanguage } from '../../shared/enums';

// Sub-components
import { ClipboardItemComponent } from './ClipboardItem';
import { EmptyState } from './EmptyState';
import { LoadingSpinner } from './LoadingSpinner';

// ==================== STYLED COMPONENTS ====================

const Container = styled.div`
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
  background: ${props => props.theme.colors.background.primary};
  overflow: hidden;
`;

const Toolbar = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.5rem;
  border-bottom: 1px solid ${props => props.theme.colors.border};
  background: ${props => props.theme.colors.background.secondary};
  flex-shrink: 0;
  gap: 1rem;
`;

const SearchContainer = styled.div`
  flex: 1;
  max-width: 400px;
  position: relative;
`;

const SearchInput = styled.input`
  width: 100%;
  padding: 0.75rem 1rem 0.75rem 2.75rem;
  border: 1px solid ${props => props.theme.colors.border};
  border-radius: 8px;
  background: ${props => props.theme.colors.background.primary};
  color: ${props => props.theme.colors.text.primary};
  font-size: 0.95rem;
  transition: all 0.2s ease;
  
  &:focus {
    outline: none;
    border-color: ${props => props.theme.colors.primary};
    box-shadow: 0 0 0 3px ${props => props.theme.colors.primary}20;
  }
  
  &::placeholder {
    color: ${props => props.theme.colors.text.tertiary};
  }
`;

const SearchIcon = styled(Search)`
  position: absolute;
  left: 0.875rem;
  top: 50%;
  transform: translateY(-50%);
  color: ${props => props.theme.colors.text.tertiary};
  width: 1.125rem;
  height: 1.125rem;
`;

const FilterControls = styled.div`
  display: flex;
  align-items: center;
  gap: 0.75rem;
`;

const FilterButton = styled.button<{ active?: boolean }>`
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.625rem 1rem;
  border: 1px solid ${props => props.active ? props.theme.colors.primary : props.theme.colors.border};
  border-radius: 8px;
  background: ${props => props.active ? props.theme.colors.primary : props.theme.colors.background.primary};
  color: ${props => props.active ? 'white' : props.theme.colors.text.primary};
  font-size: 0.875rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  
  &:hover {
    border-color: ${props => props.theme.colors.primary};
    background: ${props => props.active ? props.theme.colors.primaryDark : props.theme.colors.background.secondary};
  }
  
  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;

const ActionButton = styled.button`
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.625rem 1rem;
  border: 1px solid ${props => props.theme.colors.border};
  border-radius: 8px;
  background: ${props => props.theme.colors.background.primary};
  color: ${props => props.theme.colors.text.primary};
  font-size: 0.875rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  
  &:hover {
    border-color: ${props => props.theme.colors.error};
    background: ${props => props.theme.colors.error}10;
    color: ${props => props.theme.colors.error};
  }
  
  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;

const StatsBar = styled.div`
  display: flex;
  align-items: center;
  gap: 1.5rem;
  font-size: 0.875rem;
  color: ${props => props.theme.colors.text.secondary};
`;

const StatItem = styled.div`
  display: flex;
  align-items: center;
  gap: 0.375rem;
`;

const ContentArea = styled.div`
  flex: 1;
  overflow: hidden;
  position: relative;
`;

const ListContainer = styled.div`
  height: 100%;
  width: 100%;
`;

const ItemRow = styled.div<{ isSelected: boolean; isSensitive: boolean }>`
  padding: 0.75rem 1.5rem;
  border-bottom: 1px solid ${props => props.theme.colors.border};
  background: ${props => {
    if (props.isSelected) return props.theme.colors.primary}10;
    if (props.isSensitive) return props.theme.colors.warning}10;
    return 'transparent';
  }};
  cursor: pointer;
  transition: all 0.2s ease;
  
  &:hover {
    background: ${props => props.theme.colors.background.secondary};
  }
  
  &:last-child {
    border-bottom: none;
  }
`;

const EmptyContainer = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  padding: 2rem;
`;

const LoadingContainer = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  padding: 2rem;
`;

const FilterPanel = styled(motion.div)`
  position: absolute;
  top: 100%;
  right: 0;
  margin-top: 0.5rem;
  background: ${props => props.theme.colors.background.secondary};
  border: 1px solid ${props => props.theme.colors.border};
  border-radius: 8px;
  padding: 1rem;
  min-width: 250px;
  box-shadow: ${props => props.theme.shadows.large};
  z-index: 1000;
`;

const FilterGroup = styled.div`
  margin-bottom: 1rem;
  
  &:last-child {
    margin-bottom: 0;
  }
`;

const FilterGroupTitle = styled.h4`
  font-size: 0.875rem;
  font-weight: 600;
  margin-bottom: 0.5rem;
  color: ${props => props.theme.colors.text.primary};
`;

const FilterOptions = styled.div`
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
`;

const FilterOption = styled.button<{ active: boolean }>`
  padding: 0.375rem 0.75rem;
  border: 1px solid ${props => props.active ? props.theme.colors.primary : props.theme.colors.border};
  border-radius: 6px;
  background: ${props => props.active ? props.theme.colors.primary : props.theme.colors.background.primary};
  color: ${props => props.active ? 'white' : props.theme.colors.text.primary};
  font-size: 0.8125rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  
  &:hover {
    border-color: ${props => props.theme.colors.primary};
    background: ${props => props.active ? props.theme.colors.primaryDark : props.theme.colors.background.secondary};
  }
`;

const DateRangeFilter = styled.div`
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin-top: 0.5rem;
`;

const DateInput = styled.input`
  flex: 1;
  padding: 0.375rem 0.75rem;
  border: 1px solid ${props => props.theme.colors.border};
  border-radius: 6px;
  background: ${props => props.theme.colors.background.primary};
  color: ${props => props.theme.colors.text.primary};
  font-size: 0.8125rem;
  
  &:focus {
    outline: none;
    border-color: ${props => props.theme.colors.primary};
  }
`;

// ==================== TYPES ====================

interface ClipboardListProps {
  items: ClipboardItem[];
  selectedItemId?: string;
  onItemSelect: (item: ClipboardItem) => void;
  onItemDelete: (itemId: string) => Promise<void>;
  onItemFavorite: (itemId: string, favorite: boolean) => Promise<void>;
  onItemCopy: (item: ClipboardItem) => Promise<void>;
  onClearAll: () => Promise<void>;
  isLoading?: boolean;
  className?: string;
}

interface FilterState {
  searchQuery: string;
  contentType: string | null;
  dateRange: {
    start: Date | null;
    end: Date | null;
  };
  showSensitiveOnly: boolean;
  showFavoritesOnly: boolean;
  showWithAIOnly: boolean;
  tags: string[];
}

// ==================== UTILITY FUNCTIONS ====================

/**
 * Filter items based on filter state
 */
function filterItems(items: ClipboardItem[], filters: FilterState): ClipboardItem[] {
  return items.filter(item => {
    // Search query filter
    if (filters.searchQuery) {
      const query = filters.searchQuery.toLowerCase();
      const matchesContent = item.content.toLowerCase().includes(query);
      const matchesPreview = item.preview.toLowerCase().includes(query);
      const matchesTags = item.tags.some(tag => tag.toLowerCase().includes(query));
      const matchesSource = item.sourceApp?.toLowerCase().includes(query);
      
      if (!matchesContent && !matchesPreview && !matchesTags && !matchesSource) {
        return false;
      }
    }
    
    // Content type filter
    if (filters.contentType && item.classifiedType?.primaryType !== filters.contentType) {
      return false;
    }
    
    // Date range filter
    if (filters.dateRange.start || filters.dateRange.end) {
      const itemDate = new Date(item.timestamp);
      
      if (filters.dateRange.start && itemDate < filters.dateRange.start) {
        return false;
      }
      
      if (filters.dateRange.end && itemDate > filters.dateRange.end) {
        return false;
      }
    }
    
    // Sensitive only filter
    if (filters.showSensitiveOnly && !item.isSensitive) {
      return false;
    }
    
    // Favorites only filter
    if (filters.showFavoritesOnly && !item.metadata?.isFavorite) {
      return false;
    }
    
    // AI analysis only filter
    if (filters.showWithAIOnly && !item.aiAnalysis) {
      return false;
    }
    
    // Tags filter
    if (filters.tags.length > 0) {
      const itemTags = item.tags.map(tag => tag.toLowerCase());
      const filterTags = filters.tags.map(tag => tag.toLowerCase());
      
      if (!filterTags.some(tag => itemTags.includes(tag))) {
        return false;
      }
    }
    
    return true;
  });
}

/**
 * Sort items based on timestamp (newest first)
 */
function sortItems(items: ClipboardItem[]): ClipboardItem[] {
  return [...items].sort((a, b) => b.timestamp - a.timestamp);
}

/**
 * Get unique content types from items
 */
function getContentTypes(items: ClipboardItem[]): string[] {
  const types = new Set<string>();
  
  items.forEach(item => {
    if (item.classifiedType?.primaryType) {
      types.add(item.classifiedType.primaryType);
    }
  });
  
  return Array.from(types).sort();
}

/**
 * Get unique tags from items
 */
function getUniqueTags(items: ClipboardItem[]): string[] {
  const tags = new Set<string>();
  
  items.forEach(item => {
    item.tags.forEach(tag => tags.add(tag));
  });
  
  return Array.from(tags).sort();
}

/**
 * Get icon for content type
 */
function getContentTypeIcon(type: string | undefined) {
  switch (type) {
    case ContentCategory.CODE:
      return <Code size={14} />;
    case ContentCategory.TEXT:
      return <FileText size={14} />;
    case 'sensitive':
      return <Lock size={14} />;
    case 'error':
      return <AlertCircle size={14} />;
    default:
      return <FileText size={14} />;
  }
}

/**
 * Format date for display
 */
function formatDate(timestamp: number): string {
  const date = new Date(timestamp);
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffMins = Math.floor(diffMs / 60000);
  const diffHours = Math.floor(diffMs / 3600000);
  const diffDays = Math.floor(diffMs / 86400000);
  
  if (diffMins < 1) return 'Just now';
  if (diffMins < 60) return `${diffMins}m ago`;
  if (diffHours < 24) return `${diffHours}h ago`;
  if (diffDays < 7) return `${diffDays}d ago`;
  
  return date.toLocaleDateString();
}

// ==================== MAIN COMPONENT ====================

export const ClipboardList: React.FC<ClipboardListProps> = ({
  items,
  selectedItemId,
  onItemSelect,
  onItemDelete,
  onItemFavorite,
  onItemCopy,
  onClearAll,
  isLoading = false,
  className
}) => {
  // State
  const [filters, setFilters] = useState<FilterState>({
    searchQuery: '',
    contentType: null,
    dateRange: {
      start: null,
      end: null
    },
    showSensitiveOnly: false,
    showFavoritesOnly: false,
    showWithAIOnly: false,
    tags: []
  });
  
  const [showFilterPanel, setShowFilterPanel] = useState(false);
  const [deletingItems, setDeletingItems] = useState<Set<string>>(new Set());
  
  // Memoized data
  const filteredItems = useMemo(() => {
    const filtered = filterItems(items, filters);
    return sortItems(filtered);
  }, [items, filters]);
  
  const contentTypes = useMemo(() => getContentTypes(items), [items]);
  const uniqueTags = useMemo(() => getUniqueTags(items), [items]);
  
  const stats = useMemo(() => {
    const total = items.length;
    const filtered = filteredItems.length;
    const sensitive = items.filter(item => item.isSensitive).length;
    const favorites = items.filter(item => item.metadata?.isFavorite).length;
    const withAI = items.filter(item => item.aiAnalysis).length;
    
    return { total, filtered, sensitive, favorites, withAI };
  }, [items, filteredItems]);
  
  // Event handlers
  const handleSearchChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setFilters(prev => ({ ...prev, searchQuery: e.target.value }));
  }, []);
  
  const handleContentTypeFilter = useCallback((type: string | null) => {
    setFilters(prev => ({ ...prev, contentType: type === prev.contentType ? null : type }));
  }, []);
  
  const handleSensitiveFilter = useCallback(() => {
    setFilters(prev => ({ ...prev, showSensitiveOnly: !prev.showSensitiveOnly }));
  }, []);
  
  const handleFavoritesFilter = useCallback(() => {
    setFilters(prev => ({ ...prev, showFavoritesOnly: !prev.showFavoritesOnly }));
  }, []);
  
  const handleAIFilter = useCallback(() => {
    setFilters(prev => ({ ...prev, showWithAIOnly: !prev.showWithAIOnly }));
  }, []);
  
  const handleTagFilter = useCallback((tag: string) => {
    setFilters(prev => {
      const newTags = prev.tags.includes(tag)
        ? prev.tags.filter(t => t !== tag)
        : [...prev.tags, tag];
      
      return { ...prev, tags: newTags };
    });
  }, []);
  
  const handleClearFilters = useCallback(() => {
    setFilters({
      searchQuery: '',
      contentType: null,
      dateRange: { start: null, end: null },
      showSensitiveOnly: false,
      showFavoritesOnly: false,
      showWithAIOnly: false,
      tags: []
    });
  }, []);
  
  const handleDateRangeChange = useCallback((type: 'start' | 'end', value: string) => {
    setFilters(prev => ({
      ...prev,
      dateRange: {
        ...prev.dateRange,
        [type]: value ? new Date(value) : null
      }
    }));
  }, []);
  
  const handleItemDelete = useCallback(async (itemId: string) => {
    try {
      setDeletingItems(prev => new Set(prev).add(itemId));
      await onItemDelete(itemId);
    } finally {
      setDeletingItems(prev => {
        const next = new Set(prev);
        next.delete(itemId);
        return next;
      });
    }
  }, [onItemDelete]);
  
  const handleClearAll = useCallback(async () => {
    if (window.confirm('Are you sure you want to clear all clipboard history? This cannot be undone.')) {
      await onClearAll();
    }
  }, [onClearAll]);
  
  const handleItemClick = useCallback((item: ClipboardItem) => {
    onItemSelect(item);
  }, [onItemSelect]);
  
  const handleItemCopy = useCallback(async (item: ClipboardItem) => {
    await onItemCopy(item);
  }, [onItemCopy]);
  
  const handleItemFavorite = useCallback(async (itemId: string, favorite: boolean) => {
    await onItemFavorite(itemId, favorite);
  }, [onItemFavorite]);
  
  // Virtualized list row renderer
  const Row = useCallback(({ index, style }: { index: number; style: React.CSSProperties }) => {
    const item = filteredItems[index];
    const isSelected = selectedItemId === item.id;
    const isDeleting = deletingItems.has(item.id);
    
    return (
      <div style={style}>
        <ClipboardItemComponent
          item={item}
          isSelected={isSelected}
          isDeleting={isDeleting}
          onClick={() => handleItemClick(item)}
          onCopy={() => handleItemCopy(item)}
          onDelete={() => handleItemDelete(item.id)}
          onFavorite={(favorite) => handleItemFavorite(item.id, favorite)}
        />
      </div>
    );
  }, [filteredItems, selectedItemId, deletingItems, handleItemClick, handleItemCopy, handleItemDelete, handleItemFavorite]);
  
  // Render loading state
  if (isLoading) {
    return (
      <Container className={className}>
        <Toolbar>
          <div style={{ flex: 1 }} />
          <LoadingSpinner size={20} />
        </Toolbar>
        <LoadingContainer>
          <LoadingSpinner size={40} message="Loading clipboard history..." />
        </LoadingContainer>
      </Container>
    );
  }
  
  // Render empty state
  if (items.length === 0) {
    return (
      <Container className={className}>
        <Toolbar>
          <div style={{ flex: 1 }} />
        </Toolbar>
        <EmptyContainer>
          <EmptyState
            icon={<Copy size={48} />}
            title="No clipboard items yet"
            description="Copy something to get started. Knoux will automatically capture and analyze it."
            actionLabel="Learn more"
            onAction={() => window.open('https://docs.knoux.ai', '_blank')}
          />
        </EmptyContainer>
      </Container>
    );
  }
  
  return (
    <Container className={className}>
      {/* Toolbar */}
      <Toolbar>
        <SearchContainer>
          <SearchIcon />
          <SearchInput
            type="text"
            placeholder="Search clipboard history..."
            value={filters.searchQuery}
            onChange={handleSearchChange}
          />
        </SearchContainer>
        
        <FilterControls>
          <FilterButton
            active={showFilterPanel}
            onClick={() => setShowFilterPanel(!showFilterPanel)}
          >
            <Filter size={16} />
            Filters
            {Object.values(filters).some(filter => 
              Array.isArray(filter) ? filter.length > 0 : 
              filter && typeof filter === 'object' ? 
                Object.values(filter).some(Boolean) : 
                Boolean(filter)
            ) && (
              <span style={{
                width: 6,
                height: 6,
                borderRadius: '50%',
                background: '#667eea',
                marginLeft: 4
              }} />
            )}
          </FilterButton>
          
          <ActionButton onClick={handleClearAll} disabled={items.length === 0}>
            <Trash2 size={16} />
            Clear All
          </ActionButton>
        </FilterControls>
        
        <StatsBar>
          <StatItem>
            <Clock size={14} />
            <span>{stats.total} total</span>
          </StatItem>
          <StatItem>
            <Eye size={14} />
            <span>{stats.filtered} shown</span>
          </StatItem>
          {stats.sensitive > 0 && (
            <StatItem>
              <Lock size={14} />
              <span>{stats.sensitive} sensitive</span>
            </StatItem>
          )}
          {stats.favorites > 0 && (
            <StatItem>
              <Star size={14} />
              <span>{stats.favorites} favorites</span>
            </StatItem>
          )}
        </StatsBar>
      </Toolbar>
      
      {/* Filter Panel */}
      <AnimatePresence>
        {showFilterPanel && (
          <FilterPanel
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            transition={{ duration: 0.2 }}
          >
            <FilterGroup>
              <FilterGroupTitle>Content Type</FilterGroupTitle>
              <FilterOptions>
                {contentTypes.map(type => (
                  <FilterOption
                    key={type}
                    active={filters.contentType === type}
                    onClick={() => handleContentTypeFilter(type)}
                  >
                    {getContentTypeIcon(type)}
                    {type}
                  </FilterOption>
                ))}
                {filters.contentType && (
                  <FilterOption
                    active={false}
                    onClick={() => handleContentTypeFilter(null)}
                    style={{ background: 'transparent', border: '1px dashed' }}
                  >
                    Clear
                  </FilterOption>
                )}
              </FilterOptions>
            </FilterGroup>
            
            <FilterGroup>
              <FilterGroupTitle>Quick Filters</FilterGroupTitle>
              <FilterOptions>
                <FilterOption
                  active={filters.showSensitiveOnly}
                  onClick={handleSensitiveFilter}
                >
                  <Lock size={12} />
                  Sensitive Only
                </FilterOption>
                <FilterOption
                  active={filters.showFavoritesOnly}
                  onClick={handleFavoritesFilter}
                >
                  <Star size={12} />
                  Favorites Only
                </FilterOption>
                <FilterOption
                  active={filters.showWithAIOnly}
                  onClick={handleAIFilter}
                >
                  <Eye size={12} />
                  With AI Analysis
                </FilterOption>
              </FilterOptions>
            </FilterGroup>
            
            {uniqueTags.length > 0 && (
              <FilterGroup>
                <FilterGroupTitle>Tags</FilterGroupTitle>
                <FilterOptions>
                  {uniqueTags.slice(0, 10).map(tag => (
                    <FilterOption
                      key={tag}
                      active={filters.tags.includes(tag)}
                      onClick={() => handleTagFilter(tag)}
                    >
                      {tag}
                    </FilterOption>
                  ))}
                </FilterOptions>
              </FilterGroup>
            )}
            
            <FilterGroup>
              <FilterGroupTitle>Date Range</FilterGroupTitle>
              <DateRangeFilter>
                <DateInput
                  type="date"
                  onChange={(e) => handleDateRangeChange('start', e.target.value)}
                  value={filters.dateRange.start?.toISOString().split('T')[0] || ''}
                />
                <span>to</span>
                <DateInput
                  type="date"
                  onChange={(e) => handleDateRangeChange('end', e.target.value)}
                  value={filters.dateRange.end?.toISOString().split('T')[0] || ''}
                />
              </DateRangeFilter>
            </FilterGroup>
            
            <div style={{ display: 'flex', justifyContent: 'flex-end', marginTop: '1rem' }}>
              <FilterOption
                active={false}
                onClick={handleClearFilters}
                style={{ background: 'transparent', border: '1px dashed' }}
              >
                Clear All Filters
              </FilterOption>
            </div>
          </FilterPanel>
        )}
      </AnimatePresence>
      
      {/* Content Area */}
      <ContentArea>
        {filteredItems.length === 0 ? (
          <EmptyContainer>
            <EmptyState
              icon={<Filter size={48} />}
              title="No matching items"
              description="Try adjusting your filters or search query."
              actionLabel="Clear Filters"
              onAction={handleClearFilters}
            />
          </EmptyContainer>
        ) : (
          <ListContainer>
            <AutoSizer>
              {({ height, width }) => (
                <List
                  height={height}
                  width={width}
                  itemCount={filteredItems.length}
                  itemSize={80}
                  overscanCount={5}
                >
                  {Row}
                </List>
              )}
            </AutoSizer>
          </ListContainer>
        )}
      </ContentArea>
    </Container>
  );
};

// ==================== EXPORT ====================

export default ClipboardList;

// Performance optimization
export const MemoizedClipboardList = React.memo(ClipboardList);
