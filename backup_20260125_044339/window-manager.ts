/**
 * Knoux Clipboard AI - Window Manager
 * Manages application window state, positioning, and behavior
 * Generated by Knoux — Abu Retaj
 * Clipboard Intelligence • Desktop Precision • Premium Engineering
 */

import { BrowserWindow, screen, Rectangle } from 'electron';
import { join } from 'path';
import { llog } from '../shared/localized-logger';
import { AppConfig } from '../shared/config-schema';
import { UI } from '../shared/constants';

// ==================== TYPES ====================

/**
 * Window state for persistence
 */
export interface WindowState {
  x: number;
  y: number;
  width: number;
  height: number;
  isMaximized: boolean;
  isMinimized: boolean;
  displayBounds: Rectangle;
  timestamp: number;
}

/**
 * Window manager configuration
 */
export interface WindowManagerConfig {
  rememberPosition: boolean;
  defaultWidth: number;
  defaultHeight: number;
  minWidth: number;
  minHeight: number;
  maxWidth: number;
  maxHeight: number;
  alwaysOnTop: boolean;
  startMinimized: boolean;
  minimizeToTray: boolean;
}

// ==================== CONSTANTS ====================

/**
 * Window state file name
 */
const WINDOW_STATE_FILE = 'window-state.json';

/**
 * Minimum distance from screen edge
 */
const SCREEN_EDGE_MARGIN = 32;

/**
 * Maximum window state age (7 days)
 */
const MAX_STATE_AGE_MS = 7 * 24 * 60 * 60 * 1000;

// ==================== WINDOW MANAGER CLASS ====================

export class WindowManager {
  private window: BrowserWindow;
  private config: WindowManagerConfig;
  private logger = createLogger({ module: 'window-manager' });
  private state: WindowState | null = null;
  private stateFilePath: string;
  private isInitialized = false;
  private restoreCallbacks: Array<() => void> = [];

  constructor(window: BrowserWindow, config: AppConfig) {
    this.window = window;
    this.config = this.mapConfig(config);
    this.stateFilePath = join(this.getAppDataPath(), WINDOW_STATE_FILE);
    
    this.initialize();
  }

  // ==================== INITIALIZATION ====================

  /**
   * Map application config to window manager config
   */
  private mapConfig(config: AppConfig): WindowManagerConfig {
    return {
      rememberPosition: config.ui.window.rememberPosition,
      defaultWidth: config.ui.window.defaultWidth,
      defaultHeight: config.ui.window.defaultHeight,
      minWidth: config.ui.window.minWidth,
      minHeight: config.ui.window.minHeight,
      maxWidth: config.ui.window.maxWidth,
      maxHeight: config.ui.window.maxHeight,
      alwaysOnTop: config.ui.window.alwaysOnTop,
      startMinimized: config.ui.window.startMinimized,
      minimizeToTray: config.ui.window.minimizeToTray,
    };
  }

  /**
   * Initialize window manager
   */
  private initialize(): void {
    if (this.isInitialized) {
      return;
    }

    this.llog.info('Initializing window manager', {
      config: this.config,
    });

    // Load saved window state
    if (this.config.rememberPosition) {
      this.loadWindowState();
    }

    // Setup window event handlers
    this.setupWindowEvents();

    // Apply initial window state
    this.applyWindowState();

    this.isInitialized = true;
    this.llog.debug('Window manager initialized');
  }

  // ==================== WINDOW STATE MANAGEMENT ====================

  /**
   * Get application data path
   */
  private getAppDataPath(): string {
    const { app } = require('electron');
    return app.getPath('userData');
  }

  /**
   * Load saved window state from file
   */
  private loadWindowState(): void {
    try {
      const fs = require('fs');
      const path = require('path');

      if (!fs.existsSync(this.stateFilePath)) {
        this.llog.debug('No saved window state found');
        return;
      }

      const stateData = fs.readFileSync(this.stateFilePath, 'utf8');
      const savedState = JSON.parse(stateData) as WindowState;

      // Validate state age
      const stateAge = Date.now() - savedState.timestamp;
      if (stateAge > MAX_STATE_AGE_MS) {
        this.llog.debug('Saved window state is too old, ignoring', {
          ageDays: Math.floor(stateAge / (24 * 60 * 60 * 1000)),
        });
        return;
      }

      // Validate state against current display
      if (this.isStateValid(savedState)) {
        this.state = savedState;
        this.llog.debug('Window state loaded successfully', {
          state: savedState,
        });
      } else {
        this.llog.debug('Saved window state is invalid for current display');
      }

    } catch (error) {
      this.llog.error('Failed to load window state', error as Error, {
        filePath: this.stateFilePath,
      });
    }
  }

  /**
   * Save current window state to file
   */
  public saveWindowState(): void {
    if (!this.config.rememberPosition || this.window.isDestroyed()) {
      return;
    }

    try {
      const state = this.getCurrentWindowState();
      if (!this.isStateValid(state)) {
        this.llog.debug('Current window state is invalid, not saving');
        return;
      }

      const fs = require('fs');
      const path = require('path');

      // Ensure directory exists
      const stateDir = require('path').dirname(this.stateFilePath);
      if (!fs.existsSync(stateDir)) {
        fs.mkdirSync(stateDir, { recursive: true });
      }

      // Save state to file
      fs.writeFileSync(
        this.stateFilePath,
        JSON.stringify(state, null, 2),
        'utf8'
      );

      this.llog.debug('Window state saved', {
        filePath: this.stateFilePath,
        state,
      });

    } catch (error) {
      this.llog.error('Failed to save window state', error as Error, {
        filePath: this.stateFilePath,
      });
    }
  }

  /**
   * Get current window state
   */
  private getCurrentWindowState(): WindowState {
    const bounds = this.window.getBounds();
    const display = screen.getDisplayNearestPoint({
      x: bounds.x + bounds.width / 2,
      y: bounds.y + bounds.height / 2,
    });

    return {
      x: bounds.x,
      y: bounds.y,
      width: bounds.width,
      height: bounds.height,
      isMaximized: this.window.isMaximized(),
      isMinimized: this.window.isMinimized(),
      displayBounds: display.bounds,
      timestamp: Date.now(),
    };
  }

  /**
   * Check if window state is valid for current display configuration
   */
  private isStateValid(state: WindowState): boolean {
    // Check if state exists
    if (!state) {
      return false;
    }

    // Check timestamp
    if (Date.now() - state.timestamp > MAX_STATE_AGE_MS) {
      return false;
    }

    // Check bounds are valid numbers
    if (
      !Number.isFinite(state.x) ||
      !Number.isFinite(state.y) ||
      !Number.isFinite(state.width) ||
      !Number.isFinite(state.height)
    ) {
      return false;
    }

    // Check minimum size
    if (
      state.width < this.config.minWidth ||
      state.height < this.config.minHeight
    ) {
      return false;
    }

    // Check if window would be visible on any display
    const displays = screen.getAllDisplays();
    let isVisible = false;

    for (const display of displays) {
      const windowRect = {
        x: state.x,
        y: state.y,
        width: state.width,
        height: state.height,
      };

      const intersection = this.getRectIntersection(windowRect, display.bounds);
      const intersectionArea = intersection.width * intersection.height;
      const windowArea = windowRect.width * windowRect.height;

      // Window is considered visible if at least 25% is on screen
      if (intersectionArea > windowArea * 0.25) {
        isVisible = true;
        break;
      }
    }

    if (!isVisible) {
      this.llog.debug('Window state would not be visible on any display');
      return false;
    }

    return true;
  }

  /**
   * Calculate intersection of two rectangles
   */
  private getRectIntersection(rect1: Rectangle, rect2: Rectangle): Rectangle {
    const x1 = Math.max(rect1.x, rect2.x);
    const y1 = Math.max(rect1.y, rect2.y);
    const x2 = Math.min(rect1.x + rect1.width, rect2.x + rect2.width);
    const y2 = Math.min(rect1.y + rect1.height, rect2.y + rect2.height);

    return {
      x: x1,
      y: y1,
      width: Math.max(0, x2 - x1),
      height: Math.max(0, y2 - y1),
    };
  }

  // ==================== WINDOW POSITIONING ====================

  /**
   * Apply window state (saved or default)
   */
  private applyWindowState(): void {
    if (this.state && this.config.rememberPosition) {
      this.restoreWindowState();
    } else {
      this.applyDefaultPosition();
    }

    // Apply window constraints
    this.applyWindowConstraints();

    // Apply always on top
    this.window.setAlwaysOnTop(this.config.alwaysOnTop);

    // Register callback for when window is ready
    this.restoreCallbacks.push(() => {
      if (this.state?.isMaximized && !this.config.startMinimized) {
        this.window.maximize();
      }

      if (this.config.startMinimized) {
        this.window.minimize();
      }
    });
  }

  /**
   * Restore window from saved state
   */
  public restoreWindowState(): void {
    if (!this.state) {
      this.llog.debug('No window state to restore');
      return;
    }

    try {
      // Set window bounds
      this.window.setBounds({
        x: this.state.x,
        y: this.state.y,
        width: this.state.width,
        height: this.state.height,
      });

      this.llog.debug('Window state restored', {
        state: this.state,
      });

    } catch (error) {
      this.llog.error('Failed to restore window state', error as Error, {
        state: this.state,
      });
      this.applyDefaultPosition();
    }
  }

  /**
   * Apply default window position (centered on primary display)
   */
  private applyDefaultPosition(): void {
    const primaryDisplay = screen.getPrimaryDisplay();
    const { width, height } = primaryDisplay.workAreaSize;

    const windowWidth = Math.min(
      this.config.defaultWidth,
      width - SCREEN_EDGE_MARGIN * 2
    );
    const windowHeight = Math.min(
      this.config.defaultHeight,
      height - SCREEN_EDGE_MARGIN * 2
    );

    const x = Math.floor((width - windowWidth) / 2);
    const y = Math.floor((height - windowHeight) / 2);

    this.window.setBounds({ x, y, width: windowWidth, height: windowHeight });

    this.llog.debug('Applied default window position', {
      x,
      y,
      width: windowWidth,
      height: windowHeight,
      displaySize: { width, height },
    });
  }

  /**
   * Apply window constraints (min/max size)
   */
  private applyWindowConstraints(): void {
    // Set minimum size
    this.window.setMinimumSize(this.config.minWidth, this.config.minHeight);

    // Set maximum size (0 means unlimited in Electron)
    const maxWidth = this.config.maxWidth > 0 ? this.config.maxWidth : undefined;
    const maxHeight = this.config.maxHeight > 0 ? this.config.maxHeight : undefined;
    
    if (maxWidth !== undefined || maxHeight !== undefined) {
      this.window.setMaximumSize(
        maxWidth || 0,
        maxHeight || 0
      );
    }

    this.llog.debug('Window constraints applied', {
      minWidth: this.config.minWidth,
      minHeight: this.config.minHeight,
      maxWidth: maxWidth,
      maxHeight: maxHeight,
    });
  }

  /**
   * Ensure window is visible on screen
   */
  private ensureWindowVisible(): void {
    const bounds = this.window.getBounds();
    const displays = screen.getAllDisplays();

    let isVisible = false;

    for (const display of displays) {
      const intersection = this.getRectIntersection(bounds, display.bounds);
      if (intersection.width > 0 && intersection.height > 0) {
        isVisible = true;
        break;
      }
    }

    if (!isVisible) {
      this.llog.debug('Window is not visible on any display, repositioning');
      this.applyDefaultPosition();
    }
  }

  // ==================== WINDOW EVENT HANDLERS ====================

  /**
   * Setup window event handlers
   */
  private setupWindowEvents(): void {
    // Save state on move/resize
    this.window.on('move', () => {
      if (this.config.rememberPosition && !this.window.isMaximized()) {
        this.saveWindowState();
      }
    });

    this.window.on('resize', () => {
      if (this.config.rememberPosition && !this.window.isMaximized()) {
        this.saveWindowState();
      }
    });

    // Save state on close
    this.window.on('close', (event) => {
      if (this.config.rememberPosition) {
        this.saveWindowState();
      }
    });

    // Handle restore from minimized/maximized
    this.window.on('restore', () => {
      if (this.config.rememberPosition) {
        // Small delay to ensure window is properly restored
        setTimeout(() => {
          this.saveWindowState();
        }, 100);
      }
    });

    // Handle maximize/unmaximize
    this.window.on('maximize', () => {
      if (this.config.rememberPosition) {
        this.saveWindowState();
      }
    });

    this.window.on('unmaximize', () => {
      if (this.config.rememberPosition) {
        // Small delay to ensure window is properly unmaximized
        setTimeout(() => {
          this.saveWindowState();
        }, 100);
      }
    });

    // Handle display changes
    screen.on('display-metrics-changed', () => {
      this.llog.debug('Display configuration changed');
      this.ensureWindowVisible();
    });

    // Window ready callback
    this.window.on('ready-to-show', () => {
      // Execute restore callbacks
      this.restoreCallbacks.forEach(callback => callback());
      this.restoreCallbacks = [];
    });
  }

  // ==================== PUBLIC METHODS ====================

  /**
   * Update configuration
   */
  public updateConfig(config: AppConfig): void {
    const newConfig = this.mapConfig(config);
    const configChanged = JSON.stringify(this.config) !== JSON.stringify(newConfig);
    
    this.config = newConfig;

    if (configChanged) {
      this.llog.info('Window manager configuration updated', {
        newConfig: this.config,
      });

      // Re-apply constraints if they changed
      this.applyWindowConstraints();

      // Update always on top
      this.window.setAlwaysOnTop(this.config.alwaysOnTop);
    }
  }

  /**
   * Center window on current display
   */
  public centerWindow(): void {
    const display = screen.getDisplayNearestPoint(this.window.getBounds());
    const { width, height } = display.workAreaSize;
    const bounds = this.window.getBounds();

    const x = Math.floor((width - bounds.width) / 2);
    const y = Math.floor((height - bounds.height) / 2);

    this.window.setPosition(x, y);

    this.llog.debug('Window centered', {
      x,
      y,
      displaySize: { width, height },
    });
  }

  /**
   * Toggle always on top
   */
  public toggleAlwaysOnTop(): void {
    const newState = !this.window.isAlwaysOnTop();
    this.window.setAlwaysOnTop(newState);
    
    this.config.alwaysOnTop = newState;
    
    this.llog.debug('Always on top toggled', {
      alwaysOnTop: newState,
    });
  }

  /**
   * Get current window bounds
   */
  public getWindowBounds(): Rectangle {
    return this.window.getBounds();
  }

  /**
   * Check if window is visible
   */
  public isWindowVisible(): boolean {
    return this.window.isVisible();
  }

  /**
   * Show and focus window
   */
  public showAndFocusWindow(): void {
    if (this.window.isMinimized()) {
      this.window.restore();
    }
    
    this.window.show();
    this.window.focus();
    
    this.llog.debug('Window shown and focused');
  }

  /**
   * Minimize window to tray (if configured)
   */
  public minimizeToTray(): void {
    if (this.config.minimizeToTray) {
      this.window.hide();
      this.llog.debug('Window minimized to tray');
    } else {
      this.window.minimize();
    }
  }

  /**
   * Cleanup resources
   */
  public destroy(): void {
    // Save state one last time
    this.saveWindowState();

    // Clear callbacks
    this.restoreCallbacks = [];

    this.llog.info('Window manager destroyed');
  }
}

