/**
 * Knoux Clipboard AI - TypeScript Type Definitions
 * Unified type definitions for data exchange across components
 * Generated by Knoux — Abu Retaj
 * Clipboard Intelligence • Desktop Precision • Premium Engineering
 */

/**
 * Result wrapper for operations that can succeed or fail
 */
export type Result<T, E = Error> = 
  | { success: true; data: T }
  | { success: false; error: E };

/**
 * Async result wrapper
 */
export type AsyncResult<T, E = Error> = Promise<Result<T, E>>;

/**
 * Generic response wrapper for API calls
 */
export interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  error?: string;
  code?: number;
  timestamp: Date;
  requestId?: string;
}

/**
 * Clipboard item representing a single clipboard entry
 */
export interface ClipboardItem {
  id: string;
  content: string;
  format: ClipboardFormat;
  metadata: ClipboardMetadata;
  classification: ContentClassification;
  summary?: string;
  keyPoints: string[];
  favorites: boolean;
  pinned: boolean;
  lastAccessed: Date;
  accessCount: number;
  version: number;
  compressed?: boolean;
  encrypted?: boolean;
}

/**
 * Clipboard metadata
 */
export interface ClipboardMetadata {
  timestamp: Date;
  sourceApp: string;
  sourceWindow?: string;
  contentType: string;
  language?: ProgrammingLanguage;
  isSensitive: boolean;
  sensitiveType?: string;
  sizeBytes: number;
  lineCount: number;
  wordCount: number;
  hasHtml: boolean;
  hasRtf: boolean;
  hasImage: boolean;
  tags: string[];
  encrypted?: boolean;
  compressionMethod?: CompressionMethod;
  encryptionTimestamp?: Date;
}

/**
 * Content classification result
 */
export interface ContentClassification {
  primaryType: string;
  secondaryTypes: string[];
  confidence: number;
  language?: ProgrammingLanguage;
  framework?: string;
  isSensitive: boolean;
  sensitiveType?: string;
  patterns: ClassificationPattern[];
}

/**
 * Classification pattern detection
 */
export interface ClassificationPattern {
  type: string;
  pattern: string;
  confidence: number;
  location: TextLocation;
}

/**
 * Text location within content
 */
export interface TextLocation {
  start: number;
  end: number;
  line: number;
  column: number;
}

/**
 * AI analysis result
 */
export interface AIAnalysis {
  id: string;
  itemId: string;
  summary: string;
  suggestions: AISuggestion[];
  complexity: number;
  quality: number;
  potentialIssues: string[];
  improvements: string[];
  similarPastItems: string[];
  generatedAt: Date;
  modelUsed: string;
  processingTimeMs: number;
}

/**
 * AI suggestion for content improvement
 */
export interface AISuggestion {
  id: string;
  type: SuggestionCategory;
  title: string;
  description: string;
  priority: 'low' | 'medium' | 'high' | 'critical';
  confidence: number;
  action?: SuggestionAction;
  applyAutomatically: boolean;
  applied?: boolean;
  appliedAt?: Date;
}

/**
 * Suggestion action to apply
 */
export interface SuggestionAction {
  type: 'replace' | 'append' | 'prepend' | 'execute' | 'transform';
  content?: string;
  command?: string;
  parameters?: Record<string, any>;
  targetRange?: TextLocation;
}

/**
 * Clipboard change event
 */
export interface ClipboardEvent {
  type: 'added' | 'updated' | 'removed' | 'cleared';
  item?: ClipboardItem;
  timestamp: Date;
  source: 'user' | 'system' | 'ai';
}

/**
 * Search filter for querying clipboard history
 */
export interface SearchFilter {
  type: 'contentType' | 'dateRange' | 'hasSensitive' | 'minSize' | 'maxSize' | 'tags';
  value?: any;
  startDate?: Date;
  endDate?: Date;
  operator?: 'equals' | 'contains' | 'startsWith' | 'endsWith' | 'greaterThan' | 'lessThan';
}

/**
 * Clipboard watcher state
 */
export interface WatcherState {
  isActive: boolean;
  lastChange: Date | null;
  changeCount: number;
  errorCount: number;
  mode: DetectionMode;
}

/**
 * AI model configuration
 */
export interface AIModelConfig {
  id: string;
  name: string;
  type: AIModelType;
  provider: string;
  version: string;
  capabilities: string[];
  contextSize: number;
  maxTokens: number;
  isLocal: boolean;
  isLoaded: boolean;
  memoryUsageMB: number;
  performanceScore: number;
}

/**
 * AI processing request
 */
export interface AIRequest {
  id: string;
  content: string;
  operation: AIOperation;
  options: AIRequestOptions;
  priority: AITaskPriority;
  status: AIRequestStatus;
  createdAt: Date;
  startedAt?: Date;
  completedAt?: Date;
  result?: any;
  error?: string;
}

/**
 * AI request options
 */
export interface AIRequestOptions {
  model?: string;
  temperature?: number;
  maxTokens?: number;
  topP?: number;
  frequencyPenalty?: number;
  presencePenalty?: number;
  stopSequences?: string[];
  timeoutMs?: number;
  retryAttempts?: number;
}

/**
 * User preferences and settings
 */
export interface UserPreferences {
  // General
  language: string;
  theme: 'light' | 'dark' | 'auto';
  fontSize: number;
  animations: boolean;
  tooltips: boolean;
  notifications: boolean;
  
  // Clipboard
  autoStart: boolean;
  pollInterval: number;
  maxHistoryItems: number;
  captureImages: boolean;
  captureHtml: boolean;
  captureRtf: boolean;
  autoClearSensitive: boolean;
  autoClearMinutes: number;
  
  // AI
  aiEnabled: boolean;
  defaultModel: string;
  autoEnhance: boolean;
  autoSummarize: boolean;
  autoClassify: boolean;
  confidenceThreshold: number;
  useCloudModels: boolean;
  
  // Security
  encryptSensitive: boolean;
  requirePassword: boolean;
  autoLockMinutes: number;
  clearClipboardOnExit: boolean;
  anonymizeData: boolean;
  
  // Performance
  cacheEnabled: boolean;
  cacheSizeMB: number;
  workerCount: number;
  compressionLevel: number;
  
  // UI
  showLineNumbers: boolean;
  wordWrap: boolean;
  tabSize: number;
  fontFamily: string;
  sidebarPosition: 'left' | 'right';
  defaultView: 'list' | 'grid' | 'detailed';
}

/**
 * Application statistics
 */
export interface AppStatistics {
  // General
  uptimeMs: number;
  startTime: Date;
  version: string;
  
  // Clipboard
  totalClipboardChanges: number;
  clipboardHistorySize: number;
  clipboardMemoryUsage: number;
  lastClipboardChange: Date | null;
  
  // AI
  totalAIRequests: number;
  successfulAIRequests: number;
  failedAIRequests: number;
  averageAITimeMs: number;
  tokensUsed: number;
  estimatedCost: number;
  
  // Storage
  storageSize: number;
  itemsByType: Record<string, number>;
  compressionRatio: number;
  encryptedItems: number;
  
  // Performance
  memoryUsage: number;
  cpuUsage: number;
  diskUsage: number;
  cacheHitRate: number;
  
  // User
  favoriteItems: number;
  pinnedItems: number;
  tagsCreated: number;
  searchesPerformed: number;
}

/**
 * IPC message structure
 */
export interface IPCMessage {
  channel: string;
  id: string;
  timestamp: Date;
  payload: any;
  responseChannel?: string;
  correlationId?: string;
  requiresResponse: boolean;
}

/**
 * IPC response structure
 */
export interface IPCResponse {
  success: boolean;
  id: string;
  timestamp: Date;
  data?: any;
  error?: string;
  correlationId?: string;
}

/**
 * Notification message
 */
export interface Notification {
  id: string;
  type: 'info' | 'success' | 'warning' | 'error';
  title: string;
  message: string;
  timestamp: Date;
  read: boolean;
  actions?: NotificationAction[];
  duration?: number;
  priority: 'low' | 'medium' | 'high';
}

/**
 * Notification action
 */
export interface NotificationAction {
  label: string;
  action: string;
  primary?: boolean;
  destructive?: boolean;
}

/**
 * Context menu item
 */
export interface ContextMenuItem {
  id: string;
  label: string;
  action: string;
  icon?: string;
  shortcut?: string;
  disabled?: boolean;
  checked?: boolean;
  submenu?: ContextMenuItem[];
  separator?: boolean;
}

/**
 * Keyboard shortcut definition
 */
export interface KeyboardShortcut {
  id: string;
  key: string;
  modifiers?: ('ctrl' | 'shift' | 'alt' | 'cmd')[];
  description: string;
  global: boolean;
  enabled: boolean;
  action: string;
}

/**
 * Theme configuration
 */
export interface Theme {
  id: string;
  name: string;
  type: 'light' | 'dark';
  colors: {
    primary: string;
    secondary: string;
    background: string;
    surface: string;
    error: string;
    warning: string;
    success: string;
    info: string;
    text: {
      primary: string;
      secondary: string;
      disabled: string;
    };
    border: string;
    hover: string;
    focus: string;
  };
  fonts: {
    family: string;
    sizes: {
      small: number;
      medium: number;
      large: number;
      xlarge: number;
    };
  };
  spacing: {
    unit: number;
    small: number;
    medium: number;
    large: number;
  };
  borderRadius: number;
  shadows: string[];
}

/**
 * Plugin manifest
 */
export interface PluginManifest {
  id: string;
  name: string;
  version: string;
  author: string;
  description: string;
  icon?: string;
  homepage?: string;
  repository?: string;
  license?: string;
  
  // Capabilities
  capabilities: string[];
  permissions: string[];
  
  // Entry points
  main: string;
  preload?: string;
  
  // Dependencies
  dependencies?: Record<string, string>;
  peerDependencies?: Record<string, string>;
  
  // Configuration
  configSchema?: any;
  defaultConfig?: any;
  
  // Metadata
  tags?: string[];
  keywords?: string[];
}

/**
 * Plugin instance
 */
export interface PluginInstance {
  id: string;
  manifest: PluginManifest;
  enabled: boolean;
  loaded: boolean;
  path: string;
  config: any;
  exports?: any;
}

/**
 * Update information
 */
export interface UpdateInfo {
  available: boolean;
  version?: string;
  releaseDate?: Date;
  releaseNotes?: string;
  downloadUrl?: string;
  size?: number;
  mandatory: boolean;
}

/**
 * System information
 */
export interface SystemInfo {
  // Platform
  platform: NodeJS.Platform;
  arch: string;
  version: string;
  release: string;
  
  // Application
  appVersion: string;
  electronVersion: string;
  chromeVersion: string;
  nodeVersion: string;
  v8Version: string;
  
  // Hardware
  memory: {
    total: number;
    free: number;
    used: number;
  };
  cpus: {
    model: string;
    speed: number;
    cores: number;
  }[];
  
  // Storage
  storage: {
    total: number;
    free: number;
    used: number;
  };
  
  // Display
  display: {
    width: number;
    height: number;
    scaleFactor: number;
  };
  
  // Network
  network: {
    online: boolean;
    type?: string;
    speed?: number;
  };
}

/**
 * Error report
 */
export interface ErrorReport {
  id: string;
  timestamp: Date;
  error: {
    name: string;
    message: string;
    stack: string;
    code?: string;
  };
  context: {
    module: string;
    function: string;
    state?: any;
  };
  system: SystemInfo;
  userActions: string[];
  appState: any;
  reported: boolean;
}

/**
 * Backup information
 */
export interface BackupInfo {
  id: string;
  timestamp: Date;
  size: number;
  items: number;
  version: string;
  location: string;
  encrypted: boolean;
  compressed: boolean;
  metadata: Record<string, any>;
}

/**
 * Export options
 */
export interface ExportOptions {
  format: 'json' | 'csv' | 'txt' | 'html';
  includeSensitive: boolean;
  includeMetadata: boolean;
  includeAIResults: boolean;
  compress: boolean;
  encrypt: boolean;
  password?: string;
}

/**
 * Import options
 */
export interface ImportOptions {
  format: 'json' | 'csv' | 'txt' | 'html';
  merge: boolean;
  overwrite: boolean;
  skipDuplicates: boolean;
  validate: boolean;
  password?: string;
}

/**
 * Batch operation result
 */
export interface BatchResult {
  total: number;
  successful: number;
  failed: number;
  errors: Array<{
    item: any;
    error: string;
  }>;
  processingTime: number;
}

/**
 * Pagination parameters
 */
export interface PaginationParams {
  page: number;
  pageSize: number;
  total: number;
  sortBy?: string;
  sortDirection?: 'asc' | 'desc';
}

/**
 * Paginated response
 */
export interface PaginatedResponse<T> {
  items: T[];
  pagination: PaginationParams;
}

/**
 * Validation result
 */
export interface ValidationResult {
  valid: boolean;
  errors: string[];
  warnings: string[];
  fixes?: string[];
}

/**
 * Performance metrics
 */
export interface PerformanceMetrics {
  timestamp: Date;
  memory: {
    heapUsed: number;
    heapTotal: number;
    external: number;
    arrayBuffers: number;
  };
  cpu: {
    user: number;
    system: number;
    idle: number;
  };
  network: {
    requests: number;
    bytesSent: number;
    bytesReceived: number;
  };
  database: {
    queries: number;
    queryTime: number;
    connections: number;
  };
  rendering: {
    fps: number;
    frameTime: number;
    paintTime: number;
  };
}

/**
 * Cache entry
 */
export interface CacheEntry<T = any> {
  key: string;
  value: T;
  timestamp: Date;
  expiresAt: Date;
  hits: number;
  size: number;
  tags: string[];
}

/**
 * Cache statistics
 */
export interface CacheStats {
  size: number;
  entries: number;
  hits: number;
  misses: number;
  hitRate: number;
  memoryUsage: number;
  oldestEntry: Date | null;
  newestEntry: Date | null;
}

/**
 * Worker task
 */
export interface WorkerTask<T = any, R = any> {
  id: string;
  type: string;
  data: T;
  priority: number;
  createdAt: Date;
  startedAt?: Date;
  completedAt?: Date;
  result?: R;
  error?: string;
  retries: number;
  maxRetries: number;
  timeout: number;
}

/**
 * Worker status
 */
export interface WorkerStatus {
  id: string;
  type: string;
  busy: boolean;
  currentTask?: string;
  tasksCompleted: number;
  tasksFailed: number;
  uptime: number;
  memoryUsage: number;
  cpuUsage: number;
}

/**
 * Event listener
 */
export interface EventListener {
  id: string;
  event: string;
  callback: Function;
  once: boolean;
  context?: any;
}

/**
 * Middleware function
 */
export type Middleware<T = any> = (
  context: T,
  next: () => Promise<void>
) => Promise<void>;

/**
 * Transformer function
 */
export type Transformer<T = any, R = any> = (
  input: T,
  context?: any
) => R | Promise<R>;

/**
 * Validator function
 */
export type Validator<T = any> = (
  value: T
) => ValidationResult | Promise<ValidationResult>;

/**
 * Filter function
 */
export type Filter<T = any> = (
  item: T,
  index: number,
  array: T[]
) => boolean | Promise<boolean>;

/**
 * Comparator function
 */
export type Comparator<T = any> = (
  a: T,
  b: T
) => number;

/**
 * Reducer function
 */
export type Reducer<T = any, R = any> = (
  accumulator: R,
  current: T,
  index: number,
  array: T[]
) => R | Promise<R>;

/**
 * Mapper function
 */
export type Mapper<T = any, R = any> = (
  item: T,
  index: number,
  array: T[]
) => R | Promise<R>;

/**
 * Formatter function
 */
export type Formatter<T = any> = (
  value: T,
  format: string,
  options?: any
) => string | Promise<string>;

/**
 * Parser function
 */
export type Parser<T = any> = (
  text: string,
  format: string,
  options?: any
) => T | Promise<T>;

/**
 * Encoder function
 */
export type Encoder<T = any> = (
  data: T,
  options?: any
) => string | Buffer | Promise<string | Buffer>;

/**
 * Decoder function
 */
export type Decoder<T = any> = (
  data: string | Buffer,
  options?: any
) => T | Promise<T>;

/**
 * Type guards for runtime type checking
 */
export type TypeGuard<T = any> = (value: any) => value is T;

/**
 * Configuration schema for validation
 */
export interface ConfigSchema {
  type: 'object' | 'array' | 'string' | 'number' | 'boolean' | 'null';
  properties?: Record<string, ConfigSchema>;
  items?: ConfigSchema;
  required?: string[];
  enum?: any[];
  default?: any;
  minimum?: number;
  maximum?: number;
  minLength?: number;
  maxLength?: number;
  pattern?: string;
  format?: string;
  description?: string;
  title?: string;
}

/**
 * Generic event with payload
 */
export interface GenericEvent<T = any> {
  type: string;
  payload: T;
  timestamp: Date;
  source: string;
  correlationId?: string;
}

/**
 * Generic command for CQRS pattern
 */
export interface Command<T = any> {
  type: string;
  payload: T;
  timestamp: Date;
  correlationId?: string;
  metadata?: Record<string, any>;
}

/**
 * Generic query for CQRS pattern
 */
export interface Query<T = any> {
  type: string;
  params: T;
  timestamp: Date;
  correlationId?: string;
  metadata?: Record<string, any>;
}

/**
 * Generic state container
 */
export interface StateContainer<T = any> {
  state: T;
  version: number;
  timestamp: Date;
  previousState?: T;
  actions: string[];
}

/**
 * Generic action for state management
 */
export interface Action<T = any> {
  type: string;
  payload?: T;
  timestamp: Date;
  correlationId?: string;
  metadata?: Record<string, any>;
}

/**
 * Generic reducer for state management
 */
export interface StateReducer<T = any, A = Action> {
  (state: T, action: A): T | Promise<T>;
}

/**
 * Generic middleware for state management
 */
export interface StateMiddleware<T = any, A = Action> {
  (store: { getState: () => T; dispatch: (action: A) => void }, next: (action: A) => void, action: A): void | Promise<void>;
}

/**
 * Generic selector for state
 */
export interface Selector<T = any, R = any> {
  (state: T): R;
}

/**
 * Generic resolver for async operations
 */
export interface Resolver<T = any, R = any> {
  (parent: any, args: T, context: any, info: any): R | Promise<R>;
}

/**
 * Generic subscription for real-time updates
 */
export interface Subscription<T = any> {
  event: string;
  filter?: (payload: T) => boolean;
  callback: (payload: T) => void;
  unsubscribe: () => void;
}

/**
 * Generic observable pattern
 */
export interface Observable<T = any> {
  subscribe: (observer: Observer<T>) => Subscription<T>;
  unsubscribe: (subscription: Subscription<T>) => void;
  next: (value: T) => void;
  error: (error: any) => void;
  complete: () => void;
}

/**
 * Generic observer pattern
 */
export interface Observer<T = any> {
  next: (value: T) => void;
  error: (error: any) => void;
  complete: () => void;
}

/**
 * Generic iterator for collections
 */
export interface AsyncIterator<T = any> {
  next: () => Promise<IteratorResult<T>>;
  return?: (value?: T) => Promise<IteratorResult<T>>;
  throw?: (error: any) => Promise<IteratorResult<T>>;
}

/**
 * Generic stream for data flow
 */
export interface Stream<T = any> {
  pipe: (destination: Stream<T> | Transformer<T, any>) => Stream<any>;
  on: (event: string, handler: Function) => void;
  off: (event: string, handler: Function) => void;
  emit: (event: string, data: any) => void;
  end: () => void;
}

/**
 * Generic pipeline for data processing
 */
export interface Pipeline<T = any, R = any> {
  process: (input: T) => Promise<R>;
  addStage: (stage: Transformer<any, any>) => void;
  removeStage: (stage: Transformer<any, any>) => void;
  clear: () => void;
}

// Re-export common types from Node.js for convenience
export type { Readable, Writable, Duplex, Transform } from 'stream';
export type { EventEmitter } from 'events';
export type { Stats } from 'fs';

// Export utility types
export type Nullable<T> = T | null;
export type Optional<T> = T | undefined;
export type Maybe<T> = T | null | undefined;
export type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
export type RequiredBy<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;
export type ReadonlyBy<T, K extends keyof T> = Omit<T, K> & Readonly<Pick<T, K>>;
export type Mutable<T> = { -readonly [P in keyof T]: T[P] };
export type DeepPartial<T> = T extends object ? { [P in keyof T]?: DeepPartial<T[P]> } : T;
export type DeepReadonly<T> = T extends object ? { readonly [P in keyof T]: DeepReadonly<T[P]> } : T;
export type DeepRequired<T> = T extends object ? { [P in keyof T]-?: DeepRequired<T[P]> } : T;
export type ValueOf<T> = T[keyof T];
export type ArrayElement<A> = A extends readonly (infer T)[] ? T : never;
export type PromiseType<T> = T extends Promise<infer U> ? U : T;
export type AsyncReturnType<T extends (...args: any) => any> = PromiseType<ReturnType<T>>;
export type Constructor<T = any> = new (...args: any[]) => T;
export type AbstractConstructor<T = any> = abstract new (...args: any[]) => T;
export type InstanceType<T extends Constructor> = T extends Constructor<infer U> ? U : never;
export type AbstractInstanceType<T extends AbstractConstructor> = T extends AbstractConstructor<infer U> ? U : never;
export type ClassDecorator = <T extends Constructor>(target: T) => T | void;
export type PropertyDecorator = (target: Object, propertyKey: string | symbol) => void;
export type MethodDecorator = <T>(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>) => TypedPropertyDescriptor<T> | void;
export type ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number) => void;
